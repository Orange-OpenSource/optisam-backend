// Copyright (C) 2019 Orange
// 
// This software is distributed under the terms and conditions of the 'Apache License 2.0'
// license which can be found in the file 'License.txt' in this package distribution 
// or at 'http://www.apache.org/licenses/LICENSE-2.0'. 

// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const getFileStatus = `-- name: GetFileStatus :one
SELECT status FROM uploaded_data_files WHERE upload_id = $1 AND file_name = $2
`

type GetFileStatusParams struct {
	UploadID int32  `json:"upload_id"`
	FileName string `json:"file_name"`
}

func (q *Queries) GetFileStatus(ctx context.Context, arg GetFileStatusParams) (UploadStatus, error) {
	row := q.db.QueryRowContext(ctx, getFileStatus, arg.UploadID, arg.FileName)
	var status UploadStatus
	err := row.Scan(&status)
	return status, err
}

const insertUploadedData = `-- name: InsertUploadedData :one
INSERT INTO uploaded_data_files (scope,data_type,file_name,uploaded_by)
VALUES($1,$2,$3,$4) returning upload_id, scope, data_type, file_name, status, uploaded_by, uploaded_on, total_records, success_records, failed_records, invalid_records
`

type InsertUploadedDataParams struct {
	Scope      string   `json:"scope"`
	DataType   DataType `json:"data_type"`
	FileName   string   `json:"file_name"`
	UploadedBy string   `json:"uploaded_by"`
}

func (q *Queries) InsertUploadedData(ctx context.Context, arg InsertUploadedDataParams) (UploadedDataFile, error) {
	row := q.db.QueryRowContext(ctx, insertUploadedData,
		arg.Scope,
		arg.DataType,
		arg.FileName,
		arg.UploadedBy,
	)
	var i UploadedDataFile
	err := row.Scan(
		&i.UploadID,
		&i.Scope,
		&i.DataType,
		&i.FileName,
		&i.Status,
		&i.UploadedBy,
		&i.UploadedOn,
		&i.TotalRecords,
		&i.SuccessRecords,
		&i.FailedRecords,
		&i.InvalidRecords,
	)
	return i, err
}

const insertUploadedMetaData = `-- name: InsertUploadedMetaData :one
INSERT INTO uploaded_data_files (file_name,uploaded_by)
VALUES($1,$2) returning upload_id, scope, data_type, file_name, status, uploaded_by, uploaded_on, total_records, success_records, failed_records, invalid_records
`

type InsertUploadedMetaDataParams struct {
	FileName   string `json:"file_name"`
	UploadedBy string `json:"uploaded_by"`
}

func (q *Queries) InsertUploadedMetaData(ctx context.Context, arg InsertUploadedMetaDataParams) (UploadedDataFile, error) {
	row := q.db.QueryRowContext(ctx, insertUploadedMetaData, arg.FileName, arg.UploadedBy)
	var i UploadedDataFile
	err := row.Scan(
		&i.UploadID,
		&i.Scope,
		&i.DataType,
		&i.FileName,
		&i.Status,
		&i.UploadedBy,
		&i.UploadedOn,
		&i.TotalRecords,
		&i.SuccessRecords,
		&i.FailedRecords,
		&i.InvalidRecords,
	)
	return i, err
}

const listUploadedDataFiles = `-- name: ListUploadedDataFiles :many
SELECT count(*) OVER() AS totalRecords,upload_id, scope, data_type, file_name, status, uploaded_by, uploaded_on, total_records, success_records, failed_records, invalid_records from 
uploaded_data_files
WHERE 
    scope = ANY($1::TEXT[])
    AND data_type = 'DATA'
ORDER BY
  CASE WHEN $2::bool THEN upload_id END asc,
  CASE WHEN $3::bool THEN upload_id END desc,
  CASE WHEN $4::bool THEN scope END asc,
  CASE WHEN $5::bool THEN scope END desc,
  CASE WHEN $6::bool THEN file_name END asc,
  CASE WHEN $7::bool THEN file_name END desc,
  CASE WHEN $8::bool THEN status END asc,
  CASE WHEN $9::bool THEN status END desc,  
  CASE WHEN $10::bool THEN uploaded_by END asc,
  CASE WHEN $11::bool THEN uploaded_by END desc,
  CASE WHEN $12::bool THEN uploaded_on END asc,
  CASE WHEN $13::bool THEN uploaded_on END desc
  LIMIT $15 OFFSET $14
`

type ListUploadedDataFilesParams struct {
	Scope          []string `json:"scope"`
	UploadIDAsc    bool     `json:"upload_id_asc"`
	UploadIDDesc   bool     `json:"upload_id_desc"`
	ScopeAsc       bool     `json:"scope_asc"`
	ScopeDesc      bool     `json:"scope_desc"`
	FileNameAsc    bool     `json:"file_name_asc"`
	FileNameDesc   bool     `json:"file_name_desc"`
	StatusAsc      bool     `json:"status_asc"`
	StatusDesc     bool     `json:"status_desc"`
	UploadedByAsc  bool     `json:"uploaded_by_asc"`
	UploadedByDesc bool     `json:"uploaded_by_desc"`
	UploadedOnAsc  bool     `json:"uploaded_on_asc"`
	UploadedOnDesc bool     `json:"uploaded_on_desc"`
	PageNum        int32    `json:"page_num"`
	PageSize       int32    `json:"page_size"`
}

type ListUploadedDataFilesRow struct {
	Totalrecords   int64        `json:"totalrecords"`
	UploadID       int32        `json:"upload_id"`
	Scope          string       `json:"scope"`
	DataType       DataType     `json:"data_type"`
	FileName       string       `json:"file_name"`
	Status         UploadStatus `json:"status"`
	UploadedBy     string       `json:"uploaded_by"`
	UploadedOn     time.Time    `json:"uploaded_on"`
	TotalRecords   int32        `json:"total_records"`
	SuccessRecords int32        `json:"success_records"`
	FailedRecords  int32        `json:"failed_records"`
	InvalidRecords int32        `json:"invalid_records"`
}

func (q *Queries) ListUploadedDataFiles(ctx context.Context, arg ListUploadedDataFilesParams) ([]ListUploadedDataFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedDataFiles,
		pq.Array(arg.Scope),
		arg.UploadIDAsc,
		arg.UploadIDDesc,
		arg.ScopeAsc,
		arg.ScopeDesc,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.UploadedByAsc,
		arg.UploadedByDesc,
		arg.UploadedOnAsc,
		arg.UploadedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUploadedDataFilesRow
	for rows.Next() {
		var i ListUploadedDataFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UploadID,
			&i.Scope,
			&i.DataType,
			&i.FileName,
			&i.Status,
			&i.UploadedBy,
			&i.UploadedOn,
			&i.TotalRecords,
			&i.SuccessRecords,
			&i.FailedRecords,
			&i.InvalidRecords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedMetaDataFiles = `-- name: ListUploadedMetaDataFiles :many
SELECT count(*) OVER() AS totalRecords,upload_id, scope, data_type, file_name, status, uploaded_by, uploaded_on, total_records, success_records, failed_records, invalid_records from 
uploaded_data_files
WHERE data_type = 'METADATA'
ORDER BY
  CASE WHEN $1::bool THEN upload_id END asc,
  CASE WHEN $2::bool THEN upload_id END desc,
  CASE WHEN $3::bool THEN scope END asc,
  CASE WHEN $4::bool THEN scope END desc,
  CASE WHEN $5::bool THEN file_name END asc,
  CASE WHEN $6::bool THEN file_name END desc,
  CASE WHEN $7::bool THEN status END asc,
  CASE WHEN $8::bool THEN status END desc,  
  CASE WHEN $9::bool THEN uploaded_by END asc,
  CASE WHEN $10::bool THEN uploaded_by END desc,
  CASE WHEN $11::bool THEN uploaded_on END asc,
  CASE WHEN $12::bool THEN uploaded_on END desc
  LIMIT $14 OFFSET $13
`

type ListUploadedMetaDataFilesParams struct {
	UploadIDAsc    bool  `json:"upload_id_asc"`
	UploadIDDesc   bool  `json:"upload_id_desc"`
	ScopeAsc       bool  `json:"scope_asc"`
	ScopeDesc      bool  `json:"scope_desc"`
	FileNameAsc    bool  `json:"file_name_asc"`
	FileNameDesc   bool  `json:"file_name_desc"`
	StatusAsc      bool  `json:"status_asc"`
	StatusDesc     bool  `json:"status_desc"`
	UploadedByAsc  bool  `json:"uploaded_by_asc"`
	UploadedByDesc bool  `json:"uploaded_by_desc"`
	UploadedOnAsc  bool  `json:"uploaded_on_asc"`
	UploadedOnDesc bool  `json:"uploaded_on_desc"`
	PageNum        int32 `json:"page_num"`
	PageSize       int32 `json:"page_size"`
}

type ListUploadedMetaDataFilesRow struct {
	Totalrecords   int64        `json:"totalrecords"`
	UploadID       int32        `json:"upload_id"`
	Scope          string       `json:"scope"`
	DataType       DataType     `json:"data_type"`
	FileName       string       `json:"file_name"`
	Status         UploadStatus `json:"status"`
	UploadedBy     string       `json:"uploaded_by"`
	UploadedOn     time.Time    `json:"uploaded_on"`
	TotalRecords   int32        `json:"total_records"`
	SuccessRecords int32        `json:"success_records"`
	FailedRecords  int32        `json:"failed_records"`
	InvalidRecords int32        `json:"invalid_records"`
}

func (q *Queries) ListUploadedMetaDataFiles(ctx context.Context, arg ListUploadedMetaDataFilesParams) ([]ListUploadedMetaDataFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedMetaDataFiles,
		arg.UploadIDAsc,
		arg.UploadIDDesc,
		arg.ScopeAsc,
		arg.ScopeDesc,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.UploadedByAsc,
		arg.UploadedByDesc,
		arg.UploadedOnAsc,
		arg.UploadedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUploadedMetaDataFilesRow
	for rows.Next() {
		var i ListUploadedMetaDataFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UploadID,
			&i.Scope,
			&i.DataType,
			&i.FileName,
			&i.Status,
			&i.UploadedBy,
			&i.UploadedOn,
			&i.TotalRecords,
			&i.SuccessRecords,
			&i.FailedRecords,
			&i.InvalidRecords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileFailedRecord = `-- name: UpdateFileFailedRecord :exec
UPDATE uploaded_data_files SET failed_records = failed_records + $3 where upload_id = $1 AND file_name = $2
`

type UpdateFileFailedRecordParams struct {
	UploadID      int32  `json:"upload_id"`
	FileName      string `json:"file_name"`
	FailedRecords int32  `json:"failed_records"`
}

func (q *Queries) UpdateFileFailedRecord(ctx context.Context, arg UpdateFileFailedRecordParams) error {
	_, err := q.db.ExecContext(ctx, updateFileFailedRecord, arg.UploadID, arg.FileName, arg.FailedRecords)
	return err
}

const updateFileStatus = `-- name: UpdateFileStatus :exec
UPDATE uploaded_data_files SET status = $1 where upload_id = $2 AND file_name = $3
`

type UpdateFileStatusParams struct {
	Status   UploadStatus `json:"status"`
	UploadID int32        `json:"upload_id"`
	FileName string       `json:"file_name"`
}

func (q *Queries) UpdateFileStatus(ctx context.Context, arg UpdateFileStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateFileStatus, arg.Status, arg.UploadID, arg.FileName)
	return err
}

const updateFileSuccessRecord = `-- name: UpdateFileSuccessRecord :exec
UPDATE uploaded_data_files SET success_records = success_records + $3 where upload_id = $1 AND file_name = $2
`

type UpdateFileSuccessRecordParams struct {
	UploadID       int32  `json:"upload_id"`
	FileName       string `json:"file_name"`
	SuccessRecords int32  `json:"success_records"`
}

func (q *Queries) UpdateFileSuccessRecord(ctx context.Context, arg UpdateFileSuccessRecordParams) error {
	_, err := q.db.ExecContext(ctx, updateFileSuccessRecord, arg.UploadID, arg.FileName, arg.SuccessRecords)
	return err
}

const updateFileTotalRecord = `-- name: UpdateFileTotalRecord :exec
UPDATE uploaded_data_files SET total_records = $1 where upload_id = $2 AND file_name = $3
`

type UpdateFileTotalRecordParams struct {
	TotalRecords int32  `json:"total_records"`
	UploadID     int32  `json:"upload_id"`
	FileName     string `json:"file_name"`
}

func (q *Queries) UpdateFileTotalRecord(ctx context.Context, arg UpdateFileTotalRecordParams) error {
	_, err := q.db.ExecContext(ctx, updateFileTotalRecord, arg.TotalRecords, arg.UploadID, arg.FileName)
	return err
}
