// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const deleteCoreFactorReference = `-- name: DeleteCoreFactorReference :exec
delete from core_factor_references
`

func (q *Queries) DeleteCoreFactorReference(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteCoreFactorReference)
	return err
}

const dropFileRecords = `-- name: DropFileRecords :exec
delete from uploaded_data_files where scope = $1
`

func (q *Queries) DropFileRecords(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, dropFileRecords, scope)
	return err
}

const getActiveGID = `-- name: GetActiveGID :one
select upload_id from uploaded_data_files where scope = $1 and data_type ='GLOBALDATA' and status in ('UPLOADED' , 'PROCESSED')
`

func (q *Queries) GetActiveGID(ctx context.Context, scope string) (int32, error) {
	row := q.db.QueryRowContext(ctx, getActiveGID, scope)
	var upload_id int32
	err := row.Scan(&upload_id)
	return upload_id, err
}

const getAllDataFileStatusByGID = `-- name: GetAllDataFileStatusByGID :many
select status from uploaded_data_files where gid = $1
`

func (q *Queries) GetAllDataFileStatusByGID(ctx context.Context, gid int32) ([]UploadStatus, error) {
	rows, err := q.db.QueryContext(ctx, getAllDataFileStatusByGID, gid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UploadStatus
	for rows.Next() {
		var status UploadStatus
		if err := rows.Scan(&status); err != nil {
			return nil, err
		}
		items = append(items, status)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoreFactorList = `-- name: GetCoreFactorList :many
select id, manufacturer, model, core_factor  from core_factor_references
`

func (q *Queries) GetCoreFactorList(ctx context.Context) ([]CoreFactorReference, error) {
	rows, err := q.db.QueryContext(ctx, getCoreFactorList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreFactorReference
	for rows.Next() {
		var i CoreFactorReference
		if err := rows.Scan(
			&i.ID,
			&i.Manufacturer,
			&i.Model,
			&i.CoreFactor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoreFactorLogs = `-- name: GetCoreFactorLogs :many
select upload_id, file_name, uploaded_on from core_factor_logs order by upload_id desc limit 5
`

func (q *Queries) GetCoreFactorLogs(ctx context.Context) ([]CoreFactorLog, error) {
	rows, err := q.db.QueryContext(ctx, getCoreFactorLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoreFactorLog
	for rows.Next() {
		var i CoreFactorLog
		if err := rows.Scan(&i.UploadID, &i.FileName, &i.UploadedOn); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoreFactorReferences = `-- name: GetCoreFactorReferences :many
select id, manufacturer, model, core_factor , count(*) OVER() AS total_records from core_factor_references limit $1 offset $2
`

type GetCoreFactorReferencesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCoreFactorReferencesRow struct {
	ID           int32  `json:"id"`
	Manufacturer string `json:"manufacturer"`
	Model        string `json:"model"`
	CoreFactor   string `json:"core_factor"`
	TotalRecords int64  `json:"total_records"`
}

func (q *Queries) GetCoreFactorReferences(ctx context.Context, arg GetCoreFactorReferencesParams) ([]GetCoreFactorReferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getCoreFactorReferences, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoreFactorReferencesRow
	for rows.Next() {
		var i GetCoreFactorReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.Manufacturer,
			&i.Model,
			&i.CoreFactor,
			&i.TotalRecords,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataFileRecords = `-- name: GetDataFileRecords :one
select coalesce(sum(total_records),0)::BIGINT as total_records, coalesce(sum(failed_records),0) ::BIGINT as failed_records from  uploaded_data_files where  date(uploaded_on) >= make_date($1,$2,$3)   and scope = $4  and  file_name SIMILAR TO $5
`

type GetDataFileRecordsParams struct {
	Year          int32  `json:"year"`
	Month         int32  `json:"month"`
	Day           int32  `json:"day"`
	Scope         string `json:"scope"`
	SimilarEscape string `json:"similar_escape"`
}

type GetDataFileRecordsRow struct {
	TotalRecords  int64 `json:"total_records"`
	FailedRecords int64 `json:"failed_records"`
}

func (q *Queries) GetDataFileRecords(ctx context.Context, arg GetDataFileRecordsParams) (GetDataFileRecordsRow, error) {
	row := q.db.QueryRowContext(ctx, getDataFileRecords,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.Scope,
		arg.SimilarEscape,
	)
	var i GetDataFileRecordsRow
	err := row.Scan(&i.TotalRecords, &i.FailedRecords)
	return i, err
}

const getDeletionStatus = `-- name: GetDeletionStatus :one
select count(*) from deletion_audit where scope = $1 and status = 'INPROGRESS'
`

func (q *Queries) GetDeletionStatus(ctx context.Context, scope string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDeletionStatus, scope)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEntityMonthWise = `-- name: GetEntityMonthWise :many
select sum(success_records), lower(file_name) as filename, EXTRACT(month from uploaded_on) as month, EXTRACT(year from uploaded_on) as year from  uploaded_data_files where  DATE(uploaded_on)  < make_date($1,$2,1) and  uploaded_on >= make_date($3,$4,1)  and scope = $5  and status = 'SUCCESS'  and  file_name SIMILAR TO $6
group by ( 2,3,4)  order by 3 desc , 4 DESC
`

type GetEntityMonthWiseParams struct {
	Year          int32  `json:"year"`
	Month         int32  `json:"month"`
	Year_2        int32  `json:"year_2"`
	Month_2       int32  `json:"month_2"`
	Scope         string `json:"scope"`
	SimilarEscape string `json:"similar_escape"`
}

type GetEntityMonthWiseRow struct {
	Sum      int64   `json:"sum"`
	Filename string  `json:"filename"`
	Month    float64 `json:"month"`
	Year     float64 `json:"year"`
}

func (q *Queries) GetEntityMonthWise(ctx context.Context, arg GetEntityMonthWiseParams) ([]GetEntityMonthWiseRow, error) {
	rows, err := q.db.QueryContext(ctx, getEntityMonthWise,
		arg.Year,
		arg.Month,
		arg.Year_2,
		arg.Month_2,
		arg.Scope,
		arg.SimilarEscape,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntityMonthWiseRow
	for rows.Next() {
		var i GetEntityMonthWiseRow
		if err := rows.Scan(
			&i.Sum,
			&i.Filename,
			&i.Month,
			&i.Year,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedRecord = `-- name: GetFailedRecord :many
SELECT count(*) OVER() AS totalRecords, comments, data -> 'Data' as record from jobs where status = 'FAILED' and data -> 'UploadID' = $1 and type = 'API_WORKER' limit $2 offset $3
`

type GetFailedRecordParams struct {
	Data   json.RawMessage `json:"data"`
	Limit  int32           `json:"limit"`
	Offset int32           `json:"offset"`
}

type GetFailedRecordRow struct {
	Totalrecords int64          `json:"totalrecords"`
	Comments     sql.NullString `json:"comments"`
	Record       interface{}    `json:"record"`
}

func (q *Queries) GetFailedRecord(ctx context.Context, arg GetFailedRecordParams) ([]GetFailedRecordRow, error) {
	rows, err := q.db.QueryContext(ctx, getFailedRecord, arg.Data, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailedRecordRow
	for rows.Next() {
		var i GetFailedRecordRow
		if err := rows.Scan(&i.Totalrecords, &i.Comments, &i.Record); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailureReasons = `-- name: GetFailureReasons :many
select count(TYPE) as failed_records,comments from jobs where status = 'FAILED' and type in ('FILE_WORKER', 'API_WORKER') and end_time >= make_date($1,$2,$3) and (data -> 'Data' ->> 'scope'  = $4 or data ->> 'scope' = $4 ) and data -> 'Data' -> 'metadata_type' is NULL group by (2)
`

type GetFailureReasonsParams struct {
	Year  int32           `json:"year"`
	Month int32           `json:"month"`
	Day   int32           `json:"day"`
	Data  json.RawMessage `json:"data"`
}

type GetFailureReasonsRow struct {
	FailedRecords int64          `json:"failed_records"`
	Comments      sql.NullString `json:"comments"`
}

func (q *Queries) GetFailureReasons(ctx context.Context, arg GetFailureReasonsParams) ([]GetFailureReasonsRow, error) {
	rows, err := q.db.QueryContext(ctx, getFailureReasons,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.Data,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailureReasonsRow
	for rows.Next() {
		var i GetFailureReasonsRow
		if err := rows.Scan(&i.FailedRecords, &i.Comments); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileStatus = `-- name: GetFileStatus :one
SELECT status FROM uploaded_data_files WHERE upload_id = $1 AND file_name = $2
`

type GetFileStatusParams struct {
	UploadID int32  `json:"upload_id"`
	FileName string `json:"file_name"`
}

func (q *Queries) GetFileStatus(ctx context.Context, arg GetFileStatusParams) (UploadStatus, error) {
	row := q.db.QueryRowContext(ctx, getFileStatus, arg.UploadID, arg.FileName)
	var status UploadStatus
	err := row.Scan(&status)
	return status, err
}

const getGlobalFileInfo = `-- name: GetGlobalFileInfo :one
select analysis_id, file_name,scope_type, upload_id from uploaded_data_files where data_type = 'GLOBALDATA' and  scope = $1 and upload_id = $2
`

type GetGlobalFileInfoParams struct {
	Scope    string `json:"scope"`
	UploadID int32  `json:"upload_id"`
}

type GetGlobalFileInfoRow struct {
	AnalysisID sql.NullString `json:"analysis_id"`
	FileName   string         `json:"file_name"`
	ScopeType  ScopeTypes     `json:"scope_type"`
	UploadID   int32          `json:"upload_id"`
}

func (q *Queries) GetGlobalFileInfo(ctx context.Context, arg GetGlobalFileInfoParams) (GetGlobalFileInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalFileInfo, arg.Scope, arg.UploadID)
	var i GetGlobalFileInfoRow
	err := row.Scan(
		&i.AnalysisID,
		&i.FileName,
		&i.ScopeType,
		&i.UploadID,
	)
	return i, err
}

const getInjectionStatus = `-- name: GetInjectionStatus :one
select count(file_name) from uploaded_data_files where scope = $1 and status in ('PENDING', 'INPROGRESS','UPLOADED' , 'PROCESSED')
`

func (q *Queries) GetInjectionStatus(ctx context.Context, scope string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getInjectionStatus, scope)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTransformedGlobalFileInfo = `-- name: GetTransformedGlobalFileInfo :many
select upload_id, scope, scope_type,file_name ,status from uploaded_data_files where  data_type = 'GLOBALDATA' and (status = 'UPLOADED' or status = 'PROCESSED')
`

type GetTransformedGlobalFileInfoRow struct {
	UploadID  int32        `json:"upload_id"`
	Scope     string       `json:"scope"`
	ScopeType ScopeTypes   `json:"scope_type"`
	FileName  string       `json:"file_name"`
	Status    UploadStatus `json:"status"`
}

func (q *Queries) GetTransformedGlobalFileInfo(ctx context.Context) ([]GetTransformedGlobalFileInfoRow, error) {
	rows, err := q.db.QueryContext(ctx, getTransformedGlobalFileInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTransformedGlobalFileInfoRow
	for rows.Next() {
		var i GetTransformedGlobalFileInfoRow
		if err := rows.Scan(
			&i.UploadID,
			&i.Scope,
			&i.ScopeType,
			&i.FileName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUploadedData = `-- name: InsertUploadedData :one
INSERT INTO uploaded_data_files (scope,data_type,file_name,uploaded_by,gid,status,scope_type, analysis_id)
VALUES($1,$2,$3,$4,$5,$6,$7,$8) returning upload_id, gid, scope, data_type, file_name, status, uploaded_by, uploaded_on, updated_on, total_records, success_records, failed_records, comments, scope_type, analysis_id
`

type InsertUploadedDataParams struct {
	Scope      string         `json:"scope"`
	DataType   DataType       `json:"data_type"`
	FileName   string         `json:"file_name"`
	UploadedBy string         `json:"uploaded_by"`
	Gid        int32          `json:"gid"`
	Status     UploadStatus   `json:"status"`
	ScopeType  ScopeTypes     `json:"scope_type"`
	AnalysisID sql.NullString `json:"analysis_id"`
}

func (q *Queries) InsertUploadedData(ctx context.Context, arg InsertUploadedDataParams) (UploadedDataFile, error) {
	row := q.db.QueryRowContext(ctx, insertUploadedData,
		arg.Scope,
		arg.DataType,
		arg.FileName,
		arg.UploadedBy,
		arg.Gid,
		arg.Status,
		arg.ScopeType,
		arg.AnalysisID,
	)
	var i UploadedDataFile
	err := row.Scan(
		&i.UploadID,
		&i.Gid,
		&i.Scope,
		&i.DataType,
		&i.FileName,
		&i.Status,
		&i.UploadedBy,
		&i.UploadedOn,
		&i.UpdatedOn,
		&i.TotalRecords,
		&i.SuccessRecords,
		&i.FailedRecords,
		&i.Comments,
		&i.ScopeType,
		&i.AnalysisID,
	)
	return i, err
}

const insertUploadedMetaData = `-- name: InsertUploadedMetaData :one
INSERT INTO uploaded_data_files (file_name,uploaded_by)
VALUES($1,$2) returning upload_id, gid, scope, data_type, file_name, status, uploaded_by, uploaded_on, updated_on, total_records, success_records, failed_records, comments, scope_type, analysis_id
`

type InsertUploadedMetaDataParams struct {
	FileName   string `json:"file_name"`
	UploadedBy string `json:"uploaded_by"`
}

func (q *Queries) InsertUploadedMetaData(ctx context.Context, arg InsertUploadedMetaDataParams) (UploadedDataFile, error) {
	row := q.db.QueryRowContext(ctx, insertUploadedMetaData, arg.FileName, arg.UploadedBy)
	var i UploadedDataFile
	err := row.Scan(
		&i.UploadID,
		&i.Gid,
		&i.Scope,
		&i.DataType,
		&i.FileName,
		&i.Status,
		&i.UploadedBy,
		&i.UploadedOn,
		&i.UpdatedOn,
		&i.TotalRecords,
		&i.SuccessRecords,
		&i.FailedRecords,
		&i.Comments,
		&i.ScopeType,
		&i.AnalysisID,
	)
	return i, err
}

const listDeletionRecrods = `-- name: ListDeletionRecrods :many
SELECT count(*) OVER() AS totalRecords,id, scope, deletion_type, status, reason, created_by, created_on, updated_on from
deletion_audit
WHERE
  scope = $1
ORDER BY
  CASE WHEN $2::bool THEN deletion_type END asc,
  CASE WHEN $3::bool THEN deletion_type END desc,
  CASE WHEN $4::bool THEN status END asc,
  CASE WHEN $5::bool THEN status END desc,
  CASE WHEN $6::bool THEN created_by END asc,
  CASE WHEN $7::bool THEN created_by END desc,
  CASE WHEN $8::bool THEN created_on END asc,
  CASE WHEN $9::bool THEN created_on END desc
  LIMIT $11 OFFSET $10
`

type ListDeletionRecrodsParams struct {
	Scope            string `json:"scope"`
	DeletionTypeAsc  bool   `json:"deletion_type_asc"`
	DeletionTypeDesc bool   `json:"deletion_type_desc"`
	StatusAsc        bool   `json:"status_asc"`
	StatusDesc       bool   `json:"status_desc"`
	CreatedByAsc     bool   `json:"created_by_asc"`
	CreatedByDesc    bool   `json:"created_by_desc"`
	CreatedOnAsc     bool   `json:"created_on_asc"`
	CreatedOnDesc    bool   `json:"created_on_desc"`
	PageNum          int32  `json:"page_num"`
	PageSize         int32  `json:"page_size"`
}

type ListDeletionRecrodsRow struct {
	Totalrecords int64          `json:"totalrecords"`
	ID           int32          `json:"id"`
	Scope        string         `json:"scope"`
	DeletionType DeletionType   `json:"deletion_type"`
	Status       UploadStatus   `json:"status"`
	Reason       sql.NullString `json:"reason"`
	CreatedBy    string         `json:"created_by"`
	CreatedOn    time.Time      `json:"created_on"`
	UpdatedOn    sql.NullTime   `json:"updated_on"`
}

func (q *Queries) ListDeletionRecrods(ctx context.Context, arg ListDeletionRecrodsParams) ([]ListDeletionRecrodsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeletionRecrods,
		arg.Scope,
		arg.DeletionTypeAsc,
		arg.DeletionTypeDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.CreatedByAsc,
		arg.CreatedByDesc,
		arg.CreatedOnAsc,
		arg.CreatedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeletionRecrodsRow
	for rows.Next() {
		var i ListDeletionRecrodsRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ID,
			&i.Scope,
			&i.DeletionType,
			&i.Status,
			&i.Reason,
			&i.CreatedBy,
			&i.CreatedOn,
			&i.UpdatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedDataFiles = `-- name: ListUploadedDataFiles :many
SELECT count(*) OVER() AS totalRecords,upload_id, gid, scope, data_type, file_name, status, uploaded_by, uploaded_on, updated_on, total_records, success_records, failed_records, comments, scope_type, analysis_id from
uploaded_data_files
WHERE
    scope = ANY($1::TEXT[])
    AND data_type = 'DATA' 
    AND
     CASE 
   	 		when  $2 = 0 then gid >= 0
    		ELSE gid = $2
    	end
ORDER BY
  CASE WHEN $3::bool THEN upload_id END asc,
  CASE WHEN $4::bool THEN upload_id END desc,
  CASE WHEN $5::bool THEN scope END asc,
  CASE WHEN $6::bool THEN scope END desc,
  CASE WHEN $7::bool THEN file_name END asc,
  CASE WHEN $8::bool THEN file_name END desc,
  CASE WHEN $9::bool THEN status END asc,
  CASE WHEN $10::bool THEN status END desc,
  CASE WHEN $11::bool THEN uploaded_by END asc,
  CASE WHEN $12::bool THEN uploaded_by END desc,
  CASE WHEN $13::bool THEN uploaded_on END asc,
  CASE WHEN $14::bool THEN uploaded_on END desc
  LIMIT $16 OFFSET $15
`

type ListUploadedDataFilesParams struct {
	Scope          []string    `json:"scope"`
	Gid            interface{} `json:"gid"`
	UploadIDAsc    bool        `json:"upload_id_asc"`
	UploadIDDesc   bool        `json:"upload_id_desc"`
	ScopeAsc       bool        `json:"scope_asc"`
	ScopeDesc      bool        `json:"scope_desc"`
	FileNameAsc    bool        `json:"file_name_asc"`
	FileNameDesc   bool        `json:"file_name_desc"`
	StatusAsc      bool        `json:"status_asc"`
	StatusDesc     bool        `json:"status_desc"`
	UploadedByAsc  bool        `json:"uploaded_by_asc"`
	UploadedByDesc bool        `json:"uploaded_by_desc"`
	UploadedOnAsc  bool        `json:"uploaded_on_asc"`
	UploadedOnDesc bool        `json:"uploaded_on_desc"`
	PageNum        int32       `json:"page_num"`
	PageSize       int32       `json:"page_size"`
}

type ListUploadedDataFilesRow struct {
	Totalrecords   int64          `json:"totalrecords"`
	UploadID       int32          `json:"upload_id"`
	Gid            int32          `json:"gid"`
	Scope          string         `json:"scope"`
	DataType       DataType       `json:"data_type"`
	FileName       string         `json:"file_name"`
	Status         UploadStatus   `json:"status"`
	UploadedBy     string         `json:"uploaded_by"`
	UploadedOn     time.Time      `json:"uploaded_on"`
	UpdatedOn      sql.NullTime   `json:"updated_on"`
	TotalRecords   int32          `json:"total_records"`
	SuccessRecords int32          `json:"success_records"`
	FailedRecords  int32          `json:"failed_records"`
	Comments       sql.NullString `json:"comments"`
	ScopeType      ScopeTypes     `json:"scope_type"`
	AnalysisID     sql.NullString `json:"analysis_id"`
}

func (q *Queries) ListUploadedDataFiles(ctx context.Context, arg ListUploadedDataFilesParams) ([]ListUploadedDataFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedDataFiles,
		pq.Array(arg.Scope),
		arg.Gid,
		arg.UploadIDAsc,
		arg.UploadIDDesc,
		arg.ScopeAsc,
		arg.ScopeDesc,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.UploadedByAsc,
		arg.UploadedByDesc,
		arg.UploadedOnAsc,
		arg.UploadedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUploadedDataFilesRow
	for rows.Next() {
		var i ListUploadedDataFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UploadID,
			&i.Gid,
			&i.Scope,
			&i.DataType,
			&i.FileName,
			&i.Status,
			&i.UploadedBy,
			&i.UploadedOn,
			&i.UpdatedOn,
			&i.TotalRecords,
			&i.SuccessRecords,
			&i.FailedRecords,
			&i.Comments,
			&i.ScopeType,
			&i.AnalysisID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedGlobalDataFiles = `-- name: ListUploadedGlobalDataFiles :many
SELECT count(*) OVER() AS totalRecords,upload_id, gid, scope, data_type, file_name, status, uploaded_by, uploaded_on, updated_on, total_records, success_records, failed_records, comments, scope_type, analysis_id from
uploaded_data_files
WHERE
  scope = ANY($1::TEXT[])
  AND data_type = 'GLOBALDATA'
ORDER BY
  CASE WHEN $2::bool THEN upload_id END asc,
  CASE WHEN $3::bool THEN upload_id END desc,
  CASE WHEN $4::bool THEN scope END asc,
  CASE WHEN $5::bool THEN scope END desc,
  CASE WHEN $6::bool THEN file_name END asc,
  CASE WHEN $7::bool THEN file_name END desc,
  CASE WHEN $8::bool THEN status END asc,
  CASE WHEN $9::bool THEN status END desc,
  CASE WHEN $10::bool THEN uploaded_by END asc,
  CASE WHEN $11::bool THEN uploaded_by END desc,
  CASE WHEN $12::bool THEN uploaded_on END asc,
  CASE WHEN $13::bool THEN uploaded_on END desc
  LIMIT $15 OFFSET $14
`

type ListUploadedGlobalDataFilesParams struct {
	Scope          []string `json:"scope"`
	UploadIDAsc    bool     `json:"upload_id_asc"`
	UploadIDDesc   bool     `json:"upload_id_desc"`
	ScopeAsc       bool     `json:"scope_asc"`
	ScopeDesc      bool     `json:"scope_desc"`
	FileNameAsc    bool     `json:"file_name_asc"`
	FileNameDesc   bool     `json:"file_name_desc"`
	StatusAsc      bool     `json:"status_asc"`
	StatusDesc     bool     `json:"status_desc"`
	UploadedByAsc  bool     `json:"uploaded_by_asc"`
	UploadedByDesc bool     `json:"uploaded_by_desc"`
	UploadedOnAsc  bool     `json:"uploaded_on_asc"`
	UploadedOnDesc bool     `json:"uploaded_on_desc"`
	PageNum        int32    `json:"page_num"`
	PageSize       int32    `json:"page_size"`
}

type ListUploadedGlobalDataFilesRow struct {
	Totalrecords   int64          `json:"totalrecords"`
	UploadID       int32          `json:"upload_id"`
	Gid            int32          `json:"gid"`
	Scope          string         `json:"scope"`
	DataType       DataType       `json:"data_type"`
	FileName       string         `json:"file_name"`
	Status         UploadStatus   `json:"status"`
	UploadedBy     string         `json:"uploaded_by"`
	UploadedOn     time.Time      `json:"uploaded_on"`
	UpdatedOn      sql.NullTime   `json:"updated_on"`
	TotalRecords   int32          `json:"total_records"`
	SuccessRecords int32          `json:"success_records"`
	FailedRecords  int32          `json:"failed_records"`
	Comments       sql.NullString `json:"comments"`
	ScopeType      ScopeTypes     `json:"scope_type"`
	AnalysisID     sql.NullString `json:"analysis_id"`
}

func (q *Queries) ListUploadedGlobalDataFiles(ctx context.Context, arg ListUploadedGlobalDataFilesParams) ([]ListUploadedGlobalDataFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedGlobalDataFiles,
		pq.Array(arg.Scope),
		arg.UploadIDAsc,
		arg.UploadIDDesc,
		arg.ScopeAsc,
		arg.ScopeDesc,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.UploadedByAsc,
		arg.UploadedByDesc,
		arg.UploadedOnAsc,
		arg.UploadedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUploadedGlobalDataFilesRow
	for rows.Next() {
		var i ListUploadedGlobalDataFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UploadID,
			&i.Gid,
			&i.Scope,
			&i.DataType,
			&i.FileName,
			&i.Status,
			&i.UploadedBy,
			&i.UploadedOn,
			&i.UpdatedOn,
			&i.TotalRecords,
			&i.SuccessRecords,
			&i.FailedRecords,
			&i.Comments,
			&i.ScopeType,
			&i.AnalysisID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUploadedMetaDataFiles = `-- name: ListUploadedMetaDataFiles :many
SELECT count(*) OVER() AS totalRecords,upload_id, gid, scope, data_type, file_name, status, uploaded_by, uploaded_on, updated_on, total_records, success_records, failed_records, comments, scope_type, analysis_id from
uploaded_data_files
WHERE
  scope = ANY($1::TEXT[])
  AND data_type = 'METADATA'
ORDER BY
  CASE WHEN $2::bool THEN upload_id END asc,
  CASE WHEN $3::bool THEN upload_id END desc,
  CASE WHEN $4::bool THEN scope END asc,
  CASE WHEN $5::bool THEN scope END desc,
  CASE WHEN $6::bool THEN file_name END asc,
  CASE WHEN $7::bool THEN file_name END desc,
  CASE WHEN $8::bool THEN status END asc,
  CASE WHEN $9::bool THEN status END desc,
  CASE WHEN $10::bool THEN uploaded_by END asc,
  CASE WHEN $11::bool THEN uploaded_by END desc,
  CASE WHEN $12::bool THEN uploaded_on END asc,
  CASE WHEN $13::bool THEN uploaded_on END desc
  LIMIT $15 OFFSET $14
`

type ListUploadedMetaDataFilesParams struct {
	Scope          []string `json:"scope"`
	UploadIDAsc    bool     `json:"upload_id_asc"`
	UploadIDDesc   bool     `json:"upload_id_desc"`
	ScopeAsc       bool     `json:"scope_asc"`
	ScopeDesc      bool     `json:"scope_desc"`
	FileNameAsc    bool     `json:"file_name_asc"`
	FileNameDesc   bool     `json:"file_name_desc"`
	StatusAsc      bool     `json:"status_asc"`
	StatusDesc     bool     `json:"status_desc"`
	UploadedByAsc  bool     `json:"uploaded_by_asc"`
	UploadedByDesc bool     `json:"uploaded_by_desc"`
	UploadedOnAsc  bool     `json:"uploaded_on_asc"`
	UploadedOnDesc bool     `json:"uploaded_on_desc"`
	PageNum        int32    `json:"page_num"`
	PageSize       int32    `json:"page_size"`
}

type ListUploadedMetaDataFilesRow struct {
	Totalrecords   int64          `json:"totalrecords"`
	UploadID       int32          `json:"upload_id"`
	Gid            int32          `json:"gid"`
	Scope          string         `json:"scope"`
	DataType       DataType       `json:"data_type"`
	FileName       string         `json:"file_name"`
	Status         UploadStatus   `json:"status"`
	UploadedBy     string         `json:"uploaded_by"`
	UploadedOn     time.Time      `json:"uploaded_on"`
	UpdatedOn      sql.NullTime   `json:"updated_on"`
	TotalRecords   int32          `json:"total_records"`
	SuccessRecords int32          `json:"success_records"`
	FailedRecords  int32          `json:"failed_records"`
	Comments       sql.NullString `json:"comments"`
	ScopeType      ScopeTypes     `json:"scope_type"`
	AnalysisID     sql.NullString `json:"analysis_id"`
}

func (q *Queries) ListUploadedMetaDataFiles(ctx context.Context, arg ListUploadedMetaDataFilesParams) ([]ListUploadedMetaDataFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUploadedMetaDataFiles,
		pq.Array(arg.Scope),
		arg.UploadIDAsc,
		arg.UploadIDDesc,
		arg.ScopeAsc,
		arg.ScopeDesc,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.UploadedByAsc,
		arg.UploadedByDesc,
		arg.UploadedOnAsc,
		arg.UploadedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUploadedMetaDataFilesRow
	for rows.Next() {
		var i ListUploadedMetaDataFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UploadID,
			&i.Gid,
			&i.Scope,
			&i.DataType,
			&i.FileName,
			&i.Status,
			&i.UploadedBy,
			&i.UploadedOn,
			&i.UpdatedOn,
			&i.TotalRecords,
			&i.SuccessRecords,
			&i.FailedRecords,
			&i.Comments,
			&i.ScopeType,
			&i.AnalysisID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logCoreFactor = `-- name: LogCoreFactor :exec
insert into core_factor_logs (file_name)values($1)
`

func (q *Queries) LogCoreFactor(ctx context.Context, fileName string) error {
	_, err := q.db.ExecContext(ctx, logCoreFactor, fileName)
	return err
}

const setDeletionActive = `-- name: SetDeletionActive :one
insert into deletion_audit (scope,deletion_type,created_by) values ($1,$2,$3) returning id
`

type SetDeletionActiveParams struct {
	Scope        string       `json:"scope"`
	DeletionType DeletionType `json:"deletion_type"`
	CreatedBy    string       `json:"created_by"`
}

func (q *Queries) SetDeletionActive(ctx context.Context, arg SetDeletionActiveParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, setDeletionActive, arg.Scope, arg.DeletionType, arg.CreatedBy)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateDeletionStatus = `-- name: UpdateDeletionStatus :exec
update deletion_audit set status = $1 , reason = $2 where id = $3
`

type UpdateDeletionStatusParams struct {
	Status UploadStatus   `json:"status"`
	Reason sql.NullString `json:"reason"`
	ID     int32          `json:"id"`
}

func (q *Queries) UpdateDeletionStatus(ctx context.Context, arg UpdateDeletionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateDeletionStatus, arg.Status, arg.Reason, arg.ID)
	return err
}

const updateFileFailedRecord = `-- name: UpdateFileFailedRecord :one
UPDATE uploaded_data_files SET failed_records = failed_records + $3 where upload_id = $1 AND file_name = $2 RETURNING   total_records = (success_records) as isSuccess, total_records = (failed_records) as isFailed, total_records = (success_records + failed_records) as isPartial
`

type UpdateFileFailedRecordParams struct {
	UploadID      int32  `json:"upload_id"`
	FileName      string `json:"file_name"`
	FailedRecords int32  `json:"failed_records"`
}

type UpdateFileFailedRecordRow struct {
	Issuccess bool `json:"issuccess"`
	Isfailed  bool `json:"isfailed"`
	Ispartial bool `json:"ispartial"`
}

func (q *Queries) UpdateFileFailedRecord(ctx context.Context, arg UpdateFileFailedRecordParams) (UpdateFileFailedRecordRow, error) {
	row := q.db.QueryRowContext(ctx, updateFileFailedRecord, arg.UploadID, arg.FileName, arg.FailedRecords)
	var i UpdateFileFailedRecordRow
	err := row.Scan(&i.Issuccess, &i.Isfailed, &i.Ispartial)
	return i, err
}

const updateFileFailure = `-- name: UpdateFileFailure :exec
UPDATE uploaded_data_files SET status = $1 , comments = $2 where upload_id = $3 AND file_name = $4
`

type UpdateFileFailureParams struct {
	Status   UploadStatus   `json:"status"`
	Comments sql.NullString `json:"comments"`
	UploadID int32          `json:"upload_id"`
	FileName string         `json:"file_name"`
}

func (q *Queries) UpdateFileFailure(ctx context.Context, arg UpdateFileFailureParams) error {
	_, err := q.db.ExecContext(ctx, updateFileFailure,
		arg.Status,
		arg.Comments,
		arg.UploadID,
		arg.FileName,
	)
	return err
}

const updateFileStatus = `-- name: UpdateFileStatus :exec
UPDATE uploaded_data_files SET status = $1, updated_on = NOW() , comments = $2 where upload_id = $3 AND file_name = $4
`

type UpdateFileStatusParams struct {
	Status   UploadStatus   `json:"status"`
	Comments sql.NullString `json:"comments"`
	UploadID int32          `json:"upload_id"`
	FileName string         `json:"file_name"`
}

func (q *Queries) UpdateFileStatus(ctx context.Context, arg UpdateFileStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateFileStatus,
		arg.Status,
		arg.Comments,
		arg.UploadID,
		arg.FileName,
	)
	return err
}

const updateFileSuccessRecord = `-- name: UpdateFileSuccessRecord :one
UPDATE uploaded_data_files SET success_records = success_records + $3 where upload_id = $1 AND file_name = $2 RETURNING   total_records = (success_records) as isSuccess, total_records = (failed_records) as isFailed, total_records = (success_records + failed_records) as isPartial
`

type UpdateFileSuccessRecordParams struct {
	UploadID       int32  `json:"upload_id"`
	FileName       string `json:"file_name"`
	SuccessRecords int32  `json:"success_records"`
}

type UpdateFileSuccessRecordRow struct {
	Issuccess bool `json:"issuccess"`
	Isfailed  bool `json:"isfailed"`
	Ispartial bool `json:"ispartial"`
}

func (q *Queries) UpdateFileSuccessRecord(ctx context.Context, arg UpdateFileSuccessRecordParams) (UpdateFileSuccessRecordRow, error) {
	row := q.db.QueryRowContext(ctx, updateFileSuccessRecord, arg.UploadID, arg.FileName, arg.SuccessRecords)
	var i UpdateFileSuccessRecordRow
	err := row.Scan(&i.Issuccess, &i.Isfailed, &i.Ispartial)
	return i, err
}

const updateFileTotalRecord = `-- name: UpdateFileTotalRecord :exec
UPDATE uploaded_data_files SET total_records = $1 , failed_records = $2  where upload_id = $3 AND file_name = $4
`

type UpdateFileTotalRecordParams struct {
	TotalRecords  int32  `json:"total_records"`
	FailedRecords int32  `json:"failed_records"`
	UploadID      int32  `json:"upload_id"`
	FileName      string `json:"file_name"`
}

func (q *Queries) UpdateFileTotalRecord(ctx context.Context, arg UpdateFileTotalRecordParams) error {
	_, err := q.db.ExecContext(ctx, updateFileTotalRecord,
		arg.TotalRecords,
		arg.FailedRecords,
		arg.UploadID,
		arg.FileName,
	)
	return err
}

const updateGlobalFileStatus = `-- name: UpdateGlobalFileStatus :one
update uploaded_data_files 
set status = (CASE
		when status != 'PARTIAL' then  $2
		else status
		end) :: upload_status, updated_on = now()
where upload_id = $1 returning scope
`

type UpdateGlobalFileStatusParams struct {
	UploadID int32        `json:"upload_id"`
	Column2  UploadStatus `json:"column_2"`
}

func (q *Queries) UpdateGlobalFileStatus(ctx context.Context, arg UpdateGlobalFileStatusParams) (string, error) {
	row := q.db.QueryRowContext(ctx, updateGlobalFileStatus, arg.UploadID, arg.Column2)
	var scope string
	err := row.Scan(&scope)
	return scope, err
}
