// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const deleteReportsByScope = `-- name: DeleteReportsByScope :exec
Delete from report where scope = $1
`

func (q *Queries) DeleteReportsByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteReportsByScope, scope)
	return err
}

const downloadReport = `-- name: DownloadReport :one
SELECT r.report_data, r.created_by, r.created_on, r.scope, rt.report_type_name, r.report_metadata
FROM report r
JOIN
report_type rt 
ON r.report_type_id = rt.report_type_id
WHERE r.report_id = $1
AND r.scope = ANY($2::TEXT[])
`

type DownloadReportParams struct {
	ReportID int32    `json:"report_id"`
	Scope    []string `json:"scope"`
}

type DownloadReportRow struct {
	ReportData     json.RawMessage `json:"report_data"`
	CreatedBy      string          `json:"created_by"`
	CreatedOn      time.Time       `json:"created_on"`
	Scope          string          `json:"scope"`
	ReportTypeName string          `json:"report_type_name"`
	ReportMetadata json.RawMessage `json:"report_metadata"`
}

func (q *Queries) DownloadReport(ctx context.Context, arg DownloadReportParams) (DownloadReportRow, error) {
	row := q.db.QueryRowContext(ctx, downloadReport, arg.ReportID, pq.Array(arg.Scope))
	var i DownloadReportRow
	err := row.Scan(
		&i.ReportData,
		&i.CreatedBy,
		&i.CreatedOn,
		&i.Scope,
		&i.ReportTypeName,
		&i.ReportMetadata,
	)
	return i, err
}

const getReport = `-- name: GetReport :many
SELECT count(*) OVER() AS totalRecords,r.report_id,rt.report_type_name,r.report_status,r.report_metadata,r.created_by,r.created_on FROM
report r
JOIN
report_type rt 
ON r.report_type_id = rt.report_type_id
WHERE r.scope = ANY($1::TEXT[])
ORDER BY
  CASE WHEN $2::bool THEN r.report_id END asc,
  CASE WHEN $3::bool THEN r.report_id END desc,
  CASE WHEN $4::bool THEN rt.report_type_name END asc,
  CASE WHEN $5::bool THEN rt.report_type_name END desc,
  CASE WHEN $6::bool THEN r.report_status END asc,
  CASE WHEN $7::bool THEN r.report_status END desc,
  CASE WHEN $8::bool THEN r.created_by END asc,
  CASE WHEN $9::bool THEN r.created_by END desc,
  CASE WHEN $10::bool THEN r.created_on END asc,
  CASE WHEN $11::bool THEN r.created_on END desc
  LIMIT $13 OFFSET $12
`

type GetReportParams struct {
	Scope              []string `json:"scope"`
	ReportIDAsc        bool     `json:"report_id_asc"`
	ReportIDDesc       bool     `json:"report_id_desc"`
	ReportTypeNameAsc  bool     `json:"report_type_name_asc"`
	ReportTypeNameDesc bool     `json:"report_type_name_desc"`
	ReportStatusAsc    bool     `json:"report_status_asc"`
	ReportStatusDesc   bool     `json:"report_status_desc"`
	CreatedByAsc       bool     `json:"created_by_asc"`
	CreatedByDesc      bool     `json:"created_by_desc"`
	CreatedOnAsc       bool     `json:"created_on_asc"`
	CreatedOnDesc      bool     `json:"created_on_desc"`
	PageNum            int32    `json:"page_num"`
	PageSize           int32    `json:"page_size"`
}

type GetReportRow struct {
	Totalrecords   int64           `json:"totalrecords"`
	ReportID       int32           `json:"report_id"`
	ReportTypeName string          `json:"report_type_name"`
	ReportStatus   ReportStatus    `json:"report_status"`
	ReportMetadata json.RawMessage `json:"report_metadata"`
	CreatedBy      string          `json:"created_by"`
	CreatedOn      time.Time       `json:"created_on"`
}

func (q *Queries) GetReport(ctx context.Context, arg GetReportParams) ([]GetReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getReport,
		pq.Array(arg.Scope),
		arg.ReportIDAsc,
		arg.ReportIDDesc,
		arg.ReportTypeNameAsc,
		arg.ReportTypeNameDesc,
		arg.ReportStatusAsc,
		arg.ReportStatusDesc,
		arg.CreatedByAsc,
		arg.CreatedByDesc,
		arg.CreatedOnAsc,
		arg.CreatedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportRow
	for rows.Next() {
		var i GetReportRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ReportID,
			&i.ReportTypeName,
			&i.ReportStatus,
			&i.ReportMetadata,
			&i.CreatedBy,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportType = `-- name: GetReportType :one
SELECT report_type_id, report_type_name FROM report_type
WHERE report_type_id = $1
`

func (q *Queries) GetReportType(ctx context.Context, reportTypeID int32) (ReportType, error) {
	row := q.db.QueryRowContext(ctx, getReportType, reportTypeID)
	var i ReportType
	err := row.Scan(&i.ReportTypeID, &i.ReportTypeName)
	return i, err
}

const getReportTypes = `-- name: GetReportTypes :many
SELECT report_type_id, report_type_name FROM report_type
`

func (q *Queries) GetReportTypes(ctx context.Context) ([]ReportType, error) {
	rows, err := q.db.QueryContext(ctx, getReportTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReportType
	for rows.Next() {
		var i ReportType
		if err := rows.Scan(&i.ReportTypeID, &i.ReportTypeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertReportData = `-- name: InsertReportData :exec
UPDATE report
SET report_data = $1
WHERE report_id = $2
`

type InsertReportDataParams struct {
	ReportDataJson json.RawMessage `json:"report_data_json"`
	ReportID       int32           `json:"report_id"`
}

func (q *Queries) InsertReportData(ctx context.Context, arg InsertReportDataParams) error {
	_, err := q.db.ExecContext(ctx, insertReportData, arg.ReportDataJson, arg.ReportID)
	return err
}

const submitReport = `-- name: SubmitReport :one
INSERT INTO
report(scope,report_type_id,report_status,report_metadata,created_by)
VALUES($1,$2,$3,$4,$5) RETURNING report_id
`

type SubmitReportParams struct {
	Scope          string          `json:"scope"`
	ReportTypeID   int32           `json:"report_type_id"`
	ReportStatus   ReportStatus    `json:"report_status"`
	ReportMetadata json.RawMessage `json:"report_metadata"`
	CreatedBy      string          `json:"created_by"`
}

func (q *Queries) SubmitReport(ctx context.Context, arg SubmitReportParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, submitReport,
		arg.Scope,
		arg.ReportTypeID,
		arg.ReportStatus,
		arg.ReportMetadata,
		arg.CreatedBy,
	)
	var report_id int32
	err := row.Scan(&report_id)
	return report_id, err
}

const updateReportStatus = `-- name: UpdateReportStatus :exec
UPDATE report
SET report_status = $1
WHERE report_id = $2
`

type UpdateReportStatusParams struct {
	ReportStatus ReportStatus `json:"report_status"`
	ReportID     int32        `json:"report_id"`
}

func (q *Queries) UpdateReportStatus(ctx context.Context, arg UpdateReportStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateReportStatus, arg.ReportStatus, arg.ReportID)
	return err
}
