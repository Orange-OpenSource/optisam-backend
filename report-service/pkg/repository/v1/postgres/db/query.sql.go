// Copyright (C) 2019 Orange
// 
// This software is distributed under the terms and conditions of the 'Apache License 2.0'
// license which can be found in the file 'License.txt' in this package distribution 
// or at 'http://www.apache.org/licenses/LICENSE-2.0'. 

// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const downloadReport = `-- name: DownloadReport :one
SELECT report_data
FROM report r
WHERE r.report_id = $1
AND r.scope = ANY($2::TEXT[])
`

type DownloadReportParams struct {
	ReportID int32    `json:"report_id"`
	Scope    []string `json:"scope"`
}

func (q *Queries) DownloadReport(ctx context.Context, arg DownloadReportParams) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, downloadReport, arg.ReportID, pq.Array(arg.Scope))
	var report_data json.RawMessage
	err := row.Scan(&report_data)
	return report_data, err
}

const getReport = `-- name: GetReport :many
SELECT count(*) OVER() AS totalRecords,r.report_id,rt.report_type_name,r.report_status,r.created_by,r.created_on FROM
report r
JOIN
report_type rt 
ON r.report_type_id = rt.report_type_id
WHERE r.scope = ANY($1::TEXT[])
ORDER BY
  CASE WHEN $2::bool THEN r.report_id END asc,
  CASE WHEN $3::bool THEN r.report_id END desc,
  CASE WHEN $4::bool THEN rt.report_type_name END asc,
  CASE WHEN $5::bool THEN rt.report_type_name END desc,
  CASE WHEN $6::bool THEN r.report_status END asc,
  CASE WHEN $7::bool THEN r.report_status END desc,
  CASE WHEN $8::bool THEN r.created_by END asc,
  CASE WHEN $9::bool THEN r.created_by END desc,
  CASE WHEN $10::bool THEN r.created_on END asc,
  CASE WHEN $11::bool THEN r.created_on END desc
  LIMIT $13 OFFSET $12
`

type GetReportParams struct {
	Scope              []string `json:"scope"`
	ReportIDAsc        bool     `json:"report_id_asc"`
	ReportIDDesc       bool     `json:"report_id_desc"`
	ReportTypeNameAsc  bool     `json:"report_type_name_asc"`
	ReportTypeNameDesc bool     `json:"report_type_name_desc"`
	ReportStatusAsc    bool     `json:"report_status_asc"`
	ReportStatusDesc   bool     `json:"report_status_desc"`
	CreatedByAsc       bool     `json:"created_by_asc"`
	CreatedByDesc      bool     `json:"created_by_desc"`
	CreatedOnAsc       bool     `json:"created_on_asc"`
	CreatedOnDesc      bool     `json:"created_on_desc"`
	PageNum            int32    `json:"page_num"`
	PageSize           int32    `json:"page_size"`
}

type GetReportRow struct {
	Totalrecords   int64        `json:"totalrecords"`
	ReportID       int32        `json:"report_id"`
	ReportTypeName string       `json:"report_type_name"`
	ReportStatus   ReportStatus `json:"report_status"`
	CreatedBy      string       `json:"created_by"`
	CreatedOn      time.Time    `json:"created_on"`
}

func (q *Queries) GetReport(ctx context.Context, arg GetReportParams) ([]GetReportRow, error) {
	rows, err := q.db.QueryContext(ctx, getReport,
		pq.Array(arg.Scope),
		arg.ReportIDAsc,
		arg.ReportIDDesc,
		arg.ReportTypeNameAsc,
		arg.ReportTypeNameDesc,
		arg.ReportStatusAsc,
		arg.ReportStatusDesc,
		arg.CreatedByAsc,
		arg.CreatedByDesc,
		arg.CreatedOnAsc,
		arg.CreatedOnDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReportRow
	for rows.Next() {
		var i GetReportRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ReportID,
			&i.ReportTypeName,
			&i.ReportStatus,
			&i.CreatedBy,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReportType = `-- name: GetReportType :one
SELECT report_type_id, report_type_name FROM report_type
WHERE report_type_id = $1
`

func (q *Queries) GetReportType(ctx context.Context, reportTypeID int32) (ReportType, error) {
	row := q.db.QueryRowContext(ctx, getReportType, reportTypeID)
	var i ReportType
	err := row.Scan(&i.ReportTypeID, &i.ReportTypeName)
	return i, err
}

const getReportTypes = `-- name: GetReportTypes :many
SELECT report_type_id, report_type_name FROM report_type
`

func (q *Queries) GetReportTypes(ctx context.Context) ([]ReportType, error) {
	rows, err := q.db.QueryContext(ctx, getReportTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReportType
	for rows.Next() {
		var i ReportType
		if err := rows.Scan(&i.ReportTypeID, &i.ReportTypeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertReportData = `-- name: InsertReportData :exec
UPDATE report
SET report_data = $1
WHERE report_id = $2
`

type InsertReportDataParams struct {
	ReportDataJson json.RawMessage `json:"report_data_json"`
	ReportID       int32           `json:"report_id"`
}

func (q *Queries) InsertReportData(ctx context.Context, arg InsertReportDataParams) error {
	_, err := q.db.ExecContext(ctx, insertReportData, arg.ReportDataJson, arg.ReportID)
	return err
}

const submitReport = `-- name: SubmitReport :one
INSERT INTO
report(scope,report_type_id,report_status,report_metadata,created_by)
VALUES($1,$2,$3,$4,$5) RETURNING report_id
`

type SubmitReportParams struct {
	Scope          string          `json:"scope"`
	ReportTypeID   int32           `json:"report_type_id"`
	ReportStatus   ReportStatus    `json:"report_status"`
	ReportMetadata json.RawMessage `json:"report_metadata"`
	CreatedBy      string          `json:"created_by"`
}

func (q *Queries) SubmitReport(ctx context.Context, arg SubmitReportParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, submitReport,
		arg.Scope,
		arg.ReportTypeID,
		arg.ReportStatus,
		arg.ReportMetadata,
		arg.CreatedBy,
	)
	var report_id int32
	err := row.Scan(&report_id)
	return report_id, err
}

const updateReportStatus = `-- name: UpdateReportStatus :exec
UPDATE report
SET report_status = $1
WHERE report_id = $2
`

type UpdateReportStatusParams struct {
	ReportStatus ReportStatus `json:"report_status"`
	ReportID     int32        `json:"report_id"`
}

func (q *Queries) UpdateReportStatus(ctx context.Context, arg UpdateReportStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateReportStatus, arg.ReportStatus, arg.ReportID)
	return err
}
