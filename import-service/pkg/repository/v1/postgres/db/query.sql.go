// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const getDgraphCompletedBatches = `-- name: GetDgraphCompletedBatches :one

SELECT
   dgraph_completed_batches
FROM nominative_user_requests
WHERE
    upload_id = $1
`

func (q *Queries) GetDgraphCompletedBatches(ctx context.Context, uploadID string) (sql.NullInt32, error) {
	row := q.db.QueryRowContext(ctx, getDgraphCompletedBatches, uploadID)
	var dgraph_completed_batches sql.NullInt32
	err := row.Scan(&dgraph_completed_batches)
	return dgraph_completed_batches, err
}

const insertNominativeUserRequest = `-- name: InsertNominativeUserRequest :one
INSERT INTO
    nominative_user_requests (
        upload_id,
        scope,
        status,
        swidtag,
        product_name,
        product_version,
        aggregation_id,
        editor,
        file_name,
        file_location,
        sheet_name,
        created_by,
		aggregation_name
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    ) RETURNING request_id
`

type InsertNominativeUserRequestParams struct {
	UploadID        string         `json:"upload_id"`
	Scope           string         `json:"scope"`
	Status          string         `json:"status"`
	Swidtag         sql.NullString `json:"swidtag"`
	ProductName     sql.NullString `json:"product_name"`
	ProductVersion  sql.NullString `json:"product_version"`
	AggregationID   sql.NullString `json:"aggregation_id"`
	Editor          sql.NullString `json:"editor"`
	FileName        sql.NullString `json:"file_name"`
	FileLocation    sql.NullString `json:"file_location"`
	SheetName       sql.NullString `json:"sheet_name"`
	CreatedBy       sql.NullString `json:"created_by"`
	AggregationName sql.NullString `json:"aggregation_name"`
}

func (q *Queries) InsertNominativeUserRequest(ctx context.Context, arg InsertNominativeUserRequestParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertNominativeUserRequest,
		arg.UploadID,
		arg.Scope,
		arg.Status,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductVersion,
		arg.AggregationID,
		arg.Editor,
		arg.FileName,
		arg.FileLocation,
		arg.SheetName,
		arg.CreatedBy,
		arg.AggregationName,
	)
	var request_id int32
	err := row.Scan(&request_id)
	return request_id, err
}

const insertNominativeUserRequestDetails = `-- name: InsertNominativeUserRequestDetails :exec
INSERT INTO
  nominative_user_requests_details (
  request_id,
  headers,
  host,
  remote_addr
 ) VALUES(
    $1,
    $2,
    $3,
    $4
 )
`

type InsertNominativeUserRequestDetailsParams struct {
	RequestID  sql.NullInt32   `json:"request_id"`
	Headers    json.RawMessage `json:"headers"`
	Host       sql.NullString  `json:"host"`
	RemoteAddr sql.NullString  `json:"remote_addr"`
}

func (q *Queries) InsertNominativeUserRequestDetails(ctx context.Context, arg InsertNominativeUserRequestDetailsParams) error {
	_, err := q.db.ExecContext(ctx, insertNominativeUserRequestDetails,
		arg.RequestID,
		arg.Headers,
		arg.Host,
		arg.RemoteAddr,
	)
	return err
}

const listNominativeUsersUploadedFiles = `-- name: ListNominativeUsersUploadedFiles :many

SELECT
   	count(*) OVER() AS totalRecords,
    nominative_user_requests.request_id,
    upload_id,
    scope,
    swidtag,
    aggregation_id,
    editor,
    created_by,
    created_at,
    record_failed,
    case 
      when record_succeed::jsonb = 'null' then 0
      else jsonb_array_length(record_succeed)
    end as record_succeed,
     case
      when record_failed::jsonb = 'null' then 0
      else jsonb_array_length(record_failed)
    end as record_failed,
    file_name,
    sheet_name,
        CASE 
   	     WHEN aggregation_id IS NOT NULL THEN aggregation_name
        ELSE  product_name
  	    END AS pname,
        CASE 
   	    WHEN aggregation_id IS NOT NULL THEN 'aggregation'
        ELSE  'individual'
  	    END AS nametype,
    product_name,
    product_version,
    aggregation_name,
    status
FROM
    nominative_user_requests
INNER JOIN nominative_user_requests_details
ON nominative_user_requests.request_id = nominative_user_requests_details.request_id 
where
    scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $2:: bool THEN nominative_user_requests.request_id = $3
            ELSE TRUE
        END
    )
    ORDER BY
    CASE
        WHEN $4:: bool THEN file_name
    END asc,
    CASE
        WHEN $5:: bool THEN file_name
    END desc,
    CASE
        WHEN $6:: bool THEN status
    END asc,
    CASE
        WHEN $7:: bool THEN status
    END desc,
    CASE
        WHEN $8:: bool THEN editor
    END asc,
    CASE
        WHEN $9:: bool THEN editor
    END desc,
    CASE
        WHEN $10:: bool THEN  CASE 
                WHEN aggregation_id IS NOT NULL THEN aggregation_name
                ELSE  product_name
            END
    END asc,
    CASE
        WHEN $11:: bool THEN  CASE 
                WHEN aggregation_id IS NOT NULL THEN aggregation_name
                ELSE  product_name
            END
    END desc,
    CASE
        WHEN $12:: bool THEN product_version
    END asc,
    CASE
        WHEN $13:: bool THEN product_version
    END desc,
    CASE
        WHEN $14:: bool THEN created_by
    END asc,
    CASE
        WHEN $15:: bool THEN created_by
    END desc,
    CASE
        WHEN $16:: bool THEN created_at
    END asc,
    CASE
        WHEN $17:: bool THEN created_at
    END desc,
    CASE
        WHEN $18:: bool THEN CASE 
   	    WHEN aggregation_id IS NOT NULL THEN 'aggregation'
        ELSE  'individual'
  	    END
    END asc,
    CASE
        WHEN $19:: bool THEN CASE 
   	    WHEN aggregation_id IS NOT NULL THEN 'aggregation'
        ELSE  'individual'
  	    END
    END desc
    LIMIT $21
    OFFSET $20
`

type ListNominativeUsersUploadedFilesParams struct {
	Scope              []string `json:"scope"`
	FileUploadID       bool     `json:"file_upload_id"`
	ID                 int32    `json:"id"`
	FileNameAsc        bool     `json:"file_name_asc"`
	FileNameDesc       bool     `json:"file_name_desc"`
	FileStatusAsc      bool     `json:"file_status_asc"`
	FileStatusDesc     bool     `json:"file_status_desc"`
	ProductEditorAsc   bool     `json:"product_editor_asc"`
	ProductEditorDesc  bool     `json:"product_editor_desc"`
	NameAsc            bool     `json:"name_asc"`
	NameDesc           bool     `json:"name_desc"`
	ProductVersionAsc  bool     `json:"product_version_asc"`
	ProductVersionDesc bool     `json:"product_version_desc"`
	CreatedByAsc       bool     `json:"created_by_asc"`
	CreatedByDesc      bool     `json:"created_by_desc"`
	CreatedOnAsc       bool     `json:"created_on_asc"`
	CreatedOnDesc      bool     `json:"created_on_desc"`
	ProducttypeAsc     bool     `json:"producttype_asc"`
	ProducttypeDesc    bool     `json:"producttype_desc"`
	PageNum            int32    `json:"page_num"`
	PageSize           int32    `json:"page_size"`
}

type ListNominativeUsersUploadedFilesRow struct {
	Totalrecords    int64           `json:"totalrecords"`
	RequestID       int32           `json:"request_id"`
	UploadID        string          `json:"upload_id"`
	Scope           string          `json:"scope"`
	Swidtag         sql.NullString  `json:"swidtag"`
	AggregationID   sql.NullString  `json:"aggregation_id"`
	Editor          sql.NullString  `json:"editor"`
	CreatedBy       sql.NullString  `json:"created_by"`
	CreatedAt       sql.NullTime    `json:"created_at"`
	RecordFailed    json.RawMessage `json:"record_failed"`
	RecordSucceed   interface{}     `json:"record_succeed"`
	RecordFailed_2  interface{}     `json:"record_failed_2"`
	FileName        sql.NullString  `json:"file_name"`
	SheetName       sql.NullString  `json:"sheet_name"`
	Pname           interface{}     `json:"pname"`
	Nametype        interface{}     `json:"nametype"`
	ProductName     sql.NullString  `json:"product_name"`
	ProductVersion  sql.NullString  `json:"product_version"`
	AggregationName sql.NullString  `json:"aggregation_name"`
	Status          string          `json:"status"`
}

func (q *Queries) ListNominativeUsersUploadedFiles(ctx context.Context, arg ListNominativeUsersUploadedFilesParams) ([]ListNominativeUsersUploadedFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listNominativeUsersUploadedFiles,
		pq.Array(arg.Scope),
		arg.FileUploadID,
		arg.ID,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.FileStatusAsc,
		arg.FileStatusDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NameAsc,
		arg.NameDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.CreatedByAsc,
		arg.CreatedByDesc,
		arg.CreatedOnAsc,
		arg.CreatedOnDesc,
		arg.ProducttypeAsc,
		arg.ProducttypeDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNominativeUsersUploadedFilesRow
	for rows.Next() {
		var i ListNominativeUsersUploadedFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.RequestID,
			&i.UploadID,
			&i.Scope,
			&i.Swidtag,
			&i.AggregationID,
			&i.Editor,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.RecordFailed,
			&i.RecordSucceed,
			&i.RecordFailed_2,
			&i.FileName,
			&i.SheetName,
			&i.Pname,
			&i.Nametype,
			&i.ProductName,
			&i.ProductVersion,
			&i.AggregationName,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNominativeUserDetailsRequestAnalysis = `-- name: UpdateNominativeUserDetailsRequestAnalysis :exec
UPDATE nominative_user_requests_details
SET
    record_succeed = $1,
	record_failed = $2
WHERE request_id = $3
`

type UpdateNominativeUserDetailsRequestAnalysisParams struct {
	RecordSucceed json.RawMessage `json:"record_succeed"`
	RecordFailed  json.RawMessage `json:"record_failed"`
	RequestID     sql.NullInt32   `json:"request_id"`
}

func (q *Queries) UpdateNominativeUserDetailsRequestAnalysis(ctx context.Context, arg UpdateNominativeUserDetailsRequestAnalysisParams) error {
	_, err := q.db.ExecContext(ctx, updateNominativeUserDetailsRequestAnalysis, arg.RecordSucceed, arg.RecordFailed, arg.RequestID)
	return err
}

const updateNominativeUserRequestAnalysis = `-- name: UpdateNominativeUserRequestAnalysis :one

UPDATE nominative_user_requests
SET
	total_dgraph_batches = $1
WHERE upload_id = $2 RETURNING request_id
`

type UpdateNominativeUserRequestAnalysisParams struct {
	TotalDgraphBatches sql.NullInt32 `json:"total_dgraph_batches"`
	UploadID           string        `json:"upload_id"`
}

func (q *Queries) UpdateNominativeUserRequestAnalysis(ctx context.Context, arg UpdateNominativeUserRequestAnalysisParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, updateNominativeUserRequestAnalysis, arg.TotalDgraphBatches, arg.UploadID)
	var request_id int32
	err := row.Scan(&request_id)
	return request_id, err
}

const updateNominativeUserRequestDgraphBatchSuccess = `-- name: UpdateNominativeUserRequestDgraphBatchSuccess :one

UPDATE nominative_user_requests
SET
    dgraph_completed_batches = (dgraph_completed_batches +1)
WHERE upload_id = $1 RETURNING dgraph_completed_batches,total_dgraph_batches,postgres_success,request_id
`

type UpdateNominativeUserRequestDgraphBatchSuccessRow struct {
	DgraphCompletedBatches sql.NullInt32 `json:"dgraph_completed_batches"`
	TotalDgraphBatches     sql.NullInt32 `json:"total_dgraph_batches"`
	PostgresSuccess        sql.NullBool  `json:"postgres_success"`
	RequestID              int32         `json:"request_id"`
}

func (q *Queries) UpdateNominativeUserRequestDgraphBatchSuccess(ctx context.Context, uploadID string) (UpdateNominativeUserRequestDgraphBatchSuccessRow, error) {
	row := q.db.QueryRowContext(ctx, updateNominativeUserRequestDgraphBatchSuccess, uploadID)
	var i UpdateNominativeUserRequestDgraphBatchSuccessRow
	err := row.Scan(
		&i.DgraphCompletedBatches,
		&i.TotalDgraphBatches,
		&i.PostgresSuccess,
		&i.RequestID,
	)
	return i, err
}

const updateNominativeUserRequestDgraphSuccess = `-- name: UpdateNominativeUserRequestDgraphSuccess :exec

UPDATE nominative_user_requests
SET
    dgraph_success= $1
WHERE upload_id = $2
`

type UpdateNominativeUserRequestDgraphSuccessParams struct {
	DgraphSuccess sql.NullBool `json:"dgraph_success"`
	UploadID      string       `json:"upload_id"`
}

func (q *Queries) UpdateNominativeUserRequestDgraphSuccess(ctx context.Context, arg UpdateNominativeUserRequestDgraphSuccessParams) error {
	_, err := q.db.ExecContext(ctx, updateNominativeUserRequestDgraphSuccess, arg.DgraphSuccess, arg.UploadID)
	return err
}

const updateNominativeUserRequestPostgresSuccess = `-- name: UpdateNominativeUserRequestPostgresSuccess :one
UPDATE nominative_user_requests
SET
    postgres_success = $1
WHERE upload_id = $2 RETURNING dgraph_completed_batches,total_dgraph_batches,request_id
`

type UpdateNominativeUserRequestPostgresSuccessParams struct {
	PostgresSuccess sql.NullBool `json:"postgres_success"`
	UploadID        string       `json:"upload_id"`
}

type UpdateNominativeUserRequestPostgresSuccessRow struct {
	DgraphCompletedBatches sql.NullInt32 `json:"dgraph_completed_batches"`
	TotalDgraphBatches     sql.NullInt32 `json:"total_dgraph_batches"`
	RequestID              int32         `json:"request_id"`
}

func (q *Queries) UpdateNominativeUserRequestPostgresSuccess(ctx context.Context, arg UpdateNominativeUserRequestPostgresSuccessParams) (UpdateNominativeUserRequestPostgresSuccessRow, error) {
	row := q.db.QueryRowContext(ctx, updateNominativeUserRequestPostgresSuccess, arg.PostgresSuccess, arg.UploadID)
	var i UpdateNominativeUserRequestPostgresSuccessRow
	err := row.Scan(&i.DgraphCompletedBatches, &i.TotalDgraphBatches, &i.RequestID)
	return i, err
}

const updateNominativeUserRequestSuccess = `-- name: UpdateNominativeUserRequestSuccess :exec

UPDATE nominative_user_requests
SET
    status = $1,
	dgraph_success = $2
WHERE request_id = $3
`

type UpdateNominativeUserRequestSuccessParams struct {
	Status        string       `json:"status"`
	DgraphSuccess sql.NullBool `json:"dgraph_success"`
	RequestID     int32        `json:"request_id"`
}

func (q *Queries) UpdateNominativeUserRequestSuccess(ctx context.Context, arg UpdateNominativeUserRequestSuccessParams) error {
	_, err := q.db.ExecContext(ctx, updateNominativeUserRequestSuccess, arg.Status, arg.DgraphSuccess, arg.RequestID)
	return err
}
