// Copyright (C) 2019 Orange
// 
// This software is distributed under the terms and conditions of the 'Apache License 2.0'
// license which can be found in the file 'License.txt' in this package distribution 
// or at 'http://www.apache.org/licenses/LICENSE-2.0'. 

// Code generated by MockGen. DO NOT EDIT.
// Source: optisam-backend/common/optisam/workerqueue (interfaces: Workerqueue)

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	job "optisam-backend/common/optisam/workerqueue/job"
	worker "optisam-backend/common/optisam/workerqueue/worker"
	reflect "reflect"
)

// MockWorkerqueue is a mock of Workerqueue interface
type MockWorkerqueue struct {
	ctrl     *gomock.Controller
	recorder *MockWorkerqueueMockRecorder
}

// MockWorkerqueueMockRecorder is the mock recorder for MockWorkerqueue
type MockWorkerqueueMockRecorder struct {
	mock *MockWorkerqueue
}

// NewMockWorkerqueue creates a new mock instance
func NewMockWorkerqueue(ctrl *gomock.Controller) *MockWorkerqueue {
	mock := &MockWorkerqueue{ctrl: ctrl}
	mock.recorder = &MockWorkerqueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockWorkerqueue) EXPECT() *MockWorkerqueueMockRecorder {
	return m.recorder
}

// Close mocks base method
func (m *MockWorkerqueue) Close(arg0 context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close", arg0)
}

// Close indicates an expected call of Close
func (mr *MockWorkerqueueMockRecorder) Close(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockWorkerqueue)(nil).Close), arg0)
}

// GetRetries mocks base method
func (m *MockWorkerqueue) GetRetries() int32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRetries")
	ret0, _ := ret[0].(int32)
	return ret0
}

// GetRetries indicates an expected call of GetRetries
func (mr *MockWorkerqueueMockRecorder) GetRetries() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRetries", reflect.TypeOf((*MockWorkerqueue)(nil).GetRetries))
}

// PushJob mocks base method
func (m *MockWorkerqueue) PushJob(arg0 context.Context, arg1 job.Job, arg2 string) (int32, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PushJob", arg0, arg1, arg2)
	ret0, _ := ret[0].(int32)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// PushJob indicates an expected call of PushJob
func (mr *MockWorkerqueueMockRecorder) PushJob(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PushJob", reflect.TypeOf((*MockWorkerqueue)(nil).PushJob), arg0, arg1, arg2)
}

// RegisterWorker mocks base method
func (m *MockWorkerqueue) RegisterWorker(arg0 context.Context, arg1 worker.Worker) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RegisterWorker", arg0, arg1)
}

// RegisterWorker indicates an expected call of RegisterWorker
func (mr *MockWorkerqueueMockRecorder) RegisterWorker(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterWorker", reflect.TypeOf((*MockWorkerqueue)(nil).RegisterWorker), arg0, arg1)
}

// ResumePendingJobs mocks base method
func (m *MockWorkerqueue) ResumePendingJobs(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ResumePendingJobs", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ResumePendingJobs indicates an expected call of ResumePendingJobs
func (mr *MockWorkerqueueMockRecorder) ResumePendingJobs(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResumePendingJobs", reflect.TypeOf((*MockWorkerqueue)(nil).ResumePendingJobs), arg0)
}
