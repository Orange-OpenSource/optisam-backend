// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (type,status,data,comments,start_time,end_time,meta_data) VALUES ($1,$2,$3,$4,$5,$6,$7) RETURNING job_id
`

type CreateJobParams struct {
	Type      string          `json:"type"`
	Status    JobStatus       `json:"status"`
	Data      json.RawMessage `json:"data"`
	Comments  sql.NullString  `json:"comments"`
	StartTime sql.NullTime    `json:"start_time"`
	EndTime   sql.NullTime    `json:"end_time"`
	MetaData  json.RawMessage `json:"meta_data"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createJob,
		arg.Type,
		arg.Status,
		arg.Data,
		arg.Comments,
		arg.StartTime,
		arg.EndTime,
		arg.MetaData,
	)
	var job_id int32
	err := row.Scan(&job_id)
	return job_id, err
}

const getJob = `-- name: GetJob :one
SELECT job_id, type, status, data, comments, start_time, end_time, created_at, retry_count, meta_data FROM jobs
WHERE job_id = $1
`

func (q *Queries) GetJob(ctx context.Context, jobID int32) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJob, jobID)
	var i Job
	err := row.Scan(
		&i.JobID,
		&i.Type,
		&i.Status,
		&i.Data,
		&i.Comments,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
		&i.RetryCount,
		&i.MetaData,
	)
	return i, err
}

const getJobs = `-- name: GetJobs :many
SELECT job_id, type, status, data, comments, start_time, end_time, created_at, retry_count, meta_data FROM jobs
`

func (q *Queries) GetJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, getJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.JobID,
			&i.Type,
			&i.Status,
			&i.Data,
			&i.Comments,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.RetryCount,
			&i.MetaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobsForRetry = `-- name: GetJobsForRetry :many
SELECT job_id, type, status, data, comments, start_time, end_time, created_at, retry_count, meta_data FROM Jobs WHERE status  not in ('FAILED' ,'COMPLETED')
`

func (q *Queries) GetJobsForRetry(ctx context.Context) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, getJobsForRetry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.JobID,
			&i.Type,
			&i.Status,
			&i.Data,
			&i.Comments,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.RetryCount,
			&i.MetaData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobStatusCompleted = `-- name: UpdateJobStatusCompleted :exec
UPDATE jobs SET status = $2,end_time = $3 WHERE job_id = $1
`

type UpdateJobStatusCompletedParams struct {
	JobID   int32        `json:"job_id"`
	Status  JobStatus    `json:"status"`
	EndTime sql.NullTime `json:"end_time"`
}

func (q *Queries) UpdateJobStatusCompleted(ctx context.Context, arg UpdateJobStatusCompletedParams) error {
	_, err := q.db.ExecContext(ctx, updateJobStatusCompleted, arg.JobID, arg.Status, arg.EndTime)
	return err
}

const updateJobStatusFailed = `-- name: UpdateJobStatusFailed :exec
UPDATE jobs SET status = $2, end_time = $3, comments = $4 , retry_count = $5 where job_id = $1
`

type UpdateJobStatusFailedParams struct {
	JobID      int32          `json:"job_id"`
	Status     JobStatus      `json:"status"`
	EndTime    sql.NullTime   `json:"end_time"`
	Comments   sql.NullString `json:"comments"`
	RetryCount sql.NullInt32  `json:"retry_count"`
}

func (q *Queries) UpdateJobStatusFailed(ctx context.Context, arg UpdateJobStatusFailedParams) error {
	_, err := q.db.ExecContext(ctx, updateJobStatusFailed,
		arg.JobID,
		arg.Status,
		arg.EndTime,
		arg.Comments,
		arg.RetryCount,
	)
	return err
}

const updateJobStatusRetry = `-- name: UpdateJobStatusRetry :exec
UPDATE jobs SET status = $2,retry_count = retry_count + 1 WHERE job_id = $1
`

type UpdateJobStatusRetryParams struct {
	JobID  int32     `json:"job_id"`
	Status JobStatus `json:"status"`
}

func (q *Queries) UpdateJobStatusRetry(ctx context.Context, arg UpdateJobStatusRetryParams) error {
	_, err := q.db.ExecContext(ctx, updateJobStatusRetry, arg.JobID, arg.Status)
	return err
}

const updateJobStatusRunning = `-- name: UpdateJobStatusRunning :exec
UPDATE jobs SET status = $2,start_time = $3 WHERE job_id = $1
`

type UpdateJobStatusRunningParams struct {
	JobID     int32        `json:"job_id"`
	Status    JobStatus    `json:"status"`
	StartTime sql.NullTime `json:"start_time"`
}

func (q *Queries) UpdateJobStatusRunning(ctx context.Context, arg UpdateJobStatusRunningParams) error {
	_, err := q.db.ExecContext(ctx, updateJobStatusRunning, arg.JobID, arg.Status, arg.StartTime)
	return err
}
