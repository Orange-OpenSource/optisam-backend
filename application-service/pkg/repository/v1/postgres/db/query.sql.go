// Copyright (C) 2019 Orange
// 
// This software is distributed under the terms and conditions of the 'Apache License 2.0'
// license which can be found in the file 'License.txt' in this package distribution 
// or at 'http://www.apache.org/licenses/LICENSE-2.0'. 

// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const getApplicationInstance = `-- name: GetApplicationInstance :one
SELECT application_id, instance_id, instance_environment, products, equipments, scope from applications_instances
WHERE instance_id = $1
`

func (q *Queries) GetApplicationInstance(ctx context.Context, instanceID string) (ApplicationsInstance, error) {
	row := q.db.QueryRowContext(ctx, getApplicationInstance, instanceID)
	var i ApplicationsInstance
	err := row.Scan(
		&i.ApplicationID,
		&i.InstanceID,
		&i.InstanceEnvironment,
		pq.Array(&i.Products),
		pq.Array(&i.Equipments),
		&i.Scope,
	)
	return i, err
}

const getApplicationsView = `-- name: GetApplicationsView :many
SELECT count(*) OVER() AS totalRecords,a.application_id,a.application_name,a.application_owner ,COUNT(ai.instance_id)::INTEGER as num_of_instances,COUNT(DISTINCT(ai.product))::INTEGER as num_of_products,COUNT(DISTINCT(ai.equipment))::INTEGER as num_of_equipments, 0::INTEGER as cost 
FROM applications a LEFT JOIN (select application_id,instance_id, products, UNNEST(products) as product,UNNEST(equipments) as equipment FROM applications_instances) ai
ON a.application_id = ai.application_id
WHERE 
  a.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(a.application_name) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(a.application_name) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(a.application_owner) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(a.application_owner) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN $9::TEXT = ANY(ai.products) ELSE TRUE END)
  GROUP BY a.application_id
  ORDER BY
  CASE WHEN $10::bool THEN a.application_id END asc,
  CASE WHEN $11::bool THEN a.application_id END desc,
  CASE WHEN $12::bool THEN application_name END asc,
  CASE WHEN $13::bool THEN application_name END desc,
  CASE WHEN $14::bool THEN application_owner END asc,
  CASE WHEN $15::bool THEN application_owner END desc,
  CASE WHEN $16::bool THEN 4 END asc,
  CASE WHEN $17::bool THEN 4 END desc,
  CASE WHEN $18::bool THEN 5 END asc,
  CASE WHEN $19::bool THEN 5 END desc,
  CASE WHEN $20::bool THEN 6 END asc,
  CASE WHEN $21::bool THEN 6 END desc,
  CASE WHEN $22::bool THEN 7 END asc,
  CASE WHEN $23::bool THEN 7 END desc
  LIMIT $25 OFFSET $24
`

type GetApplicationsViewParams struct {
	Scope                []string `json:"scope"`
	LkApplicationName    bool     `json:"lk_application_name"`
	ApplicationName      string   `json:"application_name"`
	IsApplicationName    bool     `json:"is_application_name"`
	LkApplicationOwner   bool     `json:"lk_application_owner"`
	ApplicationOwner     string   `json:"application_owner"`
	IsApplicationOwner   bool     `json:"is_application_owner"`
	IsProductID          bool     `json:"is_product_id"`
	ProductID            string   `json:"product_id"`
	ApplicationIDAsc     bool     `json:"application_id_asc"`
	ApplicationIDDesc    bool     `json:"application_id_desc"`
	ApplicationNameAsc   bool     `json:"application_name_asc"`
	ApplicationNameDesc  bool     `json:"application_name_desc"`
	ApplicationOwnerAsc  bool     `json:"application_owner_asc"`
	ApplicationOwnerDesc bool     `json:"application_owner_desc"`
	NumOfInstancesAsc    bool     `json:"num_of_instances_asc"`
	NumOfInstancesDesc   bool     `json:"num_of_instances_desc"`
	NumOfProductsAsc     bool     `json:"num_of_products_asc"`
	NumOfProductsDesc    bool     `json:"num_of_products_desc"`
	NumOfEquipmentsAsc   bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc  bool     `json:"num_of_equipments_desc"`
	CostAsc              bool     `json:"cost_asc"`
	CostDesc             bool     `json:"cost_desc"`
	PageNum              int32    `json:"page_num"`
	PageSize             int32    `json:"page_size"`
}

type GetApplicationsViewRow struct {
	Totalrecords     int64  `json:"totalrecords"`
	ApplicationID    string `json:"application_id"`
	ApplicationName  string `json:"application_name"`
	ApplicationOwner string `json:"application_owner"`
	NumOfInstances   int32  `json:"num_of_instances"`
	NumOfProducts    int32  `json:"num_of_products"`
	NumOfEquipments  int32  `json:"num_of_equipments"`
	Cost             int32  `json:"cost"`
}

func (q *Queries) GetApplicationsView(ctx context.Context, arg GetApplicationsViewParams) ([]GetApplicationsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsView,
		pq.Array(arg.Scope),
		arg.LkApplicationName,
		arg.ApplicationName,
		arg.IsApplicationName,
		arg.LkApplicationOwner,
		arg.ApplicationOwner,
		arg.IsApplicationOwner,
		arg.IsProductID,
		arg.ProductID,
		arg.ApplicationIDAsc,
		arg.ApplicationIDDesc,
		arg.ApplicationNameAsc,
		arg.ApplicationNameDesc,
		arg.ApplicationOwnerAsc,
		arg.ApplicationOwnerDesc,
		arg.NumOfInstancesAsc,
		arg.NumOfInstancesDesc,
		arg.NumOfProductsAsc,
		arg.NumOfProductsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApplicationsViewRow
	for rows.Next() {
		var i GetApplicationsViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ApplicationID,
			&i.ApplicationName,
			&i.ApplicationOwner,
			&i.NumOfInstances,
			&i.NumOfProducts,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstancesView = `-- name: GetInstancesView :many
SELECT count(*) OVER() AS totalRecords,ai.instance_id,ai.instance_environment,CARDINALITY(ai.products)::INTEGER as num_of_products,CARDINALITY(ai.equipments)::INTEGER as num_of_equipments 
FROM applications_instances ai
WHERE 
  ai.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN $3::TEXT = ANY (ai.products) ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN application_id = $5 ELSE TRUE END)
  ORDER BY
  CASE WHEN $6::bool THEN ai.instance_id END asc,
  CASE WHEN $7::bool THEN ai.instance_id END desc,
  CASE WHEN $8::bool THEN instance_environment END asc,
  CASE WHEN $9::bool THEN instance_environment END desc,
  CASE WHEN $10::bool THEN 3 END asc,
  CASE WHEN $11::bool THEN 3 END desc,
  CASE WHEN $12::bool THEN 4 END asc,
  CASE WHEN $13::bool THEN 4 END desc
  LIMIT $15 OFFSET $14
`

type GetInstancesViewParams struct {
	Scope                   []string `json:"scope"`
	IsProductID             bool     `json:"is_product_id"`
	ProductID               string   `json:"product_id"`
	IsApplicationID         bool     `json:"is_application_id"`
	ApplicationID           string   `json:"application_id"`
	InstanceIDAsc           bool     `json:"instance_id_asc"`
	InstanceIDDesc          bool     `json:"instance_id_desc"`
	InstanceEnvironmentAsc  bool     `json:"instance_environment_asc"`
	InstanceEnvironmentDesc bool     `json:"instance_environment_desc"`
	NumOfProductsAsc        bool     `json:"num_of_products_asc"`
	NumOfProductsDesc       bool     `json:"num_of_products_desc"`
	NumOfEquipmentsAsc      bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc     bool     `json:"num_of_equipments_desc"`
	PageNum                 int32    `json:"page_num"`
	PageSize                int32    `json:"page_size"`
}

type GetInstancesViewRow struct {
	Totalrecords        int64  `json:"totalrecords"`
	InstanceID          string `json:"instance_id"`
	InstanceEnvironment string `json:"instance_environment"`
	NumOfProducts       int32  `json:"num_of_products"`
	NumOfEquipments     int32  `json:"num_of_equipments"`
}

func (q *Queries) GetInstancesView(ctx context.Context, arg GetInstancesViewParams) ([]GetInstancesViewRow, error) {
	rows, err := q.db.QueryContext(ctx, getInstancesView,
		pq.Array(arg.Scope),
		arg.IsProductID,
		arg.ProductID,
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.InstanceIDAsc,
		arg.InstanceIDDesc,
		arg.InstanceEnvironmentAsc,
		arg.InstanceEnvironmentDesc,
		arg.NumOfProductsAsc,
		arg.NumOfProductsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInstancesViewRow
	for rows.Next() {
		var i GetInstancesViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.InstanceID,
			&i.InstanceEnvironment,
			&i.NumOfProducts,
			&i.NumOfEquipments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertApplication = `-- name: UpsertApplication :exec
INSERT INTO applications (application_id, application_name, application_version, application_owner, scope, created_on)
VALUES ($1,$2,$3,$4,$5,$6)
ON CONFLICT (application_id)
DO
 UPDATE SET application_name = $2, application_version = $3, application_owner = $4
`

type UpsertApplicationParams struct {
	ApplicationID      string    `json:"application_id"`
	ApplicationName    string    `json:"application_name"`
	ApplicationVersion string    `json:"application_version"`
	ApplicationOwner   string    `json:"application_owner"`
	Scope              string    `json:"scope"`
	CreatedOn          time.Time `json:"created_on"`
}

func (q *Queries) UpsertApplication(ctx context.Context, arg UpsertApplicationParams) error {
	_, err := q.db.ExecContext(ctx, upsertApplication,
		arg.ApplicationID,
		arg.ApplicationName,
		arg.ApplicationVersion,
		arg.ApplicationOwner,
		arg.Scope,
		arg.CreatedOn,
	)
	return err
}

const upsertApplicationInstance = `-- name: UpsertApplicationInstance :exec
INSERT INTO applications_instances (application_id, instance_id, instance_environment, products, equipments,scope)
VALUES ($1,$2,$3,$4,$5,$6)
ON CONFLICT (instance_id)
DO
 UPDATE SET instance_environment = $3, products = $4,equipments = $5
`

type UpsertApplicationInstanceParams struct {
	ApplicationID       string   `json:"application_id"`
	InstanceID          string   `json:"instance_id"`
	InstanceEnvironment string   `json:"instance_environment"`
	Products            []string `json:"products"`
	Equipments          []string `json:"equipments"`
	Scope               string   `json:"scope"`
}

func (q *Queries) UpsertApplicationInstance(ctx context.Context, arg UpsertApplicationInstanceParams) error {
	_, err := q.db.ExecContext(ctx, upsertApplicationInstance,
		arg.ApplicationID,
		arg.InstanceID,
		arg.InstanceEnvironment,
		pq.Array(arg.Products),
		pq.Array(arg.Equipments),
		arg.Scope,
	)
	return err
}
