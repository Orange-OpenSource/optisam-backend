// Copyright (C) 2019 Orange
// 
// This software is distributed under the terms and conditions of the 'Apache License 2.0'
// license which can be found in the file 'License.txt' in this package distribution 
// or at 'http://www.apache.org/licenses/LICENSE-2.0'. 

// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const deleteAggregation = `-- name: DeleteAggregation :exec
DELETE FROM aggregations 
WHERE aggregation_id = $1
AND aggregation_scope = ANY($2::TEXT[])
`

type DeleteAggregationParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

func (q *Queries) DeleteAggregation(ctx context.Context, arg DeleteAggregationParams) error {
	_, err := q.db.ExecContext(ctx, deleteAggregation, arg.AggregationID, pq.Array(arg.Scope))
	return err
}

const insertAggregation = `-- name: InsertAggregation :one
INSERT INTO aggregations (aggregation_name,aggregation_metric,aggregation_scope,products,created_by)
VALUES ($1,$2,$3,$4,$5) RETURNING aggregation_id, aggregation_name, aggregation_metric, aggregation_scope, products, created_on, created_by, updated_on, updated_by
`

type InsertAggregationParams struct {
	AggregationName   string   `json:"aggregation_name"`
	AggregationMetric string   `json:"aggregation_metric"`
	AggregationScope  string   `json:"aggregation_scope"`
	Products          []string `json:"products"`
	CreatedBy         string   `json:"created_by"`
}

func (q *Queries) InsertAggregation(ctx context.Context, arg InsertAggregationParams) (Aggregation, error) {
	row := q.db.QueryRowContext(ctx, insertAggregation,
		arg.AggregationName,
		arg.AggregationMetric,
		arg.AggregationScope,
		pq.Array(arg.Products),
		arg.CreatedBy,
	)
	var i Aggregation
	err := row.Scan(
		&i.AggregationID,
		&i.AggregationName,
		&i.AggregationMetric,
		&i.AggregationScope,
		pq.Array(&i.Products),
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const listAcqRightsAggregation = `-- name: ListAcqRightsAggregation :many
SELECT count(*) OVER() AS totalRecords,aggregation_id,aggregation_name,a.product_editor,a.metric,array_agg(a.sku)::TEXT[] as skus,array_agg(a.swidtag)::TEXT[] as swidtags,SUM(a.total_cost)::REAL as total_cost FROM 
acqrights a JOIN (SELECT aggregation_id,aggregation_name,aggregation_metric as metric,unnest(products) as swidtag FROM aggregations) ag
ON a.swidtag = ag.swidtag AND a.metric = ag.metric
WHERE 
    a.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(a.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(a.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(ag.aggregation_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(ag.aggregation_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(a.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(a.product_editor) = lower($9) ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(a.sku) LIKE '%' || lower($12::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $13::bool THEN lower(a.sku) = lower($12) ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(a.metric) LIKE '%' || lower($15::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $16::bool THEN lower(a.metric) = lower($15) ELSE TRUE END)
  GROUP BY ag.aggregation_id,ag.aggregation_name,a.product_editor,a.metric
  ORDER BY
  CASE WHEN $17::bool THEN aggregation_name END asc,
  CASE WHEN $18::bool THEN aggregation_name END desc,
  CASE WHEN $19::bool THEN a.product_editor END asc,
  CASE WHEN $20::bool THEN a.product_editor END desc,
  CASE WHEN $21::bool THEN a.metric END asc,
  CASE WHEN $22::bool THEN a.metric END desc,
  CASE WHEN $23::bool THEN 8 END asc,
  CASE WHEN $24::bool THEN 8 END desc
  LIMIT $26 OFFSET $25
`

type ListAcqRightsAggregationParams struct {
	Scope               []string `json:"scope"`
	LkSwidtag           bool     `json:"lk_swidtag"`
	Swidtag             string   `json:"swidtag"`
	IsSwidtag           bool     `json:"is_swidtag"`
	LkAggregationName   bool     `json:"lk_aggregation_name"`
	AggregationName     string   `json:"aggregation_name"`
	IsAggregationName   bool     `json:"is_aggregation_name"`
	LkProductEditor     bool     `json:"lk_product_editor"`
	ProductEditor       string   `json:"product_editor"`
	IsProductEditor     bool     `json:"is_product_editor"`
	LkSku               bool     `json:"lk_sku"`
	Sku                 string   `json:"sku"`
	IsSku               bool     `json:"is_sku"`
	LkMetric            bool     `json:"lk_metric"`
	Metric              string   `json:"metric"`
	IsMetric            bool     `json:"is_metric"`
	AggregationNameAsc  bool     `json:"aggregation_name_asc"`
	AggregationNameDesc bool     `json:"aggregation_name_desc"`
	ProductEditorAsc    bool     `json:"product_editor_asc"`
	ProductEditorDesc   bool     `json:"product_editor_desc"`
	MetricAsc           bool     `json:"metric_asc"`
	MetricDesc          bool     `json:"metric_desc"`
	TotalCostAsc        bool     `json:"total_cost_asc"`
	TotalCostDesc       bool     `json:"total_cost_desc"`
	PageNum             int32    `json:"page_num"`
	PageSize            int32    `json:"page_size"`
}

type ListAcqRightsAggregationRow struct {
	Totalrecords    int64    `json:"totalrecords"`
	AggregationID   int32    `json:"aggregation_id"`
	AggregationName string   `json:"aggregation_name"`
	ProductEditor   string   `json:"product_editor"`
	Metric          string   `json:"metric"`
	Skus            []string `json:"skus"`
	Swidtags        []string `json:"swidtags"`
	TotalCost       float32  `json:"total_cost"`
}

func (q *Queries) ListAcqRightsAggregation(ctx context.Context, arg ListAcqRightsAggregationParams) ([]ListAcqRightsAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsAggregation,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.LkSku,
		arg.Sku,
		arg.IsSku,
		arg.LkMetric,
		arg.Metric,
		arg.IsMetric,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.MetricAsc,
		arg.MetricDesc,
		arg.TotalCostAsc,
		arg.TotalCostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsAggregationRow
	for rows.Next() {
		var i ListAcqRightsAggregationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.AggregationID,
			&i.AggregationName,
			&i.ProductEditor,
			&i.Metric,
			pq.Array(&i.Skus),
			pq.Array(&i.Swidtags),
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsAggregationIndividual = `-- name: ListAcqRightsAggregationIndividual :many
SELECT a.entity,a.sku,a.swidtag,a.product_name,a.product_editor,a.metric,a.num_licenses_acquired,a.num_licences_maintainance,a.avg_unit_price,a.avg_maintenance_unit_price,a.total_purchase_cost,a.total_maintenance_cost,a.total_cost FROM 
acqrights a
WHERE 
  a.swidtag IN (SELECT UNNEST(products) from aggregations where aggregation_id = $1)
  AND a.scope = ANY($2::TEXT[])
`

type ListAcqRightsAggregationIndividualParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

type ListAcqRightsAggregationIndividualRow struct {
	Entity                  string  `json:"entity"`
	Sku                     string  `json:"sku"`
	Swidtag                 string  `json:"swidtag"`
	ProductName             string  `json:"product_name"`
	ProductEditor           string  `json:"product_editor"`
	Metric                  string  `json:"metric"`
	NumLicensesAcquired     int32   `json:"num_licenses_acquired"`
	NumLicencesMaintainance int32   `json:"num_licences_maintainance"`
	AvgUnitPrice            float32 `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice float32 `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       float32 `json:"total_purchase_cost"`
	TotalMaintenanceCost    float32 `json:"total_maintenance_cost"`
	TotalCost               float32 `json:"total_cost"`
}

func (q *Queries) ListAcqRightsAggregationIndividual(ctx context.Context, arg ListAcqRightsAggregationIndividualParams) ([]ListAcqRightsAggregationIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsAggregationIndividual, arg.AggregationID, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsAggregationIndividualRow
	for rows.Next() {
		var i ListAcqRightsAggregationIndividualRow
		if err := rows.Scan(
			&i.Entity,
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsEditors = `-- name: ListAcqRightsEditors :many
SELECT DISTINCT acq.product_editor
FROM acqrights acq
WHERE acq.scope = $1
`

func (q *Queries) ListAcqRightsEditors(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsEditors, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsIndividual = `-- name: ListAcqRightsIndividual :many
SELECT count(*) OVER() AS totalRecords,a.entity,a.sku,a.swidtag,a.product_name,a.product_editor,a.metric,a.num_licenses_acquired,a.num_licences_maintainance,a.avg_unit_price,a.avg_maintenance_unit_price,a.total_purchase_cost,a.total_maintenance_cost,a.total_cost FROM 
acqrights a
WHERE 
  a.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(a.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(a.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(a.product_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(a.product_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(a.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(a.product_editor) = lower($9) ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(a.sku) LIKE '%' || lower($12::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $13::bool THEN lower(a.sku) = lower($12) ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(a.metric) LIKE '%' || lower($15::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $16::bool THEN lower(a.metric) = lower($15) ELSE TRUE END)
  ORDER BY
  CASE WHEN $17::bool THEN a.swidtag END asc,
  CASE WHEN $18::bool THEN a.swidtag END desc,
  CASE WHEN $19::bool THEN a.product_name END asc,
  CASE WHEN $20::bool THEN a.product_name END desc,
  CASE WHEN $21::bool THEN a.product_editor END asc,
  CASE WHEN $22::bool THEN a.product_editor END desc,
  CASE WHEN $23::bool THEN a.sku END asc,
  CASE WHEN $24::bool THEN a.sku END desc,
  CASE WHEN $25::bool THEN a.metric END asc,
  CASE WHEN $26::bool THEN a.metric END desc,
  CASE WHEN $27::bool THEN a.entity END asc,
  CASE WHEN $28::bool THEN a.entity END desc,
  CASE WHEN $29::bool THEN a.num_licenses_acquired END asc,
  CASE WHEN $30::bool THEN a.num_licenses_acquired END desc,
  CASE WHEN $31::bool THEN a.num_licences_maintainance END asc,
  CASE WHEN $32::bool THEN a.num_licences_maintainance END desc,
  CASE WHEN $33::bool THEN a.avg_unit_price END asc,
  CASE WHEN $34::bool THEN a.avg_unit_price END desc,  
  CASE WHEN $35::bool THEN a.avg_maintenance_unit_price END asc,
  CASE WHEN $36::bool THEN a.avg_maintenance_unit_price END desc,
  CASE WHEN $37::bool THEN a.total_purchase_cost END asc,
  CASE WHEN $38::bool THEN a.total_purchase_cost END desc,
  CASE WHEN $39::bool THEN a.total_maintenance_cost END asc,
  CASE WHEN $40::bool THEN a.total_maintenance_cost END desc,
  CASE WHEN $41::bool THEN a.total_cost END asc,
  CASE WHEN $42::bool THEN a.total_cost END desc
  LIMIT $44 OFFSET $43
`

type ListAcqRightsIndividualParams struct {
	Scope                       []string `json:"scope"`
	LkSwidtag                   bool     `json:"lk_swidtag"`
	Swidtag                     string   `json:"swidtag"`
	IsSwidtag                   bool     `json:"is_swidtag"`
	LkProductName               bool     `json:"lk_product_name"`
	ProductName                 string   `json:"product_name"`
	IsProductName               bool     `json:"is_product_name"`
	LkProductEditor             bool     `json:"lk_product_editor"`
	ProductEditor               string   `json:"product_editor"`
	IsProductEditor             bool     `json:"is_product_editor"`
	LkSku                       bool     `json:"lk_sku"`
	Sku                         string   `json:"sku"`
	IsSku                       bool     `json:"is_sku"`
	LkMetric                    bool     `json:"lk_metric"`
	Metric                      string   `json:"metric"`
	IsMetric                    bool     `json:"is_metric"`
	SwidtagAsc                  bool     `json:"swidtag_asc"`
	SwidtagDesc                 bool     `json:"swidtag_desc"`
	ProductNameAsc              bool     `json:"product_name_asc"`
	ProductNameDesc             bool     `json:"product_name_desc"`
	ProductEditorAsc            bool     `json:"product_editor_asc"`
	ProductEditorDesc           bool     `json:"product_editor_desc"`
	SkuAsc                      bool     `json:"sku_asc"`
	SkuDesc                     bool     `json:"sku_desc"`
	MetricAsc                   bool     `json:"metric_asc"`
	MetricDesc                  bool     `json:"metric_desc"`
	EntityAsc                   bool     `json:"entity_asc"`
	EntityDesc                  bool     `json:"entity_desc"`
	NumLicensesAcquiredAsc      bool     `json:"num_licenses_acquired_asc"`
	NumLicensesAcquiredDesc     bool     `json:"num_licenses_acquired_desc"`
	NumLicencesMaintainanceAsc  bool     `json:"num_licences_maintainance_asc"`
	NumLicencesMaintainanceDesc bool     `json:"num_licences_maintainance_desc"`
	AvgUnitPriceAsc             bool     `json:"avg_unit_price_asc"`
	AvgUnitPriceDesc            bool     `json:"avg_unit_price_desc"`
	AvgMaintenanceUnitPriceAsc  bool     `json:"avg_maintenance_unit_price_asc"`
	AvgMaintenanceUnitPriceDesc bool     `json:"avg_maintenance_unit_price_desc"`
	TotalPurchaseCostAsc        bool     `json:"total_purchase_cost_asc"`
	TotalPurchaseCostDesc       bool     `json:"total_purchase_cost_desc"`
	TotalMaintenanceCostAsc     bool     `json:"total_maintenance_cost_asc"`
	TotalMaintenanceCostDesc    bool     `json:"total_maintenance_cost_desc"`
	TotalCostAsc                bool     `json:"total_cost_asc"`
	TotalCostDesc               bool     `json:"total_cost_desc"`
	PageNum                     int32    `json:"page_num"`
	PageSize                    int32    `json:"page_size"`
}

type ListAcqRightsIndividualRow struct {
	Totalrecords            int64   `json:"totalrecords"`
	Entity                  string  `json:"entity"`
	Sku                     string  `json:"sku"`
	Swidtag                 string  `json:"swidtag"`
	ProductName             string  `json:"product_name"`
	ProductEditor           string  `json:"product_editor"`
	Metric                  string  `json:"metric"`
	NumLicensesAcquired     int32   `json:"num_licenses_acquired"`
	NumLicencesMaintainance int32   `json:"num_licences_maintainance"`
	AvgUnitPrice            float32 `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice float32 `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       float32 `json:"total_purchase_cost"`
	TotalMaintenanceCost    float32 `json:"total_maintenance_cost"`
	TotalCost               float32 `json:"total_cost"`
}

func (q *Queries) ListAcqRightsIndividual(ctx context.Context, arg ListAcqRightsIndividualParams) ([]ListAcqRightsIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsIndividual,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.LkSku,
		arg.Sku,
		arg.IsSku,
		arg.LkMetric,
		arg.Metric,
		arg.IsMetric,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.SkuAsc,
		arg.SkuDesc,
		arg.MetricAsc,
		arg.MetricDesc,
		arg.EntityAsc,
		arg.EntityDesc,
		arg.NumLicensesAcquiredAsc,
		arg.NumLicensesAcquiredDesc,
		arg.NumLicencesMaintainanceAsc,
		arg.NumLicencesMaintainanceDesc,
		arg.AvgUnitPriceAsc,
		arg.AvgUnitPriceDesc,
		arg.AvgMaintenanceUnitPriceAsc,
		arg.AvgMaintenanceUnitPriceDesc,
		arg.TotalPurchaseCostAsc,
		arg.TotalPurchaseCostDesc,
		arg.TotalMaintenanceCostAsc,
		arg.TotalMaintenanceCostDesc,
		arg.TotalCostAsc,
		arg.TotalCostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsIndividualRow
	for rows.Next() {
		var i ListAcqRightsIndividualRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Entity,
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsMetrics = `-- name: ListAcqRightsMetrics :many
SELECT DISTINCT acq.metric
FROM acqrights acq
WHERE acq.scope = $1
`

func (q *Queries) ListAcqRightsMetrics(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsMetrics, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var metric string
		if err := rows.Scan(&metric); err != nil {
			return nil, err
		}
		items = append(items, metric)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsProducts = `-- name: ListAcqRightsProducts :many
SELECT swidtag,product_name
FROM acqrights acq
WHERE swidtag NOT IN (SELECT UNNEST(products) from aggregations)
AND acq.metric = $1
AND acq.product_editor = $2
AND acq.scope = $3
`

type ListAcqRightsProductsParams struct {
	Metric string `json:"metric"`
	Editor string `json:"editor"`
	Scope  string `json:"scope"`
}

type ListAcqRightsProductsRow struct {
	Swidtag     string `json:"swidtag"`
	ProductName string `json:"product_name"`
}

func (q *Queries) ListAcqRightsProducts(ctx context.Context, arg ListAcqRightsProductsParams) ([]ListAcqRightsProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsProducts, arg.Metric, arg.Editor, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsProductsRow
	for rows.Next() {
		var i ListAcqRightsProductsRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregation = `-- name: ListAggregation :many
SELECT aggregation_id,aggregation_name,aggregation_metric,acq.product_editor,aggregation_scope,
ARRAY_AGG(acq.product_name)::TEXT[] as product_names,ARRAY_AGG(agg.swidtag)::TEXT[] as product_swidtags
FROM acqrights acq JOIN 
(SELECT aggregation_id,aggregation_name,aggregation_metric,aggregation_scope,unnest(products) swidtag,created_on,created_by,updated_on,updated_by from aggregations WHERE aggregation_scope = ANY($1::TEXT[])) agg
ON acq.swidtag = agg.swidtag AND acq.metric = agg.aggregation_metric
GROUP BY agg.aggregation_id,agg.aggregation_name,agg.aggregation_metric,acq.product_editor,agg.aggregation_scope
`

type ListAggregationRow struct {
	AggregationID     int32    `json:"aggregation_id"`
	AggregationName   string   `json:"aggregation_name"`
	AggregationMetric string   `json:"aggregation_metric"`
	ProductEditor     string   `json:"product_editor"`
	AggregationScope  string   `json:"aggregation_scope"`
	ProductNames      []string `json:"product_names"`
	ProductSwidtags   []string `json:"product_swidtags"`
}

func (q *Queries) ListAggregation(ctx context.Context, scope []string) ([]ListAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregation, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationRow
	for rows.Next() {
		var i ListAggregationRow
		if err := rows.Scan(
			&i.AggregationID,
			&i.AggregationName,
			&i.AggregationMetric,
			&i.ProductEditor,
			&i.AggregationScope,
			pq.Array(&i.ProductNames),
			pq.Array(&i.ProductSwidtags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAggregation = `-- name: UpdateAggregation :one
UPDATE aggregations
SET aggregation_name = $1,products = $2
WHERE aggregation_id = $3
AND aggregation_scope = ANY($4::TEXT[])
RETURNING aggregation_id, aggregation_name, aggregation_metric, aggregation_scope, products, created_on, created_by, updated_on, updated_by
`

type UpdateAggregationParams struct {
	AggregationName string   `json:"aggregation_name"`
	Products        []string `json:"products"`
	AggregationID   int32    `json:"aggregation_id"`
	Scope           []string `json:"scope"`
}

func (q *Queries) UpdateAggregation(ctx context.Context, arg UpdateAggregationParams) (Aggregation, error) {
	row := q.db.QueryRowContext(ctx, updateAggregation,
		arg.AggregationName,
		pq.Array(arg.Products),
		arg.AggregationID,
		pq.Array(arg.Scope),
	)
	var i Aggregation
	err := row.Scan(
		&i.AggregationID,
		&i.AggregationName,
		&i.AggregationMetric,
		&i.AggregationScope,
		pq.Array(&i.Products),
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const upsertAcqRights = `-- name: UpsertAcqRights :exec
INSERT INTO acqrights (sku,swidtag,product_name,product_editor,entity,scope,metric,num_licenses_acquired,num_licences_maintainance,avg_unit_price,avg_maintenance_unit_price,total_purchase_cost,total_maintenance_cost,total_cost,created_by)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15)
ON CONFLICT (sku)
DO
UPDATE SET swidtag = $2,product_name = $3,product_editor = $4,entity = $5,scope = $6,metric = $7,num_licenses_acquired = $8,
            num_licences_maintainance = $9,avg_unit_price = $10,avg_maintenance_unit_price = $11,total_purchase_cost = 12,
            total_maintenance_cost = $13,total_cost = $14,updated_on = $16,updated_by = $17
`

type UpsertAcqRightsParams struct {
	Sku                     string         `json:"sku"`
	Swidtag                 string         `json:"swidtag"`
	ProductName             string         `json:"product_name"`
	ProductEditor           string         `json:"product_editor"`
	Entity                  string         `json:"entity"`
	Scope                   string         `json:"scope"`
	Metric                  string         `json:"metric"`
	NumLicensesAcquired     int32          `json:"num_licenses_acquired"`
	NumLicencesMaintainance int32          `json:"num_licences_maintainance"`
	AvgUnitPrice            float32        `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice float32        `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       float32        `json:"total_purchase_cost"`
	TotalMaintenanceCost    float32        `json:"total_maintenance_cost"`
	TotalCost               float32        `json:"total_cost"`
	CreatedBy               string         `json:"created_by"`
	UpdatedOn               sql.NullTime   `json:"updated_on"`
	UpdatedBy               sql.NullString `json:"updated_by"`
}

func (q *Queries) UpsertAcqRights(ctx context.Context, arg UpsertAcqRightsParams) error {
	_, err := q.db.ExecContext(ctx, upsertAcqRights,
		arg.Sku,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductEditor,
		arg.Entity,
		arg.Scope,
		arg.Metric,
		arg.NumLicensesAcquired,
		arg.NumLicencesMaintainance,
		arg.AvgUnitPrice,
		arg.AvgMaintenanceUnitPrice,
		arg.TotalPurchaseCost,
		arg.TotalMaintenanceCost,
		arg.TotalCost,
		arg.CreatedBy,
		arg.UpdatedOn,
		arg.UpdatedBy,
	)
	return err
}
