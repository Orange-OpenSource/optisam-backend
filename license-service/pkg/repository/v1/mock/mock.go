// Code generated by MockGen. DO NOT EDIT.
// Source: optisam-backend/license-service/pkg/repository/v1 (interfaces: License)

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	v1 "optisam-backend/license-service/pkg/repository/v1"
	reflect "reflect"
)

// MockLicense is a mock of License interface
type MockLicense struct {
	ctrl     *gomock.Controller
	recorder *MockLicenseMockRecorder
}

// MockLicenseMockRecorder is the mock recorder for MockLicense
type MockLicenseMockRecorder struct {
	mock *MockLicense
}

// NewMockLicense creates a new mock instance
func NewMockLicense(ctrl *gomock.Controller) *MockLicense {
	mock := &MockLicense{ctrl: ctrl}
	mock.recorder = &MockLicenseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLicense) EXPECT() *MockLicenseMockRecorder {
	return m.recorder
}

// AggregationDetails mocks base method
func (m *MockLicense) AggregationDetails(arg0 context.Context, arg1 string, arg2 []*v1.Metric, arg3 bool, arg4 ...string) (*v1.AggregationInfo, []*v1.ProductAcquiredRight, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AggregationDetails", varargs...)
	ret0, _ := ret[0].(*v1.AggregationInfo)
	ret1, _ := ret[1].([]*v1.ProductAcquiredRight)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AggregationDetails indicates an expected call of AggregationDetails
func (mr *MockLicenseMockRecorder) AggregationDetails(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregationDetails", reflect.TypeOf((*MockLicense)(nil).AggregationDetails), varargs...)
}

// AggregationIndividualRights mocks base method
func (m *MockLicense) AggregationIndividualRights(arg0 context.Context, arg1, arg2 []string, arg3 ...string) ([]*v1.AcqRightsInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AggregationIndividualRights", varargs...)
	ret0, _ := ret[0].([]*v1.AcqRightsInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AggregationIndividualRights indicates an expected call of AggregationIndividualRights
func (mr *MockLicenseMockRecorder) AggregationIndividualRights(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregationIndividualRights", reflect.TypeOf((*MockLicense)(nil).AggregationIndividualRights), varargs...)
}

// ComputedLicensesForEquipmentForMetricOracleProcessorStandard mocks base method
func (m *MockLicense) ComputedLicensesForEquipmentForMetricOracleProcessorStandard(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricOPSComputed, arg4 ...string) (int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ComputedLicensesForEquipmentForMetricOracleProcessorStandard", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ComputedLicensesForEquipmentForMetricOracleProcessorStandard indicates an expected call of ComputedLicensesForEquipmentForMetricOracleProcessorStandard
func (mr *MockLicenseMockRecorder) ComputedLicensesForEquipmentForMetricOracleProcessorStandard(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ComputedLicensesForEquipmentForMetricOracleProcessorStandard", reflect.TypeOf((*MockLicense)(nil).ComputedLicensesForEquipmentForMetricOracleProcessorStandard), varargs...)
}

// ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll mocks base method
func (m *MockLicense) ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricOPSComputed, arg4 ...string) (int64, float64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(float64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll indicates an expected call of ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll
func (mr *MockLicenseMockRecorder) ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll", reflect.TypeOf((*MockLicense)(nil).ComputedLicensesForEquipmentForMetricOracleProcessorStandardAll), varargs...)
}

// CreateEquipmentType mocks base method
func (m *MockLicense) CreateEquipmentType(arg0 context.Context, arg1 *v1.EquipmentType, arg2 []string) (*v1.EquipmentType, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateEquipmentType", arg0, arg1, arg2)
	ret0, _ := ret[0].(*v1.EquipmentType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateEquipmentType indicates an expected call of CreateEquipmentType
func (mr *MockLicenseMockRecorder) CreateEquipmentType(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateEquipmentType", reflect.TypeOf((*MockLicense)(nil).CreateEquipmentType), arg0, arg1, arg2)
}

// EquipmentTypes mocks base method
func (m *MockLicense) EquipmentTypes(arg0 context.Context, arg1 ...string) ([]*v1.EquipmentType, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EquipmentTypes", varargs...)
	ret0, _ := ret[0].([]*v1.EquipmentType)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EquipmentTypes indicates an expected call of EquipmentTypes
func (mr *MockLicenseMockRecorder) EquipmentTypes(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EquipmentTypes", reflect.TypeOf((*MockLicense)(nil).EquipmentTypes), varargs...)
}

// GetAcqRights mocks base method
func (m *MockLicense) GetAcqRights(arg0 context.Context, arg1 []string, arg2, arg3 string) ([]*v1.Acqrights, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAcqRights", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].([]*v1.Acqrights)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAcqRights indicates an expected call of GetAcqRights
func (mr *MockLicenseMockRecorder) GetAcqRights(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAcqRights", reflect.TypeOf((*MockLicense)(nil).GetAcqRights), arg0, arg1, arg2, arg3)
}

// GetAggregations mocks base method
func (m *MockLicense) GetAggregations(arg0 context.Context, arg1, arg2 string) ([]*v1.Aggregation, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregations", arg0, arg1, arg2)
	ret0, _ := ret[0].([]*v1.Aggregation)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregations indicates an expected call of GetAggregations
func (mr *MockLicenseMockRecorder) GetAggregations(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregations", reflect.TypeOf((*MockLicense)(nil).GetAggregations), arg0, arg1, arg2)
}

// GetMetricNUPByTransformMetricName mocks base method
func (m *MockLicense) GetMetricNUPByTransformMetricName(arg0 context.Context, arg1, arg2 string) (*v1.MetricNUPOracle, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMetricNUPByTransformMetricName", arg0, arg1, arg2)
	ret0, _ := ret[0].(*v1.MetricNUPOracle)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMetricNUPByTransformMetricName indicates an expected call of GetMetricNUPByTransformMetricName
func (mr *MockLicenseMockRecorder) GetMetricNUPByTransformMetricName(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetricNUPByTransformMetricName", reflect.TypeOf((*MockLicense)(nil).GetMetricNUPByTransformMetricName), arg0, arg1, arg2)
}

// GetProdAllocatedMetric mocks base method
func (m *MockLicense) GetProdAllocatedMetric(arg0 context.Context, arg1 []string, arg2 ...string) ([]*v1.ProductAllocationEquipmentMetrics, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProdAllocatedMetric", varargs...)
	ret0, _ := ret[0].([]*v1.ProductAllocationEquipmentMetrics)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProdAllocatedMetric indicates an expected call of GetProdAllocatedMetric
func (mr *MockLicenseMockRecorder) GetProdAllocatedMetric(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProdAllocatedMetric", reflect.TypeOf((*MockLicense)(nil).GetProdAllocatedMetric), varargs...)
}

// GetProductInformation mocks base method
func (m *MockLicense) GetProductInformation(arg0 context.Context, arg1 string, arg2 ...string) (*v1.ProductAdditionalInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProductInformation", varargs...)
	ret0, _ := ret[0].(*v1.ProductAdditionalInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProductInformation indicates an expected call of GetProductInformation
func (mr *MockLicenseMockRecorder) GetProductInformation(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProductInformation", reflect.TypeOf((*MockLicense)(nil).GetProductInformation), varargs...)
}

// GetProductInformationFromAcqRight mocks base method
func (m *MockLicense) GetProductInformationFromAcqRight(arg0 context.Context, arg1 string, arg2 ...string) (*v1.ProductAdditionalInfo, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProductInformationFromAcqRight", varargs...)
	ret0, _ := ret[0].(*v1.ProductAdditionalInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProductInformationFromAcqRight indicates an expected call of GetProductInformationFromAcqRight
func (mr *MockLicenseMockRecorder) GetProductInformationFromAcqRight(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProductInformationFromAcqRight", reflect.TypeOf((*MockLicense)(nil).GetProductInformationFromAcqRight), varargs...)
}

// GetProductsByEditorProductName mocks base method
func (m *MockLicense) GetProductsByEditorProductName(arg0 context.Context, arg1 []*v1.Metric, arg2, arg3, arg4 string) ([]*v1.ProductDetail, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetProductsByEditorProductName", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].([]*v1.ProductDetail)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetProductsByEditorProductName indicates an expected call of GetProductsByEditorProductName
func (mr *MockLicenseMockRecorder) GetProductsByEditorProductName(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProductsByEditorProductName", reflect.TypeOf((*MockLicense)(nil).GetProductsByEditorProductName), arg0, arg1, arg2, arg3, arg4)
}

// IsProductPurchasedInAggregation mocks base method
func (m *MockLicense) IsProductPurchasedInAggregation(arg0 context.Context, arg1, arg2 string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsProductPurchasedInAggregation", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsProductPurchasedInAggregation indicates an expected call of IsProductPurchasedInAggregation
func (mr *MockLicenseMockRecorder) IsProductPurchasedInAggregation(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsProductPurchasedInAggregation", reflect.TypeOf((*MockLicense)(nil).IsProductPurchasedInAggregation), arg0, arg1, arg2)
}

// ListMetricACS mocks base method
func (m *MockLicense) ListMetricACS(arg0 context.Context, arg1 ...string) ([]*v1.MetricACS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricACS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricACS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricACS indicates an expected call of ListMetricACS
func (mr *MockLicenseMockRecorder) ListMetricACS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricACS", reflect.TypeOf((*MockLicense)(nil).ListMetricACS), varargs...)
}

// ListMetricAttrSum mocks base method
func (m *MockLicense) ListMetricAttrSum(arg0 context.Context, arg1 ...string) ([]*v1.MetricAttrSumStand, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricAttrSum", varargs...)
	ret0, _ := ret[0].([]*v1.MetricAttrSumStand)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricAttrSum indicates an expected call of ListMetricAttrSum
func (mr *MockLicenseMockRecorder) ListMetricAttrSum(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricAttrSum", reflect.TypeOf((*MockLicense)(nil).ListMetricAttrSum), varargs...)
}

// ListMetricEquipAttr mocks base method
func (m *MockLicense) ListMetricEquipAttr(arg0 context.Context, arg1 ...string) ([]*v1.MetricEquipAttrStand, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricEquipAttr", varargs...)
	ret0, _ := ret[0].([]*v1.MetricEquipAttrStand)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricEquipAttr indicates an expected call of ListMetricEquipAttr
func (mr *MockLicenseMockRecorder) ListMetricEquipAttr(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricEquipAttr", reflect.TypeOf((*MockLicense)(nil).ListMetricEquipAttr), varargs...)
}

// ListMetricINM mocks base method
func (m *MockLicense) ListMetricINM(arg0 context.Context, arg1 ...string) ([]*v1.MetricINM, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricINM", varargs...)
	ret0, _ := ret[0].([]*v1.MetricINM)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricINM indicates an expected call of ListMetricINM
func (mr *MockLicenseMockRecorder) ListMetricINM(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricINM", reflect.TypeOf((*MockLicense)(nil).ListMetricINM), varargs...)
}

// ListMetricIPS mocks base method
func (m *MockLicense) ListMetricIPS(arg0 context.Context, arg1 ...string) ([]*v1.MetricIPS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricIPS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricIPS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricIPS indicates an expected call of ListMetricIPS
func (mr *MockLicenseMockRecorder) ListMetricIPS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricIPS", reflect.TypeOf((*MockLicense)(nil).ListMetricIPS), varargs...)
}

// ListMetricNUP mocks base method
func (m *MockLicense) ListMetricNUP(arg0 context.Context, arg1 ...string) ([]*v1.MetricNUPOracle, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricNUP", varargs...)
	ret0, _ := ret[0].([]*v1.MetricNUPOracle)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricNUP indicates an expected call of ListMetricNUP
func (mr *MockLicenseMockRecorder) ListMetricNUP(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricNUP", reflect.TypeOf((*MockLicense)(nil).ListMetricNUP), varargs...)
}

// ListMetricOPS mocks base method
func (m *MockLicense) ListMetricOPS(arg0 context.Context, arg1 ...string) ([]*v1.MetricOPS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricOPS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricOPS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricOPS indicates an expected call of ListMetricOPS
func (mr *MockLicenseMockRecorder) ListMetricOPS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricOPS", reflect.TypeOf((*MockLicense)(nil).ListMetricOPS), varargs...)
}

// ListMetricSPS mocks base method
func (m *MockLicense) ListMetricSPS(arg0 context.Context, arg1 ...string) ([]*v1.MetricSPS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricSPS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricSPS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricSPS indicates an expected call of ListMetricSPS
func (mr *MockLicenseMockRecorder) ListMetricSPS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricSPS", reflect.TypeOf((*MockLicense)(nil).ListMetricSPS), varargs...)
}

// ListMetricSS mocks base method
func (m *MockLicense) ListMetricSS(arg0 context.Context, arg1 ...string) ([]*v1.MetricSS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricSS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricSS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricSS indicates an expected call of ListMetricSS
func (mr *MockLicenseMockRecorder) ListMetricSS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricSS", reflect.TypeOf((*MockLicense)(nil).ListMetricSS), varargs...)
}

// ListMetricUCS mocks base method
func (m *MockLicense) ListMetricUCS(arg0 context.Context, arg1 ...string) ([]*v1.MetricUCS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricUCS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricUCS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricUCS indicates an expected call of ListMetricUCS
func (mr *MockLicenseMockRecorder) ListMetricUCS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricUCS", reflect.TypeOf((*MockLicense)(nil).ListMetricUCS), varargs...)
}

// ListMetricUNS mocks base method
func (m *MockLicense) ListMetricUNS(arg0 context.Context, arg1 ...string) ([]*v1.MetricUNS, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricUNS", varargs...)
	ret0, _ := ret[0].([]*v1.MetricUNS)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricUNS indicates an expected call of ListMetricUNS
func (mr *MockLicenseMockRecorder) ListMetricUNS(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricUNS", reflect.TypeOf((*MockLicense)(nil).ListMetricUNS), varargs...)
}

// ListMetricUserSum mocks base method
func (m *MockLicense) ListMetricUserSum(arg0 context.Context, arg1 ...string) ([]*v1.MetricUserSumStand, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetricUserSum", varargs...)
	ret0, _ := ret[0].([]*v1.MetricUserSumStand)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetricUserSum indicates an expected call of ListMetricUserSum
func (mr *MockLicenseMockRecorder) ListMetricUserSum(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetricUserSum", reflect.TypeOf((*MockLicense)(nil).ListMetricUserSum), varargs...)
}

// ListMetrices mocks base method
func (m *MockLicense) ListMetrices(arg0 context.Context, arg1 ...string) ([]*v1.Metric, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListMetrices", varargs...)
	ret0, _ := ret[0].([]*v1.Metric)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListMetrices indicates an expected call of ListMetrices
func (mr *MockLicenseMockRecorder) ListMetrices(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListMetrices", reflect.TypeOf((*MockLicense)(nil).ListMetrices), varargs...)
}

// MetadataAllWithType mocks base method
func (m *MockLicense) MetadataAllWithType(arg0 context.Context, arg1 v1.MetadataType, arg2 ...string) ([]*v1.Metadata, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetadataAllWithType", varargs...)
	ret0, _ := ret[0].([]*v1.Metadata)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetadataAllWithType indicates an expected call of MetadataAllWithType
func (mr *MockLicenseMockRecorder) MetadataAllWithType(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetadataAllWithType", reflect.TypeOf((*MockLicense)(nil).MetadataAllWithType), varargs...)
}

// MetricACSComputedLicenses mocks base method
func (m *MockLicense) MetricACSComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricACSComputed, arg3 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricACSComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricACSComputedLicenses indicates an expected call of MetricACSComputedLicenses
func (mr *MockLicenseMockRecorder) MetricACSComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricACSComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricACSComputedLicenses), varargs...)
}

// MetricACSComputedLicensesAgg mocks base method
func (m *MockLicense) MetricACSComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricACSComputed, arg4 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricACSComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricACSComputedLicensesAgg indicates an expected call of MetricACSComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricACSComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricACSComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricACSComputedLicensesAgg), varargs...)
}

// MetricAttrSumComputedLicenses mocks base method
func (m *MockLicense) MetricAttrSumComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricAttrSumStandComputed, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricAttrSumComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricAttrSumComputedLicenses indicates an expected call of MetricAttrSumComputedLicenses
func (mr *MockLicenseMockRecorder) MetricAttrSumComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricAttrSumComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricAttrSumComputedLicenses), varargs...)
}

// MetricAttrSumComputedLicensesAgg mocks base method
func (m *MockLicense) MetricAttrSumComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricAttrSumStandComputed, arg4 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricAttrSumComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricAttrSumComputedLicensesAgg indicates an expected call of MetricAttrSumComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricAttrSumComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricAttrSumComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricAttrSumComputedLicensesAgg), varargs...)
}

// MetricEquipAttrComputedLicenses mocks base method
func (m *MockLicense) MetricEquipAttrComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricEquipAttrStandComputed, arg3 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricEquipAttrComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricEquipAttrComputedLicenses indicates an expected call of MetricEquipAttrComputedLicenses
func (mr *MockLicenseMockRecorder) MetricEquipAttrComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricEquipAttrComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricEquipAttrComputedLicenses), varargs...)
}

// MetricEquipAttrComputedLicensesAgg mocks base method
func (m *MockLicense) MetricEquipAttrComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricEquipAttrStandComputed, arg4 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricEquipAttrComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricEquipAttrComputedLicensesAgg indicates an expected call of MetricEquipAttrComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricEquipAttrComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricEquipAttrComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricEquipAttrComputedLicensesAgg), varargs...)
}

// MetricINMComputedLicenses mocks base method
func (m *MockLicense) MetricINMComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricINMComputed, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricINMComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricINMComputedLicenses indicates an expected call of MetricINMComputedLicenses
func (mr *MockLicenseMockRecorder) MetricINMComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricINMComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricINMComputedLicenses), varargs...)
}

// MetricINMComputedLicensesAgg mocks base method
func (m *MockLicense) MetricINMComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricINMComputed, arg4 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricINMComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricINMComputedLicensesAgg indicates an expected call of MetricINMComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricINMComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricINMComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricINMComputedLicensesAgg), varargs...)
}

// MetricIPSComputedLicenses mocks base method
func (m *MockLicense) MetricIPSComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricIPSComputed, arg3 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricIPSComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricIPSComputedLicenses indicates an expected call of MetricIPSComputedLicenses
func (mr *MockLicenseMockRecorder) MetricIPSComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricIPSComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricIPSComputedLicenses), varargs...)
}

// MetricIPSComputedLicensesAgg mocks base method
func (m *MockLicense) MetricIPSComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricIPSComputed, arg4 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricIPSComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricIPSComputedLicensesAgg indicates an expected call of MetricIPSComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricIPSComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricIPSComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricIPSComputedLicensesAgg), varargs...)
}

// MetricNUPComputedLicenses mocks base method
func (m *MockLicense) MetricNUPComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricNUPComputed, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricNUPComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricNUPComputedLicenses indicates an expected call of MetricNUPComputedLicenses
func (mr *MockLicenseMockRecorder) MetricNUPComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricNUPComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricNUPComputedLicenses), varargs...)
}

// MetricNUPComputedLicensesAgg mocks base method
func (m *MockLicense) MetricNUPComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricNUPComputed, arg4 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricNUPComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricNUPComputedLicensesAgg indicates an expected call of MetricNUPComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricNUPComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricNUPComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricNUPComputedLicensesAgg), varargs...)
}

// MetricOPSComputedLicenses mocks base method
func (m *MockLicense) MetricOPSComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricOPSComputed, arg3 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricOPSComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricOPSComputedLicenses indicates an expected call of MetricOPSComputedLicenses
func (mr *MockLicenseMockRecorder) MetricOPSComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricOPSComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricOPSComputedLicenses), varargs...)
}

// MetricOPSComputedLicensesAgg mocks base method
func (m *MockLicense) MetricOPSComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricOPSComputed, arg4 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricOPSComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricOPSComputedLicensesAgg indicates an expected call of MetricOPSComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricOPSComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricOPSComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricOPSComputedLicensesAgg), varargs...)
}

// MetricOPSComputedLicensesForAppProduct mocks base method
func (m *MockLicense) MetricOPSComputedLicensesForAppProduct(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricOPSComputed, arg4 ...string) (uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricOPSComputedLicensesForAppProduct", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// MetricOPSComputedLicensesForAppProduct indicates an expected call of MetricOPSComputedLicensesForAppProduct
func (mr *MockLicenseMockRecorder) MetricOPSComputedLicensesForAppProduct(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricOPSComputedLicensesForAppProduct", reflect.TypeOf((*MockLicense)(nil).MetricOPSComputedLicensesForAppProduct), varargs...)
}

// MetricSPSComputedLicenses mocks base method
func (m *MockLicense) MetricSPSComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricSPSComputed, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricSPSComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricSPSComputedLicenses indicates an expected call of MetricSPSComputedLicenses
func (mr *MockLicenseMockRecorder) MetricSPSComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricSPSComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricSPSComputedLicenses), varargs...)
}

// MetricSPSComputedLicensesAgg mocks base method
func (m *MockLicense) MetricSPSComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricSPSComputed, arg4 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricSPSComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricSPSComputedLicensesAgg indicates an expected call of MetricSPSComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricSPSComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricSPSComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricSPSComputedLicensesAgg), varargs...)
}

// MetricUCSComputedLicenses mocks base method
func (m *MockLicense) MetricUCSComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricUCSComputed, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricUCSComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricUCSComputedLicenses indicates an expected call of MetricUCSComputedLicenses
func (mr *MockLicenseMockRecorder) MetricUCSComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricUCSComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricUCSComputedLicenses), varargs...)
}

// MetricUCSComputedLicensesAgg mocks base method
func (m *MockLicense) MetricUCSComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricUCSComputed, arg4 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricUCSComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricUCSComputedLicensesAgg indicates an expected call of MetricUCSComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricUCSComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricUCSComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricUCSComputedLicensesAgg), varargs...)
}

// MetricUNSComputedLicenses mocks base method
func (m *MockLicense) MetricUNSComputedLicenses(arg0 context.Context, arg1 []string, arg2 *v1.MetricUNSComputed, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricUNSComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricUNSComputedLicenses indicates an expected call of MetricUNSComputedLicenses
func (mr *MockLicenseMockRecorder) MetricUNSComputedLicenses(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricUNSComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricUNSComputedLicenses), varargs...)
}

// MetricUNSComputedLicensesAgg mocks base method
func (m *MockLicense) MetricUNSComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 *v1.MetricUNSComputed, arg4 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricUNSComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricUNSComputedLicensesAgg indicates an expected call of MetricUNSComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricUNSComputedLicensesAgg(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricUNSComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricUNSComputedLicensesAgg), varargs...)
}

// MetricUserSumComputedLicenses mocks base method
func (m *MockLicense) MetricUserSumComputedLicenses(arg0 context.Context, arg1 []string, arg2 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricUserSumComputedLicenses", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricUserSumComputedLicenses indicates an expected call of MetricUserSumComputedLicenses
func (mr *MockLicenseMockRecorder) MetricUserSumComputedLicenses(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricUserSumComputedLicenses", reflect.TypeOf((*MockLicense)(nil).MetricUserSumComputedLicenses), varargs...)
}

// MetricUserSumComputedLicensesAgg mocks base method
func (m *MockLicense) MetricUserSumComputedLicensesAgg(arg0 context.Context, arg1, arg2 string, arg3 ...string) (uint64, uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "MetricUserSumComputedLicensesAgg", varargs...)
	ret0, _ := ret[0].(uint64)
	ret1, _ := ret[1].(uint64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// MetricUserSumComputedLicensesAgg indicates an expected call of MetricUserSumComputedLicensesAgg
func (mr *MockLicenseMockRecorder) MetricUserSumComputedLicensesAgg(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MetricUserSumComputedLicensesAgg", reflect.TypeOf((*MockLicense)(nil).MetricUserSumComputedLicensesAgg), varargs...)
}

// ParentsHirerachyForEquipment mocks base method
func (m *MockLicense) ParentsHirerachyForEquipment(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 ...string) (*v1.Equipment, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ParentsHirerachyForEquipment", varargs...)
	ret0, _ := ret[0].(*v1.Equipment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParentsHirerachyForEquipment indicates an expected call of ParentsHirerachyForEquipment
func (mr *MockLicenseMockRecorder) ParentsHirerachyForEquipment(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParentsHirerachyForEquipment", reflect.TypeOf((*MockLicense)(nil).ParentsHirerachyForEquipment), varargs...)
}

// ProductAcquiredRights mocks base method
func (m *MockLicense) ProductAcquiredRights(arg0 context.Context, arg1 string, arg2 []*v1.Metric, arg3 bool, arg4 ...string) (string, string, []*v1.ProductAcquiredRight, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductAcquiredRights", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].([]*v1.ProductAcquiredRight)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// ProductAcquiredRights indicates an expected call of ProductAcquiredRights
func (mr *MockLicenseMockRecorder) ProductAcquiredRights(arg0, arg1, arg2, arg3 interface{}, arg4 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductAcquiredRights", reflect.TypeOf((*MockLicense)(nil).ProductAcquiredRights), varargs...)
}

// ProductApplicationEquipments mocks base method
func (m *MockLicense) ProductApplicationEquipments(arg0 context.Context, arg1, arg2 string, arg3 ...string) ([]*v1.Equipment, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductApplicationEquipments", varargs...)
	ret0, _ := ret[0].([]*v1.Equipment)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductApplicationEquipments indicates an expected call of ProductApplicationEquipments
func (mr *MockLicenseMockRecorder) ProductApplicationEquipments(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductApplicationEquipments", reflect.TypeOf((*MockLicense)(nil).ProductApplicationEquipments), varargs...)
}

// ProductExistsForApplication mocks base method
func (m *MockLicense) ProductExistsForApplication(arg0 context.Context, arg1, arg2 string, arg3 ...string) (bool, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductExistsForApplication", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductExistsForApplication indicates an expected call of ProductExistsForApplication
func (mr *MockLicenseMockRecorder) ProductExistsForApplication(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductExistsForApplication", reflect.TypeOf((*MockLicense)(nil).ProductExistsForApplication), varargs...)
}

// ProductIDForSwidtag mocks base method
func (m *MockLicense) ProductIDForSwidtag(arg0 context.Context, arg1 string, arg2 *v1.QueryProducts, arg3 ...string) (string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductIDForSwidtag", varargs...)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductIDForSwidtag indicates an expected call of ProductIDForSwidtag
func (mr *MockLicenseMockRecorder) ProductIDForSwidtag(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductIDForSwidtag", reflect.TypeOf((*MockLicense)(nil).ProductIDForSwidtag), varargs...)
}

// ProductsForEquipmentForMetricAttrCounterStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricAttrCounterStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricACSComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricAttrCounterStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricAttrCounterStandard indicates an expected call of ProductsForEquipmentForMetricAttrCounterStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricAttrCounterStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricAttrCounterStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricAttrCounterStandard), varargs...)
}

// ProductsForEquipmentForMetricAttrSumStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricAttrSumStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricAttrSumStandComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricAttrSumStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricAttrSumStandard indicates an expected call of ProductsForEquipmentForMetricAttrSumStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricAttrSumStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricAttrSumStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricAttrSumStandard), varargs...)
}

// ProductsForEquipmentForMetricEquipAttrStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricEquipAttrStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricEquipAttrStandComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricEquipAttrStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricEquipAttrStandard indicates an expected call of ProductsForEquipmentForMetricEquipAttrStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricEquipAttrStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricEquipAttrStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricEquipAttrStandard), varargs...)
}

// ProductsForEquipmentForMetricIPSStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricIPSStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricIPSComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricIPSStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricIPSStandard indicates an expected call of ProductsForEquipmentForMetricIPSStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricIPSStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricIPSStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricIPSStandard), varargs...)
}

// ProductsForEquipmentForMetricOracleNUPStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricOracleNUPStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricNUPComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricOracleNUPStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricOracleNUPStandard indicates an expected call of ProductsForEquipmentForMetricOracleNUPStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricOracleNUPStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricOracleNUPStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricOracleNUPStandard), varargs...)
}

// ProductsForEquipmentForMetricOracleProcessorStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricOracleProcessorStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricOPSComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricOracleProcessorStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricOracleProcessorStandard indicates an expected call of ProductsForEquipmentForMetricOracleProcessorStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricOracleProcessorStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricOracleProcessorStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricOracleProcessorStandard), varargs...)
}

// ProductsForEquipmentForMetricSAGStandard mocks base method
func (m *MockLicense) ProductsForEquipmentForMetricSAGStandard(arg0 context.Context, arg1, arg2 string, arg3 byte, arg4 *v1.MetricSPSComputed, arg5 ...string) ([]*v1.ProductData, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ProductsForEquipmentForMetricSAGStandard", varargs...)
	ret0, _ := ret[0].([]*v1.ProductData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ProductsForEquipmentForMetricSAGStandard indicates an expected call of ProductsForEquipmentForMetricSAGStandard
func (mr *MockLicenseMockRecorder) ProductsForEquipmentForMetricSAGStandard(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProductsForEquipmentForMetricSAGStandard", reflect.TypeOf((*MockLicense)(nil).ProductsForEquipmentForMetricSAGStandard), varargs...)
}

// UsersForEquipmentForMetricOracleNUP mocks base method
func (m *MockLicense) UsersForEquipmentForMetricOracleNUP(arg0 context.Context, arg1, arg2, arg3 string, arg4 byte, arg5 *v1.MetricNUPComputed, arg6 ...string) ([]*v1.User, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2, arg3, arg4, arg5}
	for _, a := range arg6 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UsersForEquipmentForMetricOracleNUP", varargs...)
	ret0, _ := ret[0].([]*v1.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UsersForEquipmentForMetricOracleNUP indicates an expected call of UsersForEquipmentForMetricOracleNUP
func (mr *MockLicenseMockRecorder) UsersForEquipmentForMetricOracleNUP(arg0, arg1, arg2, arg3, arg4, arg5 interface{}, arg6 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4, arg5}, arg6...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UsersForEquipmentForMetricOracleNUP", reflect.TypeOf((*MockLicense)(nil).UsersForEquipmentForMetricOracleNUP), varargs...)
}
