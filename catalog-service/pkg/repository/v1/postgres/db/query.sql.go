// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createUploadFileLog = `-- name: CreateUploadFileLog :exec
insert into upload_file_logs (file_name,message)values($1,$2)
`

type CreateUploadFileLogParams struct {
	FileName string         `json:"file_name"`
	Message  sql.NullString `json:"message"`
}

func (q *Queries) CreateUploadFileLog(ctx context.Context, arg CreateUploadFileLogParams) error {
	_, err := q.db.ExecContext(ctx, createUploadFileLog, arg.FileName, arg.Message)
	return err
}

const deleteEditorCatalog = `-- name: DeleteEditorCatalog :exec
DELETE FROM editor_catalog
WHERE id = $1
`

func (q *Queries) DeleteEditorCatalog(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteEditorCatalog, id)
	return err
}

const deleteProductCatalog = `-- name: DeleteProductCatalog :exec
DELETE FROM product_catalog
WHERE id = $1
`

func (q *Queries) DeleteProductCatalog(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProductCatalog, id)
	return err
}

const deleteVersionCatalog = `-- name: DeleteVersionCatalog :exec
Delete from version_catalog 
WHERE id = $1
`

func (q *Queries) DeleteVersionCatalog(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteVersionCatalog, id)
	return err
}

const getEditorCatalog = `-- name: GetEditorCatalog :one
SELECT id, name, general_information, partner_managers, audits, vendors, created_on, updated_on, source from editor_catalog WHERE id = $1
`

func (q *Queries) GetEditorCatalog(ctx context.Context, id string) (EditorCatalog, error) {
	row := q.db.QueryRowContext(ctx, getEditorCatalog, id)
	var i EditorCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.GeneralInformation,
		&i.PartnerManagers,
		&i.Audits,
		&i.Vendors,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Source,
	)
	return i, err
}

const getEditorCatalogByName = `-- name: GetEditorCatalogByName :one
SELECT id, name, general_information, partner_managers, audits, vendors, created_on, updated_on, source from editor_catalog WHERE name = $1
`

func (q *Queries) GetEditorCatalogByName(ctx context.Context, name string) (EditorCatalog, error) {
	row := q.db.QueryRowContext(ctx, getEditorCatalogByName, name)
	var i EditorCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.GeneralInformation,
		&i.PartnerManagers,
		&i.Audits,
		&i.Vendors,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Source,
	)
	return i, err
}

const getEditorCatalogName = `-- name: GetEditorCatalogName :one
SELECT id,name from editor_catalog WHERE id = $1
`

type GetEditorCatalogNameRow struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetEditorCatalogName(ctx context.Context, id string) (GetEditorCatalogNameRow, error) {
	row := q.db.QueryRowContext(ctx, getEditorCatalogName, id)
	var i GetEditorCatalogNameRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getProductCatalogByEditorId = `-- name: GetProductCatalogByEditorId :one
SELECT id, name, editorid, genearl_information, contract_tips, support_vendors, metrics, is_opensource, licences_opensource, is_closesource, licenses_closesource, location, created_on, updated_on, recommendation, useful_links, swid_tag_product, source, editor_name, opensource_type from product_catalog 
WHERE editorID = $1 AND name = $2
`

type GetProductCatalogByEditorIdParams struct {
	Editorid string `json:"editorid"`
	Name     string `json:"name"`
}

func (q *Queries) GetProductCatalogByEditorId(ctx context.Context, arg GetProductCatalogByEditorIdParams) (ProductCatalog, error) {
	row := q.db.QueryRowContext(ctx, getProductCatalogByEditorId, arg.Editorid, arg.Name)
	var i ProductCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Editorid,
		&i.GenearlInformation,
		&i.ContractTips,
		&i.SupportVendors,
		&i.Metrics,
		&i.IsOpensource,
		&i.LicencesOpensource,
		&i.IsClosesource,
		&i.LicensesClosesource,
		&i.Location,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Recommendation,
		&i.UsefulLinks,
		&i.SwidTagProduct,
		&i.Source,
		&i.EditorName,
		&i.OpensourceType,
	)
	return i, err
}

const getProductCatalogByPrductID = `-- name: GetProductCatalogByPrductID :one
SELECT id, name, editorid, genearl_information, contract_tips, support_vendors, metrics, is_opensource, licences_opensource, is_closesource, licenses_closesource, location, created_on, updated_on, recommendation, useful_links, swid_tag_product, source, editor_name, opensource_type from product_catalog 
WHERE id = $1
`

func (q *Queries) GetProductCatalogByPrductID(ctx context.Context, id string) (ProductCatalog, error) {
	row := q.db.QueryRowContext(ctx, getProductCatalogByPrductID, id)
	var i ProductCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Editorid,
		&i.GenearlInformation,
		&i.ContractTips,
		&i.SupportVendors,
		&i.Metrics,
		&i.IsOpensource,
		&i.LicencesOpensource,
		&i.IsClosesource,
		&i.LicensesClosesource,
		&i.Location,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Recommendation,
		&i.UsefulLinks,
		&i.SwidTagProduct,
		&i.Source,
		&i.EditorName,
		&i.OpensourceType,
	)
	return i, err
}

const getProductCatalogBySwidTag = `-- name: GetProductCatalogBySwidTag :one
SELECT id, name, editorid, genearl_information, contract_tips, support_vendors, metrics, is_opensource, licences_opensource, is_closesource, licenses_closesource, location, created_on, updated_on, recommendation, useful_links, swid_tag_product, source, editor_name, opensource_type from product_catalog 
WHERE swid_tag_product = $1
`

func (q *Queries) GetProductCatalogBySwidTag(ctx context.Context, swidTagProduct sql.NullString) (ProductCatalog, error) {
	row := q.db.QueryRowContext(ctx, getProductCatalogBySwidTag, swidTagProduct)
	var i ProductCatalog
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Editorid,
		&i.GenearlInformation,
		&i.ContractTips,
		&i.SupportVendors,
		&i.Metrics,
		&i.IsOpensource,
		&i.LicencesOpensource,
		&i.IsClosesource,
		&i.LicensesClosesource,
		&i.Location,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.Recommendation,
		&i.UsefulLinks,
		&i.SwidTagProduct,
		&i.Source,
		&i.EditorName,
		&i.OpensourceType,
	)
	return i, err
}

const getProductsByEditorID = `-- name: GetProductsByEditorID :many
SELECT id, name, editorid, genearl_information, contract_tips, support_vendors, metrics, is_opensource, licences_opensource, is_closesource, licenses_closesource, location, created_on, updated_on, recommendation, useful_links, swid_tag_product, source, editor_name, opensource_type from product_catalog 
WHERE editorID = $1
`

func (q *Queries) GetProductsByEditorID(ctx context.Context, editorID string) ([]ProductCatalog, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByEditorID, editorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCatalog
	for rows.Next() {
		var i ProductCatalog
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Editorid,
			&i.GenearlInformation,
			&i.ContractTips,
			&i.SupportVendors,
			&i.Metrics,
			&i.IsOpensource,
			&i.LicencesOpensource,
			&i.IsClosesource,
			&i.LicensesClosesource,
			&i.Location,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.Recommendation,
			&i.UsefulLinks,
			&i.SwidTagProduct,
			&i.Source,
			&i.EditorName,
			&i.OpensourceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsNamesByEditorID = `-- name: GetProductsNamesByEditorID :many
SELECT id,name from product_catalog 
WHERE editorID = $1
`

type GetProductsNamesByEditorIDRow struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) GetProductsNamesByEditorID(ctx context.Context, editorID string) ([]GetProductsNamesByEditorIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsNamesByEditorID, editorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsNamesByEditorIDRow
	for rows.Next() {
		var i GetProductsNamesByEditorIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUploadFileLogs = `-- name: GetUploadFileLogs :many
select upload_id, file_name, uploaded_on, message from upload_file_logs order by upload_id desc limit 5
`

func (q *Queries) GetUploadFileLogs(ctx context.Context) ([]UploadFileLog, error) {
	rows, err := q.db.QueryContext(ctx, getUploadFileLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UploadFileLog
	for rows.Next() {
		var i UploadFileLog
		if err := rows.Scan(
			&i.UploadID,
			&i.FileName,
			&i.UploadedOn,
			&i.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionCatalogByPrductID = `-- name: GetVersionCatalogByPrductID :many
SELECT id, swid_tag_system, p_id, name, end_of_life, end_of_support, recommendation, swid_tag_version, source from version_catalog 
WHERE p_id = $1
`

func (q *Queries) GetVersionCatalogByPrductID(ctx context.Context, id string) ([]VersionCatalog, error) {
	rows, err := q.db.QueryContext(ctx, getVersionCatalogByPrductID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VersionCatalog
	for rows.Next() {
		var i VersionCatalog
		if err := rows.Scan(
			&i.ID,
			&i.SwidTagSystem,
			&i.PID,
			&i.Name,
			&i.EndOfLife,
			&i.EndOfSupport,
			&i.Recommendation,
			&i.SwidTagVersion,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVersionCatalogBySwidTag = `-- name: GetVersionCatalogBySwidTag :one
SELECT id, swid_tag_system, p_id, name, end_of_life, end_of_support, recommendation, swid_tag_version, source from version_catalog 
WHERE swid_tag_version = $1
`

func (q *Queries) GetVersionCatalogBySwidTag(ctx context.Context, swidTagVersion sql.NullString) (VersionCatalog, error) {
	row := q.db.QueryRowContext(ctx, getVersionCatalogBySwidTag, swidTagVersion)
	var i VersionCatalog
	err := row.Scan(
		&i.ID,
		&i.SwidTagSystem,
		&i.PID,
		&i.Name,
		&i.EndOfLife,
		&i.EndOfSupport,
		&i.Recommendation,
		&i.SwidTagVersion,
		&i.Source,
	)
	return i, err
}

const insertEditorCatalog = `-- name: InsertEditorCatalog :exec
INSERT INTO editor_catalog (id,name, general_information,partner_managers,audits,vendors,created_on,updated_on)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
`

type InsertEditorCatalogParams struct {
	ID                 string          `json:"id"`
	Name               string          `json:"name"`
	GeneralInformation sql.NullString  `json:"general_information"`
	PartnerManagers    json.RawMessage `json:"partner_managers"`
	Audits             json.RawMessage `json:"audits"`
	Vendors            json.RawMessage `json:"vendors"`
	CreatedOn          time.Time       `json:"created_on"`
	UpdatedOn          time.Time       `json:"updated_on"`
}

func (q *Queries) InsertEditorCatalog(ctx context.Context, arg InsertEditorCatalogParams) error {
	_, err := q.db.ExecContext(ctx, insertEditorCatalog,
		arg.ID,
		arg.Name,
		arg.GeneralInformation,
		arg.PartnerManagers,
		arg.Audits,
		arg.Vendors,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	return err
}

const insertProductCatalog = `-- name: InsertProductCatalog :exec
INSERT INTO product_catalog (id,name,editorID, genearl_information,contract_tips,support_vendors,metrics,is_opensource,licences_opensource,
is_closesource,licenses_closesource,location,created_on,updated_on,recommendation,useful_links,swid_tag_product,editor_name,opensource_type)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19)
`

type InsertProductCatalogParams struct {
	ID                  string          `json:"id"`
	Name                string          `json:"name"`
	Editorid            string          `json:"editorid"`
	GenearlInformation  sql.NullString  `json:"genearl_information"`
	ContractTips        sql.NullString  `json:"contract_tips"`
	SupportVendors      json.RawMessage `json:"support_vendors"`
	Metrics             json.RawMessage `json:"metrics"`
	IsOpensource        sql.NullBool    `json:"is_opensource"`
	LicencesOpensource  sql.NullString  `json:"licences_opensource"`
	IsClosesource       sql.NullBool    `json:"is_closesource"`
	LicensesClosesource json.RawMessage `json:"licenses_closesource"`
	Location            LocationType    `json:"location"`
	CreatedOn           time.Time       `json:"created_on"`
	UpdatedOn           time.Time       `json:"updated_on"`
	Recommendation      sql.NullString  `json:"recommendation"`
	UsefulLinks         json.RawMessage `json:"useful_links"`
	SwidTagProduct      sql.NullString  `json:"swid_tag_product"`
	EditorName          string          `json:"editor_name"`
	OpensourceType      OpensourceType  `json:"opensource_type"`
}

func (q *Queries) InsertProductCatalog(ctx context.Context, arg InsertProductCatalogParams) error {
	_, err := q.db.ExecContext(ctx, insertProductCatalog,
		arg.ID,
		arg.Name,
		arg.Editorid,
		arg.GenearlInformation,
		arg.ContractTips,
		arg.SupportVendors,
		arg.Metrics,
		arg.IsOpensource,
		arg.LicencesOpensource,
		arg.IsClosesource,
		arg.LicensesClosesource,
		arg.Location,
		arg.CreatedOn,
		arg.UpdatedOn,
		arg.Recommendation,
		arg.UsefulLinks,
		arg.SwidTagProduct,
		arg.EditorName,
		arg.OpensourceType,
	)
	return err
}

const insertVersionCatalog = `-- name: InsertVersionCatalog :exec
INSERT INTO version_catalog (id,p_id,name,end_of_life,end_of_support,recommendation,swid_tag_version,swid_tag_system)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
`

type InsertVersionCatalogParams struct {
	ID             string         `json:"id"`
	PID            string         `json:"p_id"`
	Name           string         `json:"name"`
	EndOfLife      sql.NullTime   `json:"end_of_life"`
	EndOfSupport   sql.NullTime   `json:"end_of_support"`
	Recommendation sql.NullString `json:"recommendation"`
	SwidTagVersion sql.NullString `json:"swid_tag_version"`
	SwidTagSystem  string         `json:"swid_tag_system"`
}

func (q *Queries) InsertVersionCatalog(ctx context.Context, arg InsertVersionCatalogParams) error {
	_, err := q.db.ExecContext(ctx, insertVersionCatalog,
		arg.ID,
		arg.PID,
		arg.Name,
		arg.EndOfLife,
		arg.EndOfSupport,
		arg.Recommendation,
		arg.SwidTagVersion,
		arg.SwidTagSystem,
	)
	return err
}

const updateEditorCatalog = `-- name: UpdateEditorCatalog :exec
UPDATE editor_catalog SET general_information=$1, partner_managers=$2, audits=$3, vendors=$4, updated_on=$5, name=$7 where id=$6
`

type UpdateEditorCatalogParams struct {
	GeneralInformation sql.NullString  `json:"general_information"`
	PartnerManagers    json.RawMessage `json:"partner_managers"`
	Audits             json.RawMessage `json:"audits"`
	Vendors            json.RawMessage `json:"vendors"`
	UpdatedOn          time.Time       `json:"updated_on"`
	ID                 string          `json:"id"`
	Name               string          `json:"name"`
}

func (q *Queries) UpdateEditorCatalog(ctx context.Context, arg UpdateEditorCatalogParams) error {
	_, err := q.db.ExecContext(ctx, updateEditorCatalog,
		arg.GeneralInformation,
		arg.PartnerManagers,
		arg.Audits,
		arg.Vendors,
		arg.UpdatedOn,
		arg.ID,
		arg.Name,
	)
	return err
}

const updateEditorNameForProductCatalog = `-- name: UpdateEditorNameForProductCatalog :exec
update product_catalog set editor_name = $1 where editorid = $2
`

type UpdateEditorNameForProductCatalogParams struct {
	EditorName string `json:"editor_name"`
	Editorid   string `json:"editorid"`
}

func (q *Queries) UpdateEditorNameForProductCatalog(ctx context.Context, arg UpdateEditorNameForProductCatalogParams) error {
	_, err := q.db.ExecContext(ctx, updateEditorNameForProductCatalog, arg.EditorName, arg.Editorid)
	return err
}

const updateProductCatalog = `-- name: UpdateProductCatalog :exec
UPDATE product_catalog SET 
name=$1,editorID=$2, genearl_information=$3,contract_tips=$4,support_vendors=$5,metrics=$6,is_opensource=$7,licences_opensource=$8,
is_closesource=$9,licenses_closesource=$10,location=$11,updated_on=$12,recommendation=$13,useful_links=$14,swid_tag_product=$15,editor_name=$16,opensource_type=$17
where id =$18
`

type UpdateProductCatalogParams struct {
	Name                string          `json:"name"`
	Editorid            string          `json:"editorid"`
	GenearlInformation  sql.NullString  `json:"genearl_information"`
	ContractTips        sql.NullString  `json:"contract_tips"`
	SupportVendors      json.RawMessage `json:"support_vendors"`
	Metrics             json.RawMessage `json:"metrics"`
	IsOpensource        sql.NullBool    `json:"is_opensource"`
	LicencesOpensource  sql.NullString  `json:"licences_opensource"`
	IsClosesource       sql.NullBool    `json:"is_closesource"`
	LicensesClosesource json.RawMessage `json:"licenses_closesource"`
	Location            LocationType    `json:"location"`
	UpdatedOn           time.Time       `json:"updated_on"`
	Recommendation      sql.NullString  `json:"recommendation"`
	UsefulLinks         json.RawMessage `json:"useful_links"`
	SwidTagProduct      sql.NullString  `json:"swid_tag_product"`
	EditorName          string          `json:"editor_name"`
	OpensourceType      OpensourceType  `json:"opensource_type"`
	ID                  string          `json:"id"`
}

func (q *Queries) UpdateProductCatalog(ctx context.Context, arg UpdateProductCatalogParams) error {
	_, err := q.db.ExecContext(ctx, updateProductCatalog,
		arg.Name,
		arg.Editorid,
		arg.GenearlInformation,
		arg.ContractTips,
		arg.SupportVendors,
		arg.Metrics,
		arg.IsOpensource,
		arg.LicencesOpensource,
		arg.IsClosesource,
		arg.LicensesClosesource,
		arg.Location,
		arg.UpdatedOn,
		arg.Recommendation,
		arg.UsefulLinks,
		arg.SwidTagProduct,
		arg.EditorName,
		arg.OpensourceType,
		arg.ID,
	)
	return err
}

const updateProductEditor = `-- name: UpdateProductEditor :exec
UPDATE product_catalog SET 
updated_on=$1,editor_name=$2
where id =$3
`

type UpdateProductEditorParams struct {
	UpdatedOn  time.Time `json:"updated_on"`
	EditorName string    `json:"editor_name"`
	ID         string    `json:"id"`
}

func (q *Queries) UpdateProductEditor(ctx context.Context, arg UpdateProductEditorParams) error {
	_, err := q.db.ExecContext(ctx, updateProductEditor, arg.UpdatedOn, arg.EditorName, arg.ID)
	return err
}

const updateVersionCatalog = `-- name: UpdateVersionCatalog :exec
UPDATE version_catalog SET 
name=$1,end_of_life=$2, end_of_support=$3,recommendation=$4,swid_tag_version=$5,swid_tag_system=$6
where id = $7
`

type UpdateVersionCatalogParams struct {
	Name           string         `json:"name"`
	EndOfLife      sql.NullTime   `json:"end_of_life"`
	EndOfSupport   sql.NullTime   `json:"end_of_support"`
	Recommendation sql.NullString `json:"recommendation"`
	SwidTagVersion sql.NullString `json:"swid_tag_version"`
	SwidTagSystem  string         `json:"swid_tag_system"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateVersionCatalog(ctx context.Context, arg UpdateVersionCatalogParams) error {
	_, err := q.db.ExecContext(ctx, updateVersionCatalog,
		arg.Name,
		arg.EndOfLife,
		arg.EndOfSupport,
		arg.Recommendation,
		arg.SwidTagVersion,
		arg.SwidTagSystem,
		arg.ID,
	)
	return err
}

const updateVersionForEditor = `-- name: UpdateVersionForEditor :exec
UPDATE version_catalog SET swid_tag_system=$1
where id =$2
`

type UpdateVersionForEditorParams struct {
	SwidTagSystem string `json:"swid_tag_system"`
	ID            string `json:"id"`
}

func (q *Queries) UpdateVersionForEditor(ctx context.Context, arg UpdateVersionForEditorParams) error {
	_, err := q.db.ExecContext(ctx, updateVersionForEditor, arg.SwidTagSystem, arg.ID)
	return err
}

const updateVersionsSysSwidatagsForEditor = `-- name: UpdateVersionsSysSwidatagsForEditor :exec
update version_catalog set swid_tag_system = case 
when (name = '')
then
REPLACE(CONCAT((
    select
        name
    from
        product_catalog
    where
        id = p_id
),'_',(
    select
        name
    from
        editor_catalog
    where
        editor_catalog.id = $1
)),' ','_')
else
REPLACE(CONCAT((
    select
        name
    from
        product_catalog
    where
        id = p_id
),
'_',
(
    select
        name
    from
        editor_catalog
    where
        editor_catalog.id = $1
), '_',name),' ','_') 
end
where p_id in (select id from product_catalog where product_catalog.editorID = $1)
`

func (q *Queries) UpdateVersionsSysSwidatagsForEditor(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateVersionsSysSwidatagsForEditor, id)
	return err
}

const upsertEditorCatalog = `-- name: UpsertEditorCatalog :one
INSERT INTO editor_catalog (id,name,created_on,updated_on) values ($1,$2,$3,$4) ON CONFLICT (LOWER(name)) DO Update SET updated_on =$4 returning id,name
`

type UpsertEditorCatalogParams struct {
	ID        string    `json:"id"`
	Name      string    `json:"name"`
	CreatedOn time.Time `json:"created_on"`
	UpdatedOn time.Time `json:"updated_on"`
}

type UpsertEditorCatalogRow struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpsertEditorCatalog(ctx context.Context, arg UpsertEditorCatalogParams) (UpsertEditorCatalogRow, error) {
	row := q.db.QueryRowContext(ctx, upsertEditorCatalog,
		arg.ID,
		arg.Name,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	var i UpsertEditorCatalogRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const upsertProductCatalog = `-- name: UpsertProductCatalog :one
INSERT INTO product_catalog (id,name,editorID,editor_name,is_closesource,is_opensource,genearl_information,location,created_on,updated_on,opensource_type) values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11) on CONFLICT(LOWER(name),LOWER(editor_name)) Do Update SET updated_on =$9 returning id
`

type UpsertProductCatalogParams struct {
	ID                 string         `json:"id"`
	Name               string         `json:"name"`
	Editorid           string         `json:"editorid"`
	EditorName         string         `json:"editor_name"`
	IsClosesource      sql.NullBool   `json:"is_closesource"`
	IsOpensource       sql.NullBool   `json:"is_opensource"`
	GenearlInformation sql.NullString `json:"genearl_information"`
	Location           LocationType   `json:"location"`
	CreatedOn          time.Time      `json:"created_on"`
	UpdatedOn          time.Time      `json:"updated_on"`
	OpensourceType     OpensourceType `json:"opensource_type"`
}

func (q *Queries) UpsertProductCatalog(ctx context.Context, arg UpsertProductCatalogParams) (string, error) {
	row := q.db.QueryRowContext(ctx, upsertProductCatalog,
		arg.ID,
		arg.Name,
		arg.Editorid,
		arg.EditorName,
		arg.IsClosesource,
		arg.IsOpensource,
		arg.GenearlInformation,
		arg.Location,
		arg.CreatedOn,
		arg.UpdatedOn,
		arg.OpensourceType,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const upsertVersionCatalog = `-- name: UpsertVersionCatalog :one
INSERT INTO version_catalog (id,p_id,name,end_of_life,end_of_support,swid_tag_system)
VALUES ($1,$2,$3,$4,$5,$6) on CONFLICT(LOWER(name),p_id) Do Update SET end_of_life =$4,end_of_support=$5 returning id
`

type UpsertVersionCatalogParams struct {
	ID            string       `json:"id"`
	PID           string       `json:"p_id"`
	Name          string       `json:"name"`
	EndOfLife     sql.NullTime `json:"end_of_life"`
	EndOfSupport  sql.NullTime `json:"end_of_support"`
	SwidTagSystem string       `json:"swid_tag_system"`
}

func (q *Queries) UpsertVersionCatalog(ctx context.Context, arg UpsertVersionCatalogParams) (string, error) {
	row := q.db.QueryRowContext(ctx, upsertVersionCatalog,
		arg.ID,
		arg.PID,
		arg.Name,
		arg.EndOfLife,
		arg.EndOfSupport,
		arg.SwidTagSystem,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}
