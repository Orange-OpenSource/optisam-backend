// Copyright (C) 2019 Orange
// 
// This software is distributed under the terms and conditions of the 'Apache License 2.0'
// license which can be found in the file 'License.txt' in this package distribution 
// or at 'http://www.apache.org/licenses/LICENSE-2.0'. 

// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const deleteProductAggregation = `-- name: DeleteProductAggregation :exec
Update products set aggregation_id = $1, aggregation_name = $2 WHERE
aggregation_id = $3
`

type DeleteProductAggregationParams struct {
	AggregationID   int32  `json:"aggregation_id"`
	AggregationName string `json:"aggregation_name"`
	AggregationID_2 int32  `json:"aggregation_id_2"`
}

func (q *Queries) DeleteProductAggregation(ctx context.Context, arg DeleteProductAggregationParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductAggregation, arg.AggregationID, arg.AggregationName, arg.AggregationID_2)
	return err
}

const deleteProductApplications = `-- name: DeleteProductApplications :exec
DELETE FROM products_applications
WHERE swidtag = $1 and application_id = ANY($2::TEXT[])
`

type DeleteProductApplicationsParams struct {
	ProductID     string   `json:"product_id"`
	ApplicationID []string `json:"application_id"`
}

func (q *Queries) DeleteProductApplications(ctx context.Context, arg DeleteProductApplicationsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductApplications, arg.ProductID, pq.Array(arg.ApplicationID))
	return err
}

const deleteProductEquipments = `-- name: DeleteProductEquipments :exec
DELETE FROM products_equipments
WHERE swidtag = $1 and equipment_id = ANY($2::TEXT[])
`

type DeleteProductEquipmentsParams struct {
	ProductID   string   `json:"product_id"`
	EquipmentID []string `json:"equipment_id"`
}

func (q *Queries) DeleteProductEquipments(ctx context.Context, arg DeleteProductEquipmentsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductEquipments, arg.ProductID, pq.Array(arg.EquipmentID))
	return err
}

const equipmentProducts = `-- name: EquipmentProducts :many
SELECT swidtag, equipment_id, num_of_users from products_equipments
WHERE
equipment_id = $1
`

func (q *Queries) EquipmentProducts(ctx context.Context, equipmentID string) ([]ProductsEquipment, error) {
	rows, err := q.db.QueryContext(ctx, equipmentProducts, equipmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsEquipment
	for rows.Next() {
		var i ProductsEquipment
		if err := rows.Scan(&i.Swidtag, &i.EquipmentID, &i.NumOfUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAggregation = `-- name: GetProductAggregation :many
SELECT swidtag
FROM products
WHERE aggregation_id = $1 and aggregation_name = $2
`

type GetProductAggregationParams struct {
	AggregationID   int32  `json:"aggregation_id"`
	AggregationName string `json:"aggregation_name"`
}

func (q *Queries) GetProductAggregation(ctx context.Context, arg GetProductAggregationParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getProductAggregation, arg.AggregationID, arg.AggregationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var swidtag string
		if err := rows.Scan(&swidtag); err != nil {
			return nil, err
		}
		items = append(items, swidtag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductInformation = `-- name: GetProductInformation :one
SELECT p.swidtag,p.product_editor,p.product_edition,p.product_version
FROM products p 
WHERE p.swidtag = $1
AND p.scope = ANY($2::TEXT[])
`

type GetProductInformationParams struct {
	Swidtag string   `json:"swidtag"`
	Scope   []string `json:"scope"`
}

type GetProductInformationRow struct {
	Swidtag        string `json:"swidtag"`
	ProductEditor  string `json:"product_editor"`
	ProductEdition string `json:"product_edition"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductInformation(ctx context.Context, arg GetProductInformationParams) (GetProductInformationRow, error) {
	row := q.db.QueryRowContext(ctx, getProductInformation, arg.Swidtag, pq.Array(arg.Scope))
	var i GetProductInformationRow
	err := row.Scan(
		&i.Swidtag,
		&i.ProductEditor,
		&i.ProductEdition,
		&i.ProductVersion,
	)
	return i, err
}

const getProductOptions = `-- name: GetProductOptions :many
SELECT p.swidtag,p.product_name,p.product_edition,p.product_editor,p.product_version
FROM products p 
WHERE p.option_of = $1
AND p.scope = ANY($2::TEXT[])
`

type GetProductOptionsParams struct {
	Swidtag string   `json:"swidtag"`
	Scope   []string `json:"scope"`
}

type GetProductOptionsRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEdition string `json:"product_edition"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductOptions(ctx context.Context, arg GetProductOptionsParams) ([]GetProductOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductOptions, arg.Swidtag, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductOptionsRow
	for rows.Next() {
		var i GetProductOptionsRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEdition,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByEditor = `-- name: GetProductsByEditor :many
SELECT swidtag, product_name
FROM products
WHERE product_editor = $1 and scope = ANY($2::TEXT[])
`

type GetProductsByEditorParams struct {
	ProductEditor string   `json:"product_editor"`
	Scopes        []string `json:"scopes"`
}

type GetProductsByEditorRow struct {
	Swidtag     string `json:"swidtag"`
	ProductName string `json:"product_name"`
}

func (q *Queries) GetProductsByEditor(ctx context.Context, arg GetProductsByEditorParams) ([]GetProductsByEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByEditor, arg.ProductEditor, pq.Array(arg.Scopes))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByEditorRow
	for rows.Next() {
		var i GetProductsByEditorRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregationProductsView = `-- name: ListAggregationProductsView :many
SELECT p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition ,COUNT(distinct pa.application_id)::INTEGER as num_of_applications,COUNT(distinct pe.equipment_id)::INTEGER as num_of_equipments, sum(cost)::FLOAT as cost 
FROM products p 
LEFT JOIN products_applications pa
ON p.swidtag = pa.swidtag
LEFT JOIN products_equipments pe
ON p.swidtag = pe.swidtag
WHERE
  p.aggregation_id = $1
  AND p.scope = ANY($2::TEXT[])
GROUP BY p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition
`

type ListAggregationProductsViewParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

type ListAggregationProductsViewRow struct {
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListAggregationProductsView(ctx context.Context, arg ListAggregationProductsViewParams) ([]ListAggregationProductsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregationProductsView, arg.AggregationID, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationProductsViewRow
	for rows.Next() {
		var i ListAggregationProductsViewRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregationsView = `-- name: ListAggregationsView :many
SELECT count(*) OVER() AS totalRecords,p.aggregation_id,p.aggregation_name,p.product_editor,array_agg(distinct p.swidtag)::TEXT[] as swidtags, COALESCE(SUM(pa.num_of_applications),0)::INTEGER as num_of_applications , COALESCE(SUM(pe.num_of_equipments),0)::INTEGER as num_of_equipments , sum(cost)::INTEGER as total_cost  
FROM products p 
LEFT JOIN
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications  GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments  GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
WHERE
  p.aggregation_id <> 0
  AND p.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(p.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(p.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(p.aggregation_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(p.aggregation_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(p.product_editor) = lower($9) ELSE TRUE END)
  GROUP BY p.aggregation_id, p.aggregation_name, p.product_editor
  ORDER BY
  CASE WHEN $11::bool THEN p.aggregation_name END asc,
  CASE WHEN $12::bool THEN p.aggregation_name END desc,
  CASE WHEN $13::bool THEN p.product_editor END asc,
  CASE WHEN $14::bool THEN p.product_editor END desc,
  CASE WHEN $15::bool THEN 5 END asc,
  CASE WHEN $16::bool THEN 5 END desc,
  CASE WHEN $17::bool THEN 6 END asc,
  CASE WHEN $18::bool THEN 6 END desc,
  CASE WHEN $19::bool THEN 7 END asc,
  CASE WHEN $20::bool THEN 7 END desc
  LIMIT $22 OFFSET $21
`

type ListAggregationsViewParams struct {
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkAggregationName     bool     `json:"lk_aggregation_name"`
	AggregationName       string   `json:"aggregation_name"`
	IsAggregationName     bool     `json:"is_aggregation_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	AggregationNameAsc    bool     `json:"aggregation_name_asc"`
	AggregationNameDesc   bool     `json:"aggregation_name_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListAggregationsViewRow struct {
	Totalrecords      int64    `json:"totalrecords"`
	AggregationID     int32    `json:"aggregation_id"`
	AggregationName   string   `json:"aggregation_name"`
	ProductEditor     string   `json:"product_editor"`
	Swidtags          []string `json:"swidtags"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	TotalCost         int32    `json:"total_cost"`
}

func (q *Queries) ListAggregationsView(ctx context.Context, arg ListAggregationsViewParams) ([]ListAggregationsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregationsView,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationsViewRow
	for rows.Next() {
		var i ListAggregationsViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.AggregationID,
			&i.AggregationName,
			&i.ProductEditor,
			pq.Array(&i.Swidtags),
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditors = `-- name: ListEditors :many
SELECT DISTINCT ON (p.product_editor) p.product_editor 
FROM products p 
WHERE p.scope = ANY($1::TEXT[])
`

func (q *Queries) ListEditors(ctx context.Context, scope []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEditors, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsView = `-- name: ListProductsView :many
SELECT count(*) OVER() AS totalRecords,p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications , COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments , sum(cost)::FLOAT as cost 
FROM products p 
LEFT JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
WHERE
  p.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(p.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(p.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(p.product_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(p.product_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(p.product_editor) = lower($9) ELSE TRUE END)
  GROUP BY p.swidtag,pa.num_of_applications, pe.num_of_equipments
  ORDER BY
  CASE WHEN $11::bool THEN p.swidtag END asc,
  CASE WHEN $12::bool THEN p.swidtag END desc,
  CASE WHEN $13::bool THEN p.product_name END asc,
  CASE WHEN $14::bool THEN p.product_name END desc,
  CASE WHEN $15::bool THEN p.product_edition END asc,
  CASE WHEN $16::bool THEN p.product_edition END desc,
  CASE WHEN $17::bool THEN p.product_version END asc,
  CASE WHEN $18::bool THEN p.product_version END desc,
  CASE WHEN $19::bool THEN 4 END asc,
  CASE WHEN $20::bool THEN 4 END desc,
  CASE WHEN $21::bool THEN 5 END asc,
  CASE WHEN $22::bool THEN 5 END desc,
  CASE WHEN $23::bool THEN 6 END asc,
  CASE WHEN $24::bool THEN 6 END desc,
  CASE WHEN $25::bool THEN 7 END asc,
  CASE WHEN $26::bool THEN 7 END desc
  LIMIT $28 OFFSET $27
`

type ListProductsViewParams struct {
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRow struct {
	Totalrecords      int64   `json:"totalrecords"`
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListProductsView(ctx context.Context, arg ListProductsViewParams) ([]ListProductsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsView,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRow
	for rows.Next() {
		var i ListProductsViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsViewRedirectedApplication = `-- name: ListProductsViewRedirectedApplication :many
SELECT count(*) OVER() AS totalRecords,p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications , COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments , sum(cost)::FLOAT as cost 
FROM products p 
INNER JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE (CASE WHEN $1::bool THEN application_id = $2 ELSE TRUE END) GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE (CASE WHEN $3::bool THEN equipment_id = $4 ELSE TRUE END) GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
WHERE
  p.scope = ANY($5::TEXT[])
  AND (CASE WHEN $6::bool THEN lower(p.swidtag) LIKE '%' || lower($7::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.swidtag) = lower($7) ELSE TRUE END)
  AND (CASE WHEN $9::bool THEN lower(p.product_name) LIKE '%' || lower($10::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(p.product_name) = lower($10) ELSE TRUE END)
  AND (CASE WHEN $12::bool THEN lower(p.product_editor) LIKE '%' || lower($13::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(p.product_editor) = lower($13) ELSE TRUE END)
  GROUP BY p.swidtag,pa.num_of_applications, pe.num_of_equipments
  ORDER BY
  CASE WHEN $15::bool THEN p.swidtag END asc,
  CASE WHEN $16::bool THEN p.swidtag END desc,
  CASE WHEN $17::bool THEN p.product_name END asc,
  CASE WHEN $18::bool THEN p.product_name END desc,
  CASE WHEN $19::bool THEN p.product_edition END asc,
  CASE WHEN $20::bool THEN p.product_edition END desc,
  CASE WHEN $21::bool THEN p.product_version END asc,
  CASE WHEN $22::bool THEN p.product_version END desc,
  CASE WHEN $23::bool THEN 4 END asc,
  CASE WHEN $24::bool THEN 4 END desc,
  CASE WHEN $25::bool THEN 5 END asc,
  CASE WHEN $26::bool THEN 5 END desc,
  CASE WHEN $27::bool THEN 6 END asc,
  CASE WHEN $28::bool THEN 6 END desc,
  CASE WHEN $29::bool THEN 7 END asc,
  CASE WHEN $30::bool THEN 7 END desc
  LIMIT $32 OFFSET $31
`

type ListProductsViewRedirectedApplicationParams struct {
	IsApplicationID       bool     `json:"is_application_id"`
	ApplicationID         string   `json:"application_id"`
	IsEquipmentID         bool     `json:"is_equipment_id"`
	EquipmentID           string   `json:"equipment_id"`
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRedirectedApplicationRow struct {
	Totalrecords      int64   `json:"totalrecords"`
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListProductsViewRedirectedApplication(ctx context.Context, arg ListProductsViewRedirectedApplicationParams) ([]ListProductsViewRedirectedApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsViewRedirectedApplication,
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.IsEquipmentID,
		arg.EquipmentID,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRedirectedApplicationRow
	for rows.Next() {
		var i ListProductsViewRedirectedApplicationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsViewRedirectedEquipment = `-- name: ListProductsViewRedirectedEquipment :many
SELECT count(*) OVER() AS totalRecords,p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications , COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments , sum(cost)::FLOAT as cost 
FROM products p 
LEFT JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE (CASE WHEN $1::bool THEN application_id = $2 ELSE TRUE END) GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
INNER JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE (CASE WHEN $3::bool THEN equipment_id = $4 ELSE TRUE END) GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
WHERE
  p.scope = ANY($5::TEXT[])
  AND (CASE WHEN $6::bool THEN lower(p.swidtag) LIKE '%' || lower($7::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.swidtag) = lower($7) ELSE TRUE END)
  AND (CASE WHEN $9::bool THEN lower(p.product_name) LIKE '%' || lower($10::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(p.product_name) = lower($10) ELSE TRUE END)
  AND (CASE WHEN $12::bool THEN lower(p.product_editor) LIKE '%' || lower($13::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(p.product_editor) = lower($13) ELSE TRUE END)
  GROUP BY p.swidtag,pa.num_of_applications, pe.num_of_equipments
  ORDER BY
  CASE WHEN $15::bool THEN p.swidtag END asc,
  CASE WHEN $16::bool THEN p.swidtag END desc,
  CASE WHEN $17::bool THEN p.product_name END asc,
  CASE WHEN $18::bool THEN p.product_name END desc,
  CASE WHEN $19::bool THEN p.product_edition END asc,
  CASE WHEN $20::bool THEN p.product_edition END desc,
  CASE WHEN $21::bool THEN p.product_version END asc,
  CASE WHEN $22::bool THEN p.product_version END desc,
  CASE WHEN $23::bool THEN 4 END asc,
  CASE WHEN $24::bool THEN 4 END desc,
  CASE WHEN $25::bool THEN 5 END asc,
  CASE WHEN $26::bool THEN 5 END desc,
  CASE WHEN $27::bool THEN 6 END asc,
  CASE WHEN $28::bool THEN 6 END desc,
  CASE WHEN $29::bool THEN 7 END asc,
  CASE WHEN $30::bool THEN 7 END desc
  LIMIT $32 OFFSET $31
`

type ListProductsViewRedirectedEquipmentParams struct {
	IsApplicationID       bool     `json:"is_application_id"`
	ApplicationID         string   `json:"application_id"`
	IsEquipmentID         bool     `json:"is_equipment_id"`
	EquipmentID           string   `json:"equipment_id"`
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRedirectedEquipmentRow struct {
	Totalrecords      int64   `json:"totalrecords"`
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListProductsViewRedirectedEquipment(ctx context.Context, arg ListProductsViewRedirectedEquipmentParams) ([]ListProductsViewRedirectedEquipmentRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsViewRedirectedEquipment,
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.IsEquipmentID,
		arg.EquipmentID,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRedirectedEquipmentRow
	for rows.Next() {
		var i ListProductsViewRedirectedEquipmentRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productAggregationChildOptions = `-- name: ProductAggregationChildOptions :many
SELECT p.swidtag,p.product_name,p.product_editor,p.product_edition,p.product_version
FROM products p
WHERE 
  p.aggregation_id = $1
  AND p.scope = ANY($2::TEXT[])
`

type ProductAggregationChildOptionsParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

type ProductAggregationChildOptionsRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEditor  string `json:"product_editor"`
	ProductEdition string `json:"product_edition"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) ProductAggregationChildOptions(ctx context.Context, arg ProductAggregationChildOptionsParams) ([]ProductAggregationChildOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, productAggregationChildOptions, arg.AggregationID, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductAggregationChildOptionsRow
	for rows.Next() {
		var i ProductAggregationChildOptionsRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productAggregationDetails = `-- name: ProductAggregationDetails :one
SELECT p.aggregation_id,p.aggregation_name,p.product_editor,array_agg(distinct p.swidtag)::TEXT[] as swidtags,array_agg(distinct p.product_edition)::TEXT[] as editions, COUNT(pa.application_id)::INTEGER as num_of_applications,COUNT(pe.equipment_id)::INTEGER as num_of_equipments, SUM(p.cost)::INTEGER as total_cost  
FROM products p 
LEFT JOIN products_applications pa
ON p.swidtag = pa.swidtag
LEFT JOIN products_equipments pe
ON p.swidtag = pe.swidtag
WHERE
  p.aggregation_id = $1
  AND p.scope = ANY($2::TEXT[])
GROUP BY p.aggregation_id,p.aggregation_name,p.product_editor
`

type ProductAggregationDetailsParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

type ProductAggregationDetailsRow struct {
	AggregationID     int32    `json:"aggregation_id"`
	AggregationName   string   `json:"aggregation_name"`
	ProductEditor     string   `json:"product_editor"`
	Swidtags          []string `json:"swidtags"`
	Editions          []string `json:"editions"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	TotalCost         int32    `json:"total_cost"`
}

func (q *Queries) ProductAggregationDetails(ctx context.Context, arg ProductAggregationDetailsParams) (ProductAggregationDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, productAggregationDetails, arg.AggregationID, pq.Array(arg.Scope))
	var i ProductAggregationDetailsRow
	err := row.Scan(
		&i.AggregationID,
		&i.AggregationName,
		&i.ProductEditor,
		pq.Array(&i.Swidtags),
		pq.Array(&i.Editions),
		&i.NumOfApplications,
		&i.NumOfEquipments,
		&i.TotalCost,
	)
	return i, err
}

const upsertProduct = `-- name: UpsertProduct :exec
INSERT INTO products (swidtag, product_name, product_version, product_edition, product_category, product_editor,scope,option_of,created_on,created_by)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)
ON CONFLICT (swidtag)
DO
 UPDATE SET product_name = $2, product_version = $3, product_edition = $4,product_category = $5,product_editor= $6,scope=$7,option_of=$8,updated_on=$11,updated_by=$12
`

type UpsertProductParams struct {
	Swidtag         string         `json:"swidtag"`
	ProductName     string         `json:"product_name"`
	ProductVersion  string         `json:"product_version"`
	ProductEdition  string         `json:"product_edition"`
	ProductCategory string         `json:"product_category"`
	ProductEditor   string         `json:"product_editor"`
	Scope           string         `json:"scope"`
	OptionOf        string         `json:"option_of"`
	CreatedOn       time.Time      `json:"created_on"`
	CreatedBy       string         `json:"created_by"`
	UpdatedOn       time.Time      `json:"updated_on"`
	UpdatedBy       sql.NullString `json:"updated_by"`
}

func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) error {
	_, err := q.db.ExecContext(ctx, upsertProduct,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductVersion,
		arg.ProductEdition,
		arg.ProductCategory,
		arg.ProductEditor,
		arg.Scope,
		arg.OptionOf,
		arg.CreatedOn,
		arg.CreatedBy,
		arg.UpdatedOn,
		arg.UpdatedBy,
	)
	return err
}

const upsertProductAggregation = `-- name: UpsertProductAggregation :exec
Update products set aggregation_id = $1, aggregation_name = $2 WHERE
swidtag = ANY($3::TEXT[])
`

type UpsertProductAggregationParams struct {
	AggregationID   int32    `json:"aggregation_id"`
	AggregationName string   `json:"aggregation_name"`
	Swidtags        []string `json:"swidtags"`
}

func (q *Queries) UpsertProductAggregation(ctx context.Context, arg UpsertProductAggregationParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductAggregation, arg.AggregationID, arg.AggregationName, pq.Array(arg.Swidtags))
	return err
}

const upsertProductPartial = `-- name: UpsertProductPartial :exec
INSERT INTO products (swidtag,scope,created_by)
VALUES ($1,$2,$3)
ON CONFLICT (swidtag)
DO NOTHING
`

type UpsertProductPartialParams struct {
	Swidtag   string `json:"swidtag"`
	Scope     string `json:"scope"`
	CreatedBy string `json:"created_by"`
}

func (q *Queries) UpsertProductPartial(ctx context.Context, arg UpsertProductPartialParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductPartial, arg.Swidtag, arg.Scope, arg.CreatedBy)
	return err
}
