// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/shopspring/decimal"
	"github.com/tabbed/pqtype"
)

const addComputedLicenses = `-- name: AddComputedLicenses :exec

UPDATE acqrights
SET
    num_licences_computed = $1,
    total_computed_cost = $2
WHERE sku = $3 AND scope = $4
`

type AddComputedLicensesParams struct {
	Computedlicenses int32           `json:"computedlicenses"`
	Computedcost     decimal.Decimal `json:"computedcost"`
	Sku              string          `json:"sku"`
	Scope            string          `json:"scope"`
}

func (q *Queries) AddComputedLicenses(ctx context.Context, arg AddComputedLicensesParams) error {
	_, err := q.db.ExecContext(ctx, addComputedLicenses,
		arg.Computedlicenses,
		arg.Computedcost,
		arg.Sku,
		arg.Scope,
	)
	return err
}

const addComputedLicensesToAggregation = `-- name: AddComputedLicensesToAggregation :exec

UPDATE aggregated_rights
SET
    num_licences_computed = $1,
    total_computed_cost = $2
WHERE sku = $3 AND scope = $4
`

type AddComputedLicensesToAggregationParams struct {
	Computedlicenses int32           `json:"computedlicenses"`
	Computedcost     decimal.Decimal `json:"computedcost"`
	Sku              string          `json:"sku"`
	Scope            string          `json:"scope"`
}

func (q *Queries) AddComputedLicensesToAggregation(ctx context.Context, arg AddComputedLicensesToAggregationParams) error {
	_, err := q.db.ExecContext(ctx, addComputedLicensesToAggregation,
		arg.Computedlicenses,
		arg.Computedcost,
		arg.Sku,
		arg.Scope,
	)
	return err
}

const aggregatedRightDetails = `-- name: AggregatedRightDetails :one

SELECT
    agg.aggregation_name,
    agg.product_editor,
    agg.products as product_names,
    agg.swidtags as product_swidtags,
    COALESCE( (
            SELECT y.metrics
            FROM (
                    SELECT
                        ARRAY_AGG(DISTINCT armetrics):: TEXT [] as metrics
                    FROM
                        aggregated_rights ar,
                        unnest(
                            string_to_array(ar.metric, ',')
                        ) as armetrics
                    WHERE
                        ar.scope = $1
                        AND ar.aggregation_id = $2
                ) y
        ),
        '{}'
    ):: TEXT [] as metrics,
    COALESCE( (
            SELECT
                sum(y.num_of_applications)
            FROM (
                    SELECT
                        count(DISTINCT pa.application_id) as num_of_applications
                    FROM
                        products_applications pa
                    WHERE
                        pa.scope = $1
                        AND pa.swidtag = ANY(agg.swidtags)
                ) y
        ),
        0
    ):: INTEGER as num_of_applications,
    COALESCE( (
            SELECT
                sum(z.num_of_equipments)
            FROM (
                    SELECT
                        count(DISTINCT pe.equipment_id) as num_of_equipments
                    FROM
                        products_equipments pe
                    WHERE
                        pe.scope = $1
                        AND pe.swidtag = ANY(agg.swidtags)
                ) z
        ),
        0
    ):: INTEGER as num_of_equipments,
    COALESCE( (
            SELECT
                ARRAY_AGG(DISTINCT x.version)
            FROM (
                    SELECT
                        acq.version as version
                    FROM
                        acqrights acq
                    WHERE
                        acq.swidtag = ANY(agg.swidtags)
                        AND acq.scope = $1
                    UNION
                    SELECT
                        prd.product_version as version
                    FROM
                        products prd
                    WHERE
                        prd.swidtag = ANY(agg.swidtags)
                        AND prd.scope = $1
                ) x
        ),
        '{}'
    ):: TEXT [] as product_versions
FROM aggregations agg
WHERE scope = $1 AND id = $2
GROUP BY
    agg.aggregation_name,
    agg.product_editor,
    agg.products,
    agg.swidtags
`

type AggregatedRightDetailsParams struct {
	Scope string `json:"scope"`
	ID    int32  `json:"id"`
}

type AggregatedRightDetailsRow struct {
	AggregationName   string   `json:"aggregation_name"`
	ProductEditor     string   `json:"product_editor"`
	ProductNames      []string `json:"product_names"`
	ProductSwidtags   []string `json:"product_swidtags"`
	Metrics           []string `json:"metrics"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	ProductVersions   []string `json:"product_versions"`
}

func (q *Queries) AggregatedRightDetails(ctx context.Context, arg AggregatedRightDetailsParams) (AggregatedRightDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, aggregatedRightDetails, arg.Scope, arg.ID)
	var i AggregatedRightDetailsRow
	err := row.Scan(
		&i.AggregationName,
		&i.ProductEditor,
		pq.Array(&i.ProductNames),
		pq.Array(&i.ProductSwidtags),
		pq.Array(&i.Metrics),
		&i.NumOfApplications,
		&i.NumOfEquipments,
		pq.Array(&i.ProductVersions),
	)
	return i, err
}

const allNoMaintainenceProducts = `-- name: AllNoMaintainenceProducts :many


SELECT
    result.swidtag :: VARCHAR
FROM
    (
        SELECT
            unnest(a.swidtags) AS swidtag
        FROM
            aggregated_rights AS ar
            JOIN aggregations AS a ON ar.aggregation_id = a.id
        WHERE
            ar.scope = $1
            AND (
                start_of_maintenance IS NULL
                OR (
                    end_of_maintenance <= CURRENT_DATE
                    AND start_of_maintenance <= CURRENT_DATE
                )
            )
        UNION
        SELECT
            swidtag
        FROM
            acqrights AS acq
        WHERE
            acq.scope = $1
            AND (
                start_of_maintenance IS NULL
                OR (
                    end_of_maintenance <= CURRENT_DATE
                    AND start_of_maintenance <= CURRENT_DATE
                )
            )
    ) as result 
    where result.swidtag NOT IN( 
     SELECT final.swidtag
        FROM (
            SELECT unnest(a.swidtags) AS swidtag
            FROM aggregated_rights AS ar
            JOIN aggregations AS a ON ar.aggregation_id = a.id
            WHERE ar.scope = $1
                AND (
                    ar.start_of_maintenance IS NOT NULL
                    AND ar.end_of_maintenance > CURRENT_DATE
                    AND ar.start_of_maintenance < CURRENT_DATE
                )
            UNION
            SELECT acq.swidtag
            FROM acqrights AS acq
            WHERE acq.scope = $1
                AND (
                    acq.start_of_maintenance IS NOT NULL
                    AND acq.end_of_maintenance > CURRENT_DATE
                    AND acq.start_of_maintenance < CURRENT_DATE
                )
        ) AS final)
`

func (q *Queries) AllNoMaintainenceProducts(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, allNoMaintainenceProducts, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var result_swidtag string
		if err := rows.Scan(&result_swidtag); err != nil {
			return nil, err
		}
		items = append(items, result_swidtag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const counterFeitedProductsCosts = `-- name: CounterFeitedProductsCosts :many

SELECT
    swidtags as swid_tags,
    product_names as product_names,
    aggregation_name as aggregation_name,
    computed_cost:: Numeric(15, 2) as computed_cost,
    purchase_cost:: Numeric(15, 2) as purchase_cost, (delta_cost):: Numeric(15, 2) as delta_cost
FROM
    overall_computed_licences
WHERE
    scope = $1
    AND editor = $2
    AND cost_optimization = FALSE
GROUP BY
    swidtags,
    product_names,
    aggregation_name,
    purchase_cost,
    computed_cost,
    delta_cost
HAVING (delta_cost) < 0
ORDER BY delta_cost ASC
LIMIT 5
`

type CounterFeitedProductsCostsParams struct {
	Scope  string `json:"scope"`
	Editor string `json:"editor"`
}

type CounterFeitedProductsCostsRow struct {
	SwidTags        string          `json:"swid_tags"`
	ProductNames    string          `json:"product_names"`
	AggregationName string          `json:"aggregation_name"`
	ComputedCost    decimal.Decimal `json:"computed_cost"`
	PurchaseCost    decimal.Decimal `json:"purchase_cost"`
	DeltaCost       decimal.Decimal `json:"delta_cost"`
}

func (q *Queries) CounterFeitedProductsCosts(ctx context.Context, arg CounterFeitedProductsCostsParams) ([]CounterFeitedProductsCostsRow, error) {
	rows, err := q.db.QueryContext(ctx, counterFeitedProductsCosts, arg.Scope, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CounterFeitedProductsCostsRow
	for rows.Next() {
		var i CounterFeitedProductsCostsRow
		if err := rows.Scan(
			&i.SwidTags,
			&i.ProductNames,
			&i.AggregationName,
			&i.ComputedCost,
			&i.PurchaseCost,
			&i.DeltaCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const counterFeitedProductsLicences = `-- name: CounterFeitedProductsLicences :many

SELECT
    swidtags as swid_tags,
    product_names as product_names,
    aggregation_name as aggregation_name,
    num_computed_licences:: Numeric(15, 2) as num_computed_licences,
    num_acquired_licences:: Numeric(15, 2) as num_acquired_licences, (delta_number):: Numeric(15, 2) as delta
FROM
    overall_computed_licences
WHERE
    scope = $1
    AND editor = $2
    AND cost_optimization = FALSE
GROUP BY
    swidtags,
    product_names,
    aggregation_name,
    num_acquired_licences,
    num_computed_licences,
    delta_number
HAVING (delta_number) < 0
ORDER BY delta ASC
LIMIT 5
`

type CounterFeitedProductsLicencesParams struct {
	Scope  string `json:"scope"`
	Editor string `json:"editor"`
}

type CounterFeitedProductsLicencesRow struct {
	SwidTags            string          `json:"swid_tags"`
	ProductNames        string          `json:"product_names"`
	AggregationName     string          `json:"aggregation_name"`
	NumComputedLicences decimal.Decimal `json:"num_computed_licences"`
	NumAcquiredLicences decimal.Decimal `json:"num_acquired_licences"`
	Delta               decimal.Decimal `json:"delta"`
}

func (q *Queries) CounterFeitedProductsLicences(ctx context.Context, arg CounterFeitedProductsLicencesParams) ([]CounterFeitedProductsLicencesRow, error) {
	rows, err := q.db.QueryContext(ctx, counterFeitedProductsLicences, arg.Scope, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CounterFeitedProductsLicencesRow
	for rows.Next() {
		var i CounterFeitedProductsLicencesRow
		if err := rows.Scan(
			&i.SwidTags,
			&i.ProductNames,
			&i.AggregationName,
			&i.NumComputedLicences,
			&i.NumAcquiredLicences,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const counterfeitPercent = `-- name: CounterfeitPercent :one

select
    coalesce(sum(num_acquired_licences), 0):: Numeric(15, 2) as acq,
    coalesce(abs(sum(delta_number)), 0):: Numeric(15, 2) as delta_rights
from
    overall_computed_licences ocl
where
    ocl.scope = $1
    AND ocl.delta_number < 0
`

type CounterfeitPercentRow struct {
	Acq         decimal.Decimal `json:"acq"`
	DeltaRights decimal.Decimal `json:"delta_rights"`
}

func (q *Queries) CounterfeitPercent(ctx context.Context, scope string) (CounterfeitPercentRow, error) {
	row := q.db.QueryRowContext(ctx, counterfeitPercent, scope)
	var i CounterfeitPercentRow
	err := row.Scan(&i.Acq, &i.DeltaRights)
	return i, err
}

const deletConcurrentUserByID = `-- name: DeletConcurrentUserByID :exec

DELETE FROM
    product_concurrent_user
WHERE scope = $1 AND id = $2
`

type DeletConcurrentUserByIDParams struct {
	Scope string `json:"scope"`
	ID    int32  `json:"id"`
}

func (q *Queries) DeletConcurrentUserByID(ctx context.Context, arg DeletConcurrentUserByIDParams) error {
	_, err := q.db.ExecContext(ctx, deletConcurrentUserByID, arg.Scope, arg.ID)
	return err
}

const deleteAcqrightBySKU = `-- name: DeleteAcqrightBySKU :exec

DELETE FROM acqrights WHERE scope = $1 AND sku = $2
`

type DeleteAcqrightBySKUParams struct {
	Scope string `json:"scope"`
	Sku   string `json:"sku"`
}

func (q *Queries) DeleteAcqrightBySKU(ctx context.Context, arg DeleteAcqrightBySKUParams) error {
	_, err := q.db.ExecContext(ctx, deleteAcqrightBySKU, arg.Scope, arg.Sku)
	return err
}

const deleteAcqrightsByScope = `-- name: DeleteAcqrightsByScope :exec

DELETE FROM acqrights WHERE scope = $1
`

func (q *Queries) DeleteAcqrightsByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteAcqrightsByScope, scope)
	return err
}

const deleteAggregatedRightBySKU = `-- name: DeleteAggregatedRightBySKU :exec

DELETE FROM aggregated_rights WHERE scope = $1 AND sku = $2
`

type DeleteAggregatedRightBySKUParams struct {
	Scope string `json:"scope"`
	Sku   string `json:"sku"`
}

func (q *Queries) DeleteAggregatedRightBySKU(ctx context.Context, arg DeleteAggregatedRightBySKUParams) error {
	_, err := q.db.ExecContext(ctx, deleteAggregatedRightBySKU, arg.Scope, arg.Sku)
	return err
}

const deleteAggregatedRightsByScope = `-- name: DeleteAggregatedRightsByScope :exec

DELETE FROM aggregated_rights WHERE scope = $1
`

func (q *Queries) DeleteAggregatedRightsByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteAggregatedRightsByScope, scope)
	return err
}

const deleteAggregation = `-- name: DeleteAggregation :exec

DELETE FROM aggregations WHERE id = $1 AND scope = $2
`

type DeleteAggregationParams struct {
	ID    int32  `json:"id"`
	Scope string `json:"scope"`
}

func (q *Queries) DeleteAggregation(ctx context.Context, arg DeleteAggregationParams) error {
	_, err := q.db.ExecContext(ctx, deleteAggregation, arg.ID, arg.Scope)
	return err
}

const deleteAggregationByScope = `-- name: DeleteAggregationByScope :exec

DELETE FROM aggregations WHERE scope = $1
`

func (q *Queries) DeleteAggregationByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteAggregationByScope, scope)
	return err
}

const deleteNominativeUserByID = `-- name: DeleteNominativeUserByID :exec

DELETE FROM nominative_user WHERE scope = $1 AND user_id = $2
`

type DeleteNominativeUserByIDParams struct {
	Scope string `json:"scope"`
	ID    int32  `json:"id"`
}

func (q *Queries) DeleteNominativeUserByID(ctx context.Context, arg DeleteNominativeUserByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteNominativeUserByID, arg.Scope, arg.ID)
	return err
}

const deleteOverallComputedLicensesByScope = `-- name: DeleteOverallComputedLicensesByScope :exec

DELETE FROM overall_computed_licences WHERE scope = $1
`

func (q *Queries) DeleteOverallComputedLicensesByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteOverallComputedLicensesByScope, scope)
	return err
}

const deleteProductApplications = `-- name: DeleteProductApplications :exec

DELETE FROM
    products_applications
WHERE
    swidtag = $1
    and application_id = ANY($2:: TEXT [])
    and scope = $3
`

type DeleteProductApplicationsParams struct {
	ProductID     string   `json:"product_id"`
	ApplicationID []string `json:"application_id"`
	Scope         string   `json:"scope"`
}

func (q *Queries) DeleteProductApplications(ctx context.Context, arg DeleteProductApplicationsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductApplications, arg.ProductID, pq.Array(arg.ApplicationID), arg.Scope)
	return err
}

const deleteProductEquipments = `-- name: DeleteProductEquipments :exec

DELETE FROM
    products_equipments
WHERE
    swidtag = $1
    and equipment_id = ANY($2:: TEXT [])
    and scope = $3
`

type DeleteProductEquipmentsParams struct {
	ProductID   string   `json:"product_id"`
	EquipmentID []string `json:"equipment_id"`
	Scope       string   `json:"scope"`
}

func (q *Queries) DeleteProductEquipments(ctx context.Context, arg DeleteProductEquipmentsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductEquipments, arg.ProductID, pq.Array(arg.EquipmentID), arg.Scope)
	return err
}

const deleteProductsByScope = `-- name: DeleteProductsByScope :exec

DELETE FROM products WHERE scope = $1
`

func (q *Queries) DeleteProductsByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteProductsByScope, scope)
	return err
}

const deleteProductsBySwidTagScope = `-- name: DeleteProductsBySwidTagScope :exec

DELETE FROM products
WHERE
    products.scope = $1
    AND products.swidtag = $2
    AND product_type = 'SAAS'
`

type DeleteProductsBySwidTagScopeParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

func (q *Queries) DeleteProductsBySwidTagScope(ctx context.Context, arg DeleteProductsBySwidTagScopeParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductsBySwidTagScope, arg.Scope, arg.Swidtag)
	return err
}

const deleteSharedDataByScope = `-- name: DeleteSharedDataByScope :exec

DELETE FROM shared_licenses WHERE scope = $1
`

func (q *Queries) DeleteSharedDataByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteSharedDataByScope, scope)
	return err
}

const deleteSharedLicences = `-- name: DeleteSharedLicences :exec

Delete from shared_licenses where sku = $1 AND scope = $2
`

type DeleteSharedLicencesParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

func (q *Queries) DeleteSharedLicences(ctx context.Context, arg DeleteSharedLicencesParams) error {
	_, err := q.db.ExecContext(ctx, deleteSharedLicences, arg.Sku, arg.Scope)
	return err
}

const deployedProducts = `-- name: DeployedProducts :many

SELECT
    swidtag
FROM
    products
WHERE
    products.scope = $1
    AND swidtag NOT IN (
        SELECT
            DISTINCT(swidtag)
        FROM
            acqrights
            LEFT JOIN editor_catalog AS ec ON ec.name = acqrights.product_editor
        WHERE
            acqrights.scope = $1
            AND acqrights.swidtag NOT IN (
                SELECT
                    swidtag
                FROM
                    products_equipments
                WHERE
                    products_equipments.scope = $1
            )
        UNION
        SELECT
            swidtag
        FROM
            products
            LEFT JOIN editor_catalog AS ec ON ec.name = products.product_editor
        WHERE
            products.scope = $1
            AND products.swidtag NOT IN (
                SELECT
                    swidtag
                FROM
                    acqrights
                WHERE
                    acqrights.scope = $1
                UNION
                SELECT
                    unnest(swidtags) AS swidtags
                FROM
                    aggregations
                    INNER JOIN aggregated_rights ON aggregations.id = aggregated_rights.aggregation_id
                WHERE
                    aggregations.scope = $1
            )
            AND products.swidtag IN (
                SELECT
                    swidtag
                FROM
                    products_equipments
                WHERE
                    products_equipments.scope = $1
            )
    )
`

func (q *Queries) DeployedProducts(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, deployedProducts, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var swidtag string
		if err := rows.Scan(&swidtag); err != nil {
			return nil, err
		}
		items = append(items, swidtag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deploymentPercent = `-- name: DeploymentPercent :one
select
    coalesce(sum(count(distinct(swidtag))) OVER())::FLOAT AS totalRecords
from
    products pro
where 
    pro.scope = $1
    AND pro.product_type = $2
`

type DeploymentPercentParams struct {
	Scope       string      `json:"scope"`
	ProductType ProductType `json:"product_type"`
}

func (q *Queries) DeploymentPercent(ctx context.Context, arg DeploymentPercentParams) (float64, error) {
	row := q.db.QueryRowContext(ctx, deploymentPercent, arg.Scope, arg.ProductType)
	var totalrecords float64
	err := row.Scan(&totalrecords)
	return totalrecords, err
}

const dropAllocatedMetricFromEquipment = `-- name: DropAllocatedMetricFromEquipment :exec

UPDATE products_equipments
SET
    allocated_metric = $1
WHERE
    swidtag = $2
    AND scope = $3
    AND equipment_id = $4
`

type DropAllocatedMetricFromEquipmentParams struct {
	AllocatedMetric string `json:"allocated_metric"`
	Swidtag         string `json:"swidtag"`
	Scope           string `json:"scope"`
	EquipmentID     string `json:"equipment_id"`
}

func (q *Queries) DropAllocatedMetricFromEquipment(ctx context.Context, arg DropAllocatedMetricFromEquipmentParams) error {
	_, err := q.db.ExecContext(ctx, dropAllocatedMetricFromEquipment,
		arg.AllocatedMetric,
		arg.Swidtag,
		arg.Scope,
		arg.EquipmentID,
	)
	return err
}

const equipmentProducts = `-- name: EquipmentProducts :many

SELECT swidtag, equipment_id, num_of_users, allocated_metric, scope from products_equipments WHERE equipment_id = $1
`

func (q *Queries) EquipmentProducts(ctx context.Context, equipmentID string) ([]ProductsEquipment, error) {
	rows, err := q.db.QueryContext(ctx, equipmentProducts, equipmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsEquipment
	for rows.Next() {
		var i ProductsEquipment
		if err := rows.Scan(
			&i.Swidtag,
			&i.EquipmentID,
			&i.NumOfUsers,
			&i.AllocatedMetric,
			&i.Scope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exportConcurrentUsers = `-- name: ExportConcurrentUsers :many

SELECT
    count(*) OVER() AS totalRecords,
    pcu.id,
    pcu.swidtag,
    pcu.purchase_date,
    pcu.number_of_users,
    pcu.profile_user,
    pcu.team,
    pcu.updated_on,
    pcu.created_on,
    pcu.created_by,
    pcu.updated_by,
    pcu.aggregation_id,
    agg.aggregation_name,
    p.product_version,
    p.product_name,
    pcu.is_aggregations
FROM
    product_concurrent_user pcu
    LEFT JOIN aggregations agg on pcu.aggregation_id = agg.id
    LEFT JOIN products p on pcu.swidtag = p.swidtag
    AND p.scope = ANY($1:: TEXT [])
WHERE
    pcu.scope = ANY($1:: TEXT [])
    AND pcu.is_aggregations = $2:: bool
    AND (
        CASE
            WHEN $3:: bool THEN lower(p.product_name) LIKE '%' || lower($4:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(p.product_name) = lower($4)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $6:: bool THEN lower(agg.aggregation_name) LIKE '%' || lower($7:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(agg.aggregation_name) = lower($7)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $9:: bool THEN lower(p.product_version) LIKE '%' || lower($10:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(p.product_version) = lower($10)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $12:: bool THEN lower(pcu.profile_user) LIKE '%' || lower($13:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(pcu.profile_user) = lower($13)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $15:: bool THEN lower(pcu.team) LIKE '%' || lower($16:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $17:: bool THEN lower(pcu.team) = lower($16)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $18:: bool THEN lower(pcu.number_of_users) LIKE '%' || lower($19:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $20:: bool THEN lower(pcu.number_of_users) = lower($19)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $21:: bool THEN pcu.purchase_date <= $22
            ELSE TRUE
        END
    )
GROUP BY
    pcu.id,
    pcu.swidtag,
    pcu.purchase_date,
    pcu.number_of_users,
    pcu.profile_user,
    pcu.team,
    pcu.updated_on,
    pcu.created_on,
    pcu.created_by,
    pcu.updated_by,
    pcu.aggregation_id,
    agg.aggregation_name,
    p.product_version,
    p.product_name
ORDER BY
    CASE
        WHEN $23:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $24:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $25:: bool THEN agg.aggregation_name
    END asc,
    CASE
        WHEN $26:: bool THEN agg.aggregation_name
    END desc,
    CASE
        WHEN $27:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $28:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $29:: bool THEN pcu.profile_user
    END asc,
    CASE
        WHEN $30:: bool THEN pcu.profile_user
    END desc,
    CASE
        WHEN $31:: bool THEN pcu.team
    END asc,
    CASE
        WHEN $32:: bool THEN pcu.team
    END desc,
    CASE
        WHEN $33:: bool THEN pcu.number_of_users
    END asc,
    CASE
        WHEN $34:: bool THEN pcu.number_of_users
    END desc,
    CASE
        WHEN $35:: bool THEN pcu.purchase_date
    END asc,
    CASE
        WHEN $36:: bool THEN pcu.purchase_date
    END desc
`

type ExportConcurrentUsersParams struct {
	Scope               []string  `json:"scope"`
	IsAggregations      bool      `json:"is_aggregations"`
	LkProductName       bool      `json:"lk_product_name"`
	ProductName         string    `json:"product_name"`
	IsProductName       bool      `json:"is_product_name"`
	LkAggregationName   bool      `json:"lk_aggregation_name"`
	AggregationName     string    `json:"aggregation_name"`
	IsAggregationName   bool      `json:"is_aggregation_name"`
	LkProductVersion    bool      `json:"lk_product_version"`
	ProductVersion      string    `json:"product_version"`
	IsProductVersion    bool      `json:"is_product_version"`
	LkProfileUser       bool      `json:"lk_profile_user"`
	ProfileUser         string    `json:"profile_user"`
	IsProfileUser       bool      `json:"is_profile_user"`
	LkTeam              bool      `json:"lk_team"`
	Team                string    `json:"team"`
	IsTeam              bool      `json:"is_team"`
	LkNumberOfUsers     bool      `json:"lk_number_of_users"`
	NumberOfUsers       string    `json:"number_of_users"`
	IsNumberOfUsers     bool      `json:"is_number_of_users"`
	IsPurchaseDate      bool      `json:"is_purchase_date"`
	PurchaseDate        time.Time `json:"purchase_date"`
	ProductNameAsc      bool      `json:"product_name_asc"`
	ProductNameDesc     bool      `json:"product_name_desc"`
	AggregationNameAsc  bool      `json:"aggregation_name_asc"`
	AggregationNameDesc bool      `json:"aggregation_name_desc"`
	ProductVersionAsc   bool      `json:"product_version_asc"`
	ProductVersionDesc  bool      `json:"product_version_desc"`
	ProfileUserAsc      bool      `json:"profile_user_asc"`
	ProfileUserDesc     bool      `json:"profile_user_desc"`
	TeamAsc             bool      `json:"team_asc"`
	TeamDesc            bool      `json:"team_desc"`
	NumberOfUsersAsc    bool      `json:"number_of_users_asc"`
	NumberOfUsersDesc   bool      `json:"number_of_users_desc"`
	PurchaseDateAsc     bool      `json:"purchase_date_asc"`
	PurchaseDateDesc    bool      `json:"purchase_date_desc"`
}

type ExportConcurrentUsersRow struct {
	Totalrecords    int64          `json:"totalrecords"`
	ID              int32          `json:"id"`
	Swidtag         sql.NullString `json:"swidtag"`
	PurchaseDate    time.Time      `json:"purchase_date"`
	NumberOfUsers   sql.NullInt32  `json:"number_of_users"`
	ProfileUser     sql.NullString `json:"profile_user"`
	Team            sql.NullString `json:"team"`
	UpdatedOn       time.Time      `json:"updated_on"`
	CreatedOn       time.Time      `json:"created_on"`
	CreatedBy       string         `json:"created_by"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	AggregationID   sql.NullInt32  `json:"aggregation_id"`
	AggregationName sql.NullString `json:"aggregation_name"`
	ProductVersion  sql.NullString `json:"product_version"`
	ProductName     sql.NullString `json:"product_name"`
	IsAggregations  sql.NullBool   `json:"is_aggregations"`
}

func (q *Queries) ExportConcurrentUsers(ctx context.Context, arg ExportConcurrentUsersParams) ([]ExportConcurrentUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, exportConcurrentUsers,
		pq.Array(arg.Scope),
		arg.IsAggregations,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkProductVersion,
		arg.ProductVersion,
		arg.IsProductVersion,
		arg.LkProfileUser,
		arg.ProfileUser,
		arg.IsProfileUser,
		arg.LkTeam,
		arg.Team,
		arg.IsTeam,
		arg.LkNumberOfUsers,
		arg.NumberOfUsers,
		arg.IsNumberOfUsers,
		arg.IsPurchaseDate,
		arg.PurchaseDate,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProfileUserAsc,
		arg.ProfileUserDesc,
		arg.TeamAsc,
		arg.TeamDesc,
		arg.NumberOfUsersAsc,
		arg.NumberOfUsersDesc,
		arg.PurchaseDateAsc,
		arg.PurchaseDateDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExportConcurrentUsersRow
	for rows.Next() {
		var i ExportConcurrentUsersRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ID,
			&i.Swidtag,
			&i.PurchaseDate,
			&i.NumberOfUsers,
			&i.ProfileUser,
			&i.Team,
			&i.UpdatedOn,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.AggregationID,
			&i.AggregationName,
			&i.ProductVersion,
			&i.ProductName,
			&i.IsAggregations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exportNominativeUsersAggregation = `-- name: ExportNominativeUsersAggregation :many

SELECT
    count(*) OVER() AS totalRecords,
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    nu.aggregations_id,
    agg.aggregation_name
FROM nominative_user nU
    LEFT JOIN aggregations agg on nu.aggregations_id = agg.id
WHERE
    nu.aggregations_id != 0
    AND nu.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $2:: bool THEN lower(agg.aggregation_name) LIKE '%' || lower($3:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN lower(agg.aggregation_name) = lower($3)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(nu.user_name) LIKE '%' || lower($6:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $7:: bool THEN lower(nu.user_name) = lower($6)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(nu.first_name) LIKE '%' || lower($9:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $10:: bool THEN lower(nu.first_name) = lower($9)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(nu.user_email) LIKE '%' || lower($12:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $13:: bool THEN lower(nu.user_email) = lower($12)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(nu.profile) LIKE '%' || lower($15:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $16:: bool THEN lower(nu.profile) = lower($15)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $17:: bool THEN date(nu.activation_date):: text = $18:: text
            ELSE TRUE
        END
    )
GROUP BY
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    nu.aggregations_id,
    agg.aggregation_name
ORDER BY
    CASE
        WHEN $19:: bool THEN agg.aggregation_name
    END asc,
    CASE
        WHEN $20:: bool THEN agg.aggregation_name
    END desc,
    CASE
        WHEN $21:: bool THEN nu.user_name
    END asc,
    CASE
        WHEN $22:: bool THEN nu.user_name
    END desc,
    CASE
        WHEN $23:: bool THEN nu.first_name
    END asc,
    CASE
        WHEN $24:: bool THEN nu.first_name
    END desc,
    CASE
        WHEN $25:: bool THEN nu.user_email
    END asc,
    CASE
        WHEN $26:: bool THEN nu.user_email
    END desc,
    CASE
        WHEN $27:: bool THEN nu.profile
    END asc,
    CASE
        WHEN $28:: bool THEN nu.profile
    END desc,
    CASE
        WHEN $29:: bool THEN nu.activation_date
    END asc,
    CASE
        WHEN $30:: bool THEN nu.activation_date
    END desc
`

type ExportNominativeUsersAggregationParams struct {
	Scope               []string `json:"scope"`
	LkAggregationName   bool     `json:"lk_aggregation_name"`
	AggregationName     string   `json:"aggregation_name"`
	IsAggregationName   bool     `json:"is_aggregation_name"`
	LkUserName          bool     `json:"lk_user_name"`
	UserName            string   `json:"user_name"`
	IsUserName          bool     `json:"is_user_name"`
	LkFirstName         bool     `json:"lk_first_name"`
	FirstName           string   `json:"first_name"`
	IsFirstName         bool     `json:"is_first_name"`
	LkUserEmail         bool     `json:"lk_user_email"`
	UserEmail           string   `json:"user_email"`
	IsUserEmail         bool     `json:"is_user_email"`
	LkProfile           bool     `json:"lk_profile"`
	Profile             string   `json:"profile"`
	IsProfile           bool     `json:"is_profile"`
	IsActivationDate    bool     `json:"is_activation_date"`
	ActivationDate      string   `json:"activation_date"`
	AggregationNameAsc  bool     `json:"aggregation_name_asc"`
	AggregationNameDesc bool     `json:"aggregation_name_desc"`
	UserNameAsc         bool     `json:"user_name_asc"`
	UserNameDesc        bool     `json:"user_name_desc"`
	FirstNameAsc        bool     `json:"first_name_asc"`
	FirstNameDesc       bool     `json:"first_name_desc"`
	UserEmailAsc        bool     `json:"user_email_asc"`
	UserEmailDesc       bool     `json:"user_email_desc"`
	ProfileAsc          bool     `json:"profile_asc"`
	ProfileDesc         bool     `json:"profile_desc"`
	ActivationDateAsc   bool     `json:"activation_date_asc"`
	ActivationDateDesc  bool     `json:"activation_date_desc"`
}

type ExportNominativeUsersAggregationRow struct {
	Totalrecords    int64          `json:"totalrecords"`
	UserID          int32          `json:"user_id"`
	Swidtag         sql.NullString `json:"swidtag"`
	ActivationDate  sql.NullTime   `json:"activation_date"`
	UserEmail       string         `json:"user_email"`
	UserName        sql.NullString `json:"user_name"`
	FirstName       sql.NullString `json:"first_name"`
	Profile         sql.NullString `json:"profile"`
	ProductEditor   sql.NullString `json:"product_editor"`
	UpdatedAt       time.Time      `json:"updated_at"`
	CreatedAt       time.Time      `json:"created_at"`
	CreatedBy       string         `json:"created_by"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	AggregationsID  sql.NullInt32  `json:"aggregations_id"`
	AggregationName sql.NullString `json:"aggregation_name"`
}

func (q *Queries) ExportNominativeUsersAggregation(ctx context.Context, arg ExportNominativeUsersAggregationParams) ([]ExportNominativeUsersAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, exportNominativeUsersAggregation,
		pq.Array(arg.Scope),
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkUserName,
		arg.UserName,
		arg.IsUserName,
		arg.LkFirstName,
		arg.FirstName,
		arg.IsFirstName,
		arg.LkUserEmail,
		arg.UserEmail,
		arg.IsUserEmail,
		arg.LkProfile,
		arg.Profile,
		arg.IsProfile,
		arg.IsActivationDate,
		arg.ActivationDate,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.UserNameAsc,
		arg.UserNameDesc,
		arg.FirstNameAsc,
		arg.FirstNameDesc,
		arg.UserEmailAsc,
		arg.UserEmailDesc,
		arg.ProfileAsc,
		arg.ProfileDesc,
		arg.ActivationDateAsc,
		arg.ActivationDateDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExportNominativeUsersAggregationRow
	for rows.Next() {
		var i ExportNominativeUsersAggregationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UserID,
			&i.Swidtag,
			&i.ActivationDate,
			&i.UserEmail,
			&i.UserName,
			&i.FirstName,
			&i.Profile,
			&i.ProductEditor,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.AggregationsID,
			&i.AggregationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const exportNominativeUsersProducts = `-- name: ExportNominativeUsersProducts :many

SELECT
    count(*) OVER() AS totalRecords,
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    p.product_version,
    p.product_name
FROM nominative_user nU
    INNER JOIN products p on nu.swidtag = p.swidtag and nu.scope = ANY($1:: TEXT []) AND p.scope = ANY($1:: TEXT [])
where
    nu.swidtag != ''
    AND nu.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $2:: bool THEN lower(p.product_name) LIKE '%' || lower($3:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN lower(p.product_name) = lower($3)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(p.product_version) LIKE '%' || lower($6:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $7:: bool THEN lower(p.product_version) = lower($6)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(nu.user_name) LIKE '%' || lower($9:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $10:: bool THEN lower(nu.user_name) = lower($9)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(nu.first_name) LIKE '%' || lower($12:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $13:: bool THEN lower(nu.first_name) = lower($12)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(nu.user_email) LIKE '%' || lower($15:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $16:: bool THEN lower(nu.user_email) = lower($15)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $17:: bool THEN lower(nu.profile) LIKE '%' || lower($18:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $19:: bool THEN lower(nu.profile) = lower($18)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $20:: bool THEN date(nu.activation_date):: text = $21:: text
            ELSE TRUE
        END
    )
GROUP BY
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    p.product_version,
    p.product_name
ORDER BY
    CASE
        WHEN $22:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $23:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $24:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $25:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $26:: bool THEN nu.user_name
    END asc,
    CASE
        WHEN $27:: bool THEN nu.user_name
    END desc,
    CASE
        WHEN $28:: bool THEN nu.first_name
    END asc,
    CASE
        WHEN $29:: bool THEN nu.first_name
    END desc,
    CASE
        WHEN $30:: bool THEN nu.user_email
    END asc,
    CASE
        WHEN $31:: bool THEN nu.user_email
    END desc,
    CASE
        WHEN $32:: bool THEN nu.profile
    END asc,
    CASE
        WHEN $33:: bool THEN nu.profile
    END desc,
    CASE
        WHEN $34:: bool THEN nu.activation_date
    END asc,
    CASE
        WHEN $35:: bool THEN nu.activation_date
    END desc
`

type ExportNominativeUsersProductsParams struct {
	Scope              []string `json:"scope"`
	LkProductName      bool     `json:"lk_product_name"`
	ProductName        string   `json:"product_name"`
	IsProductName      bool     `json:"is_product_name"`
	LkProductVersion   bool     `json:"lk_product_version"`
	ProductVersion     string   `json:"product_version"`
	IsProductVersion   bool     `json:"is_product_version"`
	LkUserName         bool     `json:"lk_user_name"`
	UserName           string   `json:"user_name"`
	IsUserName         bool     `json:"is_user_name"`
	LkFirstName        bool     `json:"lk_first_name"`
	FirstName          string   `json:"first_name"`
	IsFirstName        bool     `json:"is_first_name"`
	LkUserEmail        bool     `json:"lk_user_email"`
	UserEmail          string   `json:"user_email"`
	IsUserEmail        bool     `json:"is_user_email"`
	LkProfile          bool     `json:"lk_profile"`
	Profile            string   `json:"profile"`
	IsProfile          bool     `json:"is_profile"`
	IsActivationDate   bool     `json:"is_activation_date"`
	ActivationDate     string   `json:"activation_date"`
	ProductNameAsc     bool     `json:"product_name_asc"`
	ProductNameDesc    bool     `json:"product_name_desc"`
	ProductVersionAsc  bool     `json:"product_version_asc"`
	ProductVersionDesc bool     `json:"product_version_desc"`
	UserNameAsc        bool     `json:"user_name_asc"`
	UserNameDesc       bool     `json:"user_name_desc"`
	FirstNameAsc       bool     `json:"first_name_asc"`
	FirstNameDesc      bool     `json:"first_name_desc"`
	UserEmailAsc       bool     `json:"user_email_asc"`
	UserEmailDesc      bool     `json:"user_email_desc"`
	ProfileAsc         bool     `json:"profile_asc"`
	ProfileDesc        bool     `json:"profile_desc"`
	ActivationDateAsc  bool     `json:"activation_date_asc"`
	ActivationDateDesc bool     `json:"activation_date_desc"`
}

type ExportNominativeUsersProductsRow struct {
	Totalrecords   int64          `json:"totalrecords"`
	UserID         int32          `json:"user_id"`
	Swidtag        sql.NullString `json:"swidtag"`
	ActivationDate sql.NullTime   `json:"activation_date"`
	UserEmail      string         `json:"user_email"`
	UserName       sql.NullString `json:"user_name"`
	FirstName      sql.NullString `json:"first_name"`
	Profile        sql.NullString `json:"profile"`
	ProductEditor  sql.NullString `json:"product_editor"`
	UpdatedAt      time.Time      `json:"updated_at"`
	CreatedAt      time.Time      `json:"created_at"`
	CreatedBy      string         `json:"created_by"`
	UpdatedBy      sql.NullString `json:"updated_by"`
	ProductVersion string         `json:"product_version"`
	ProductName    string         `json:"product_name"`
}

func (q *Queries) ExportNominativeUsersProducts(ctx context.Context, arg ExportNominativeUsersProductsParams) ([]ExportNominativeUsersProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, exportNominativeUsersProducts,
		pq.Array(arg.Scope),
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductVersion,
		arg.ProductVersion,
		arg.IsProductVersion,
		arg.LkUserName,
		arg.UserName,
		arg.IsUserName,
		arg.LkFirstName,
		arg.FirstName,
		arg.IsFirstName,
		arg.LkUserEmail,
		arg.UserEmail,
		arg.IsUserEmail,
		arg.LkProfile,
		arg.Profile,
		arg.IsProfile,
		arg.IsActivationDate,
		arg.ActivationDate,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.UserNameAsc,
		arg.UserNameDesc,
		arg.FirstNameAsc,
		arg.FirstNameDesc,
		arg.UserEmailAsc,
		arg.UserEmailDesc,
		arg.ProfileAsc,
		arg.ProfileDesc,
		arg.ActivationDateAsc,
		arg.ActivationDateDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExportNominativeUsersProductsRow
	for rows.Next() {
		var i ExportNominativeUsersProductsRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UserID,
			&i.Swidtag,
			&i.ActivationDate,
			&i.UserEmail,
			&i.UserName,
			&i.FirstName,
			&i.Profile,
			&i.ProductEditor,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.ProductVersion,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAcqBySwidtag = `-- name: GetAcqBySwidtag :one

Select sku, swidtag, product_name, product_editor, scope, metric, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, created_on, created_by, updated_on, updated_by, start_of_maintenance, end_of_maintenance, last_purchased_order, support_number, maintenance_provider, version, comment, ordering_date, corporate_sourcing_contract, software_provider, file_name, file_data, repartition, support_numbers
from acqrights
where
    swidtag = $1
    and scope = $2
`

type GetAcqBySwidtagParams struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

func (q *Queries) GetAcqBySwidtag(ctx context.Context, arg GetAcqBySwidtagParams) (Acqright, error) {
	row := q.db.QueryRowContext(ctx, getAcqBySwidtag, arg.Swidtag, arg.Scope)
	var i Acqright
	err := row.Scan(
		&i.Sku,
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.Scope,
		&i.Metric,
		&i.NumLicensesAcquired,
		&i.NumLicencesComputed,
		&i.NumLicencesMaintainance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalComputedCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.LastPurchasedOrder,
		&i.SupportNumber,
		&i.MaintenanceProvider,
		&i.Version,
		&i.Comment,
		&i.OrderingDate,
		&i.CorporateSourcingContract,
		&i.SoftwareProvider,
		&i.FileName,
		&i.FileData,
		&i.Repartition,
		pq.Array(&i.SupportNumbers),
	)
	return i, err
}

const getAcqBySwidtags = `-- name: GetAcqBySwidtags :many

Select
    sku,
    swidtag,
    product_name,
    product_editor,
    metric,
    num_licenses_acquired,
    num_licences_maintainance,
    avg_unit_price,
    avg_maintenance_unit_price,
    total_purchase_cost,
    total_maintenance_cost,
    total_cost,
    start_of_maintenance,
    end_of_maintenance,
    version,
    comment,
    ordering_date,
    software_provider,
    corporate_sourcing_contract,
    last_purchased_order,
    support_numbers,
    maintenance_provider,
    file_name
from acqrights
where
    swidtag = ANY($1:: TEXT [])
    and scope = $2
    AND (
        CASE
            WHEN $3:: bool THEN lower(metric) = lower($4)
            ELSE TRUE
        END
    )
`

type GetAcqBySwidtagsParams struct {
	Swidtag  []string `json:"swidtag"`
	Scope    string   `json:"scope"`
	IsMetric bool     `json:"is_metric"`
	Metric   string   `json:"metric"`
}

type GetAcqBySwidtagsRow struct {
	Sku                       string          `json:"sku"`
	Swidtag                   string          `json:"swidtag"`
	ProductName               string          `json:"product_name"`
	ProductEditor             string          `json:"product_editor"`
	Metric                    string          `json:"metric"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	NumLicencesMaintainance   int32           `json:"num_licences_maintainance"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	Version                   string          `json:"version"`
	Comment                   sql.NullString  `json:"comment"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	SoftwareProvider          string          `json:"software_provider"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	FileName                  string          `json:"file_name"`
}

func (q *Queries) GetAcqBySwidtags(ctx context.Context, arg GetAcqBySwidtagsParams) ([]GetAcqBySwidtagsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAcqBySwidtags,
		pq.Array(arg.Swidtag),
		arg.Scope,
		arg.IsMetric,
		arg.Metric,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAcqBySwidtagsRow
	for rows.Next() {
		var i GetAcqBySwidtagsRow
		if err := rows.Scan(
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Version,
			&i.Comment,
			&i.OrderingDate,
			&i.SoftwareProvider,
			&i.CorporateSourcingContract,
			&i.LastPurchasedOrder,
			pq.Array(&i.SupportNumbers),
			&i.MaintenanceProvider,
			&i.FileName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAcqRightBySKU = `-- name: GetAcqRightBySKU :one

SELECT
    sku,
    swidtag,
    product_name,
    product_editor,
    metric,
    num_licenses_acquired,
    num_licences_maintainance,
    avg_unit_price,
    avg_maintenance_unit_price,
    total_purchase_cost,
    total_maintenance_cost,
    total_cost,
    start_of_maintenance,
    end_of_maintenance,
    version,
    comment,
    ordering_date,
    software_provider,
    corporate_sourcing_contract,
    last_purchased_order,
    support_numbers,
    maintenance_provider,
    file_name,
    file_data,
    repartition
FROM acqrights
WHERE
    sku = $1
    and scope = $2
`

type GetAcqRightBySKUParams struct {
	AcqrightSku string `json:"acqright_sku"`
	Scope       string `json:"scope"`
}

type GetAcqRightBySKURow struct {
	Sku                       string          `json:"sku"`
	Swidtag                   string          `json:"swidtag"`
	ProductName               string          `json:"product_name"`
	ProductEditor             string          `json:"product_editor"`
	Metric                    string          `json:"metric"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	NumLicencesMaintainance   int32           `json:"num_licences_maintainance"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	Version                   string          `json:"version"`
	Comment                   sql.NullString  `json:"comment"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	SoftwareProvider          string          `json:"software_provider"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	FileName                  string          `json:"file_name"`
	FileData                  []byte          `json:"file_data"`
	Repartition               bool            `json:"repartition"`
}

func (q *Queries) GetAcqRightBySKU(ctx context.Context, arg GetAcqRightBySKUParams) (GetAcqRightBySKURow, error) {
	row := q.db.QueryRowContext(ctx, getAcqRightBySKU, arg.AcqrightSku, arg.Scope)
	var i GetAcqRightBySKURow
	err := row.Scan(
		&i.Sku,
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.Metric,
		&i.NumLicensesAcquired,
		&i.NumLicencesMaintainance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.Version,
		&i.Comment,
		&i.OrderingDate,
		&i.SoftwareProvider,
		&i.CorporateSourcingContract,
		&i.LastPurchasedOrder,
		pq.Array(&i.SupportNumbers),
		&i.MaintenanceProvider,
		&i.FileName,
		&i.FileData,
		&i.Repartition,
	)
	return i, err
}

const getAcqRightFileDataBySKU = `-- name: GetAcqRightFileDataBySKU :one

SELECT file_data
FROM acqrights
WHERE
    sku = $1
    and scope = $2
`

type GetAcqRightFileDataBySKUParams struct {
	AcqrightSku string `json:"acqright_sku"`
	Scope       string `json:"scope"`
}

func (q *Queries) GetAcqRightFileDataBySKU(ctx context.Context, arg GetAcqRightFileDataBySKUParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getAcqRightFileDataBySKU, arg.AcqrightSku, arg.Scope)
	var file_data []byte
	err := row.Scan(&file_data)
	return file_data, err
}

const getAcqRightMetricsBySwidtag = `-- name: GetAcqRightMetricsBySwidtag :many

SELECT sku, metric
FROM acqrights
WHERE
    scope = $1
    AND swidtag = $2
`

type GetAcqRightMetricsBySwidtagParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

type GetAcqRightMetricsBySwidtagRow struct {
	Sku    string `json:"sku"`
	Metric string `json:"metric"`
}

func (q *Queries) GetAcqRightMetricsBySwidtag(ctx context.Context, arg GetAcqRightMetricsBySwidtagParams) ([]GetAcqRightMetricsBySwidtagRow, error) {
	rows, err := q.db.QueryContext(ctx, getAcqRightMetricsBySwidtag, arg.Scope, arg.Swidtag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAcqRightMetricsBySwidtagRow
	for rows.Next() {
		var i GetAcqRightMetricsBySwidtagRow
		if err := rows.Scan(&i.Sku, &i.Metric); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAcqRightsByEditor = `-- name: GetAcqRightsByEditor :many

SELECT
    acq.sku,
    acq.swidtag,
    acq.metric,
    acq.avg_unit_price:: FLOAT AS avg_unit_price,
    acq.num_licenses_acquired
FROM acqrights acq
WHERE
    acq.product_editor = $1
    AND acq.scope = $2
`

type GetAcqRightsByEditorParams struct {
	ProductEditor string `json:"product_editor"`
	Scope         string `json:"scope"`
}

type GetAcqRightsByEditorRow struct {
	Sku                 string  `json:"sku"`
	Swidtag             string  `json:"swidtag"`
	Metric              string  `json:"metric"`
	AvgUnitPrice        float64 `json:"avg_unit_price"`
	NumLicensesAcquired int32   `json:"num_licenses_acquired"`
}

func (q *Queries) GetAcqRightsByEditor(ctx context.Context, arg GetAcqRightsByEditorParams) ([]GetAcqRightsByEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getAcqRightsByEditor, arg.ProductEditor, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAcqRightsByEditorRow
	for rows.Next() {
		var i GetAcqRightsByEditorRow
		if err := rows.Scan(
			&i.Sku,
			&i.Swidtag,
			&i.Metric,
			&i.AvgUnitPrice,
			&i.NumLicensesAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAcqRightsCost = `-- name: GetAcqRightsCost :one

SELECT
    SUM(total_cost):: Numeric(15, 2) as total_cost,
    SUM(total_maintenance_cost):: Numeric(15, 2) as total_maintenance_cost
from acqrights
WHERE
    scope = ANY($1:: TEXT [])
GROUP BY scope
`

type GetAcqRightsCostRow struct {
	TotalCost            decimal.Decimal `json:"total_cost"`
	TotalMaintenanceCost decimal.Decimal `json:"total_maintenance_cost"`
}

func (q *Queries) GetAcqRightsCost(ctx context.Context, scope []string) (GetAcqRightsCostRow, error) {
	row := q.db.QueryRowContext(ctx, getAcqRightsCost, pq.Array(scope))
	var i GetAcqRightsCostRow
	err := row.Scan(&i.TotalCost, &i.TotalMaintenanceCost)
	return i, err
}

const getAggRightMetricsByAggregationId = `-- name: GetAggRightMetricsByAggregationId :many

SELECT sku, metric
FROM aggregated_rights
WHERE
    scope = $1
    AND aggregation_id = $2
`

type GetAggRightMetricsByAggregationIdParams struct {
	Scope string `json:"scope"`
	AggID int32  `json:"agg_id"`
}

type GetAggRightMetricsByAggregationIdRow struct {
	Sku    string `json:"sku"`
	Metric string `json:"metric"`
}

func (q *Queries) GetAggRightMetricsByAggregationId(ctx context.Context, arg GetAggRightMetricsByAggregationIdParams) ([]GetAggRightMetricsByAggregationIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggRightMetricsByAggregationId, arg.Scope, arg.AggID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggRightMetricsByAggregationIdRow
	for rows.Next() {
		var i GetAggRightMetricsByAggregationIdRow
		if err := rows.Scan(&i.Sku, &i.Metric); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAggregatedRightBySKU = `-- name: GetAggregatedRightBySKU :one

SELECT
    sku,
    aggregation_id,
    metric,
    ordering_date,
    corporate_sourcing_contract,
    software_provider,
    scope,
    num_licenses_acquired,
    num_licences_computed,
    num_licences_maintenance,
    avg_unit_price,
    avg_maintenance_unit_price,
    total_purchase_cost,
    total_computed_cost,
    total_maintenance_cost,
    total_cost,
    start_of_maintenance,
    end_of_maintenance,
    last_purchased_order,
    support_numbers,
    maintenance_provider,
    comment,
    file_name
FROM aggregated_rights
WHERE sku = $1 AND scope = $2
`

type GetAggregatedRightBySKUParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

type GetAggregatedRightBySKURow struct {
	Sku                       string          `json:"sku"`
	AggregationID             int32           `json:"aggregation_id"`
	Metric                    string          `json:"metric"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	SoftwareProvider          string          `json:"software_provider"`
	Scope                     string          `json:"scope"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	NumLicencesComputed       int32           `json:"num_licences_computed"`
	NumLicencesMaintenance    int32           `json:"num_licences_maintenance"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost         decimal.Decimal `json:"total_computed_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	Comment                   sql.NullString  `json:"comment"`
	FileName                  string          `json:"file_name"`
}

func (q *Queries) GetAggregatedRightBySKU(ctx context.Context, arg GetAggregatedRightBySKUParams) (GetAggregatedRightBySKURow, error) {
	row := q.db.QueryRowContext(ctx, getAggregatedRightBySKU, arg.Sku, arg.Scope)
	var i GetAggregatedRightBySKURow
	err := row.Scan(
		&i.Sku,
		&i.AggregationID,
		&i.Metric,
		&i.OrderingDate,
		&i.CorporateSourcingContract,
		&i.SoftwareProvider,
		&i.Scope,
		&i.NumLicensesAcquired,
		&i.NumLicencesComputed,
		&i.NumLicencesMaintenance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalComputedCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.LastPurchasedOrder,
		pq.Array(&i.SupportNumbers),
		&i.MaintenanceProvider,
		&i.Comment,
		&i.FileName,
	)
	return i, err
}

const getAggregatedRightsFileDataBySKU = `-- name: GetAggregatedRightsFileDataBySKU :one

SELECT file_data
FROM aggregated_rights
WHERE sku = $1 and scope = $2
`

type GetAggregatedRightsFileDataBySKUParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAggregatedRightsFileDataBySKU(ctx context.Context, arg GetAggregatedRightsFileDataBySKUParams) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, getAggregatedRightsFileDataBySKU, arg.Sku, arg.Scope)
	var file_data []byte
	err := row.Scan(&file_data)
	return file_data, err
}

const getAggregationByEditor = `-- name: GetAggregationByEditor :many

SELECT
    agg.aggregation_name,
    array_to_string(agg.swidtags, ',') as swidtags,
    COALESCE(agr.sku, '') as sku,
    COALESCE(agr.metric, '') as metric,
    COALESCE(agr.avg_unit_price, 0):: FLOAT AS avg_unit_price,
    COALESCE(agr.num_licenses_acquired, 0)
FROM aggregations agg
    LEFT JOIN (
        SELECT
            a.aggregation_id,
            a.sku,
            a.metric,
            a.avg_unit_price,
            a.num_licenses_acquired
        FROM
            aggregated_rights a
        WHERE
            a.scope = $1
    ) agr ON agr.aggregation_id = agg.id
WHERE
    agg.scope = $1
    AND agg.product_editor = $2
`

type GetAggregationByEditorParams struct {
	Scope         string `json:"scope"`
	ProductEditor string `json:"product_editor"`
}

type GetAggregationByEditorRow struct {
	AggregationName     string  `json:"aggregation_name"`
	Swidtags            string  `json:"swidtags"`
	Sku                 string  `json:"sku"`
	Metric              string  `json:"metric"`
	AvgUnitPrice        float64 `json:"avg_unit_price"`
	NumLicensesAcquired int32   `json:"num_licenses_acquired"`
}

func (q *Queries) GetAggregationByEditor(ctx context.Context, arg GetAggregationByEditorParams) ([]GetAggregationByEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getAggregationByEditor, arg.Scope, arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAggregationByEditorRow
	for rows.Next() {
		var i GetAggregationByEditorRow
		if err := rows.Scan(
			&i.AggregationName,
			&i.Swidtags,
			&i.Sku,
			&i.Metric,
			&i.AvgUnitPrice,
			&i.NumLicensesAcquired,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAggregationByID = `-- name: GetAggregationByID :one

SELECT id, aggregation_name, scope, product_editor, products, swidtags, created_on, created_by, updated_on, updated_by FROM aggregations WHERE id = $1 AND scope = $2
`

type GetAggregationByIDParams struct {
	ID    int32  `json:"id"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAggregationByID(ctx context.Context, arg GetAggregationByIDParams) (Aggregation, error) {
	row := q.db.QueryRowContext(ctx, getAggregationByID, arg.ID, arg.Scope)
	var i Aggregation
	err := row.Scan(
		&i.ID,
		&i.AggregationName,
		&i.Scope,
		&i.ProductEditor,
		pq.Array(&i.Products),
		pq.Array(&i.Swidtags),
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const getAggregationByName = `-- name: GetAggregationByName :one

SELECT id, aggregation_name, scope, product_editor, products, swidtags, created_on, created_by, updated_on, updated_by
FROM aggregations
WHERE
    aggregation_name = $1
    AND scope = $2
`

type GetAggregationByNameParams struct {
	AggregationName string `json:"aggregation_name"`
	Scope           string `json:"scope"`
}

func (q *Queries) GetAggregationByName(ctx context.Context, arg GetAggregationByNameParams) (Aggregation, error) {
	row := q.db.QueryRowContext(ctx, getAggregationByName, arg.AggregationName, arg.Scope)
	var i Aggregation
	err := row.Scan(
		&i.ID,
		&i.AggregationName,
		&i.Scope,
		&i.ProductEditor,
		pq.Array(&i.Products),
		pq.Array(&i.Swidtags),
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const getApplicationsByProductID = `-- name: GetApplicationsByProductID :many

SELECT application_id
from products_applications
WHERE
    scope = $1
    AND swidtag = $2
`

type GetApplicationsByProductIDParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

func (q *Queries) GetApplicationsByProductID(ctx context.Context, arg GetApplicationsByProductIDParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getApplicationsByProductID, arg.Scope, arg.Swidtag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var application_id string
		if err := rows.Scan(&application_id); err != nil {
			return nil, err
		}
		items = append(items, application_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableAcqLicenses = `-- name: GetAvailableAcqLicenses :one

SELECT
    COALESCE(num_licenses_acquired, 0):: INTEGER as acquired_licences
FROM acqrights
WHERE sku = $1 AND scope = $2
GROUP BY
    num_licenses_acquired
`

type GetAvailableAcqLicensesParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAvailableAcqLicenses(ctx context.Context, arg GetAvailableAcqLicensesParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getAvailableAcqLicenses, arg.Sku, arg.Scope)
	var acquired_licences int32
	err := row.Scan(&acquired_licences)
	return acquired_licences, err
}

const getAvailableAggLicenses = `-- name: GetAvailableAggLicenses :one

SELECT
    COALESCE(num_licenses_acquired, 0):: INTEGER as acquired_licences
FROM aggregated_rights
WHERE sku = $1 AND scope = $2
GROUP BY
    num_licenses_acquired
`

type GetAvailableAggLicensesParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAvailableAggLicenses(ctx context.Context, arg GetAvailableAggLicensesParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getAvailableAggLicenses, arg.Sku, arg.Scope)
	var acquired_licences int32
	err := row.Scan(&acquired_licences)
	return acquired_licences, err
}

const getComputedCost = `-- name: GetComputedCost :one
SELECT
    SUM(computed_cost + (total_cost-purchase_cost)):: Numeric(15, 2) as total_cost,
    SUM(computed_cost):: Numeric(15, 2) as purchase_cost
from overall_computed_licences
WHERE
    scope = ANY($1:: TEXT [])
GROUP BY scope
`

type GetComputedCostRow struct {
	TotalCost    decimal.Decimal `json:"total_cost"`
	PurchaseCost decimal.Decimal `json:"purchase_cost"`
}

func (q *Queries) GetComputedCost(ctx context.Context, scope []string) (GetComputedCostRow, error) {
	row := q.db.QueryRowContext(ctx, getComputedCost, pq.Array(scope))
	var i GetComputedCostRow
	err := row.Scan(&i.TotalCost, &i.PurchaseCost)
	return i, err
}

const getComputedCostEditorProducts = `-- name: GetComputedCostEditorProducts :many
SELECT SUM(computed_cost + (total_cost-purchase_cost)):: FLOAT AS cost, ocl.editor,ocl.product_names,sku,aggregation_name
FROM overall_computed_licences ocl 
WHERE
cost_optimization = FALSE
  AND scope = ANY($1:: TEXT []) AND editor = $2 GROUP BY ocl.editor,ocl.product_names,ocl.sku,aggregation_name
`

type GetComputedCostEditorProductsParams struct {
	Scope  []string `json:"scope"`
	Editor string   `json:"editor"`
}

type GetComputedCostEditorProductsRow struct {
	Cost            float64 `json:"cost"`
	Editor          string  `json:"editor"`
	ProductNames    string  `json:"product_names"`
	Sku             string  `json:"sku"`
	AggregationName string  `json:"aggregation_name"`
}

func (q *Queries) GetComputedCostEditorProducts(ctx context.Context, arg GetComputedCostEditorProductsParams) ([]GetComputedCostEditorProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getComputedCostEditorProducts, pq.Array(arg.Scope), arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComputedCostEditorProductsRow
	for rows.Next() {
		var i GetComputedCostEditorProductsRow
		if err := rows.Scan(
			&i.Cost,
			&i.Editor,
			&i.ProductNames,
			&i.Sku,
			&i.AggregationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getComputedCostEditors = `-- name: GetComputedCostEditors :many
SELECT SUM(computed_cost + (total_cost-purchase_cost)):: FLOAT AS cost, ocl.editor
FROM overall_computed_licences ocl 
WHERE
cost_optimization = FALSE
  AND scope = ANY($1:: TEXT []) GROUP BY ocl.editor
`

type GetComputedCostEditorsRow struct {
	Cost   float64 `json:"cost"`
	Editor string  `json:"editor"`
}

func (q *Queries) GetComputedCostEditors(ctx context.Context, scope []string) ([]GetComputedCostEditorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getComputedCostEditors, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetComputedCostEditorsRow
	for rows.Next() {
		var i GetComputedCostEditorsRow
		if err := rows.Scan(&i.Cost, &i.Editor); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConcurrentNominativeUsersBySwidTag = `-- name: GetConcurrentNominativeUsersBySwidTag :many

SELECT scope, swidtag
FROM product_concurrent_user
WHERE
    product_concurrent_user.swidtag = ANY($1:: TEXT [])
    AND product_concurrent_user.scope = ANY($2:: TEXT [])
UNION
SELECT scope, swidtag
FROM nominative_user
WHERE
    nominative_user.swidtag = ANY($1:: TEXT [])
    AND nominative_user.scope = ANY($2:: TEXT [])
`

type GetConcurrentNominativeUsersBySwidTagParams struct {
	Swidtag []string `json:"swidtag"`
	Scope   []string `json:"scope"`
}

type GetConcurrentNominativeUsersBySwidTagRow struct {
	Scope   string         `json:"scope"`
	Swidtag sql.NullString `json:"swidtag"`
}

func (q *Queries) GetConcurrentNominativeUsersBySwidTag(ctx context.Context, arg GetConcurrentNominativeUsersBySwidTagParams) ([]GetConcurrentNominativeUsersBySwidTagRow, error) {
	rows, err := q.db.QueryContext(ctx, getConcurrentNominativeUsersBySwidTag, pq.Array(arg.Swidtag), pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConcurrentNominativeUsersBySwidTagRow
	for rows.Next() {
		var i GetConcurrentNominativeUsersBySwidTagRow
		if err := rows.Scan(&i.Scope, &i.Swidtag); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConcurrentUserByID = `-- name: GetConcurrentUserByID :one

SELECT id, is_aggregations, aggregation_id, swidtag, number_of_users, profile_user, team, scope, purchase_date, created_on, created_by, updated_on, updated_by
FROM product_concurrent_user
WHERE scope = $1 AND id = $2
`

type GetConcurrentUserByIDParams struct {
	Scope string `json:"scope"`
	ID    int32  `json:"id"`
}

func (q *Queries) GetConcurrentUserByID(ctx context.Context, arg GetConcurrentUserByIDParams) (ProductConcurrentUser, error) {
	row := q.db.QueryRowContext(ctx, getConcurrentUserByID, arg.Scope, arg.ID)
	var i ProductConcurrentUser
	err := row.Scan(
		&i.ID,
		&i.IsAggregations,
		&i.AggregationID,
		&i.Swidtag,
		&i.NumberOfUsers,
		&i.ProfileUser,
		&i.Team,
		&i.Scope,
		&i.PurchaseDate,
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const getConcurrentUsersByDay = `-- name: GetConcurrentUsersByDay :many

SELECT
    purchase_date,
    SUM(number_of_users) AS totalConUsers
FROM product_concurrent_user
WHERE
    scope = $1
    AND (
        CASE
            WHEN $2:: bool THEN purchase_date >= $3
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN purchase_date <= $5
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $6:: bool THEN swidtag = $7
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN aggregation_id = $9
            ELSE TRUE
        END
    )
GROUP BY purchase_date
`

type GetConcurrentUsersByDayParams struct {
	Scope               string         `json:"scope"`
	IsPurchaseStartDate bool           `json:"is_purchase_start_date"`
	StartDate           time.Time      `json:"start_date"`
	IsPurchaseEndDate   bool           `json:"is_purchase_end_date"`
	EndDate             time.Time      `json:"end_date"`
	IsSwidtag           bool           `json:"is_swidtag"`
	Swidtag             sql.NullString `json:"swidtag"`
	IsAggregationID     bool           `json:"is_aggregation_id"`
	AggregationID       sql.NullInt32  `json:"aggregation_id"`
}

type GetConcurrentUsersByDayRow struct {
	PurchaseDate  time.Time `json:"purchase_date"`
	Totalconusers int64     `json:"totalconusers"`
}

func (q *Queries) GetConcurrentUsersByDay(ctx context.Context, arg GetConcurrentUsersByDayParams) ([]GetConcurrentUsersByDayRow, error) {
	rows, err := q.db.QueryContext(ctx, getConcurrentUsersByDay,
		arg.Scope,
		arg.IsPurchaseStartDate,
		arg.StartDate,
		arg.IsPurchaseEndDate,
		arg.EndDate,
		arg.IsSwidtag,
		arg.Swidtag,
		arg.IsAggregationID,
		arg.AggregationID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConcurrentUsersByDayRow
	for rows.Next() {
		var i GetConcurrentUsersByDayRow
		if err := rows.Scan(&i.PurchaseDate, &i.Totalconusers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConcurrentUsersByMonth = `-- name: GetConcurrentUsersByMonth :many

SELECT
    CONCAT(
        TO_CHAR(purchase_date, 'Month'),
        EXTRACT(
            YEAR
            FROM
                purchase_date
        )
    ) as purchaseMonthYear,
    SUM(number_of_users) AS totalConUsers
FROM product_concurrent_user
WHERE
    scope = $1
    AND (
        CASE
            WHEN $2:: bool THEN purchase_date >= $3
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN purchase_date <= $5
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $6:: bool THEN swidtag = $7
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN aggregation_id = $9
            ELSE TRUE
        END
    )
GROUP BY purchaseMonthYear
`

type GetConcurrentUsersByMonthParams struct {
	Scope               string         `json:"scope"`
	IsPurchaseStartDate bool           `json:"is_purchase_start_date"`
	StartDate           time.Time      `json:"start_date"`
	IsPurchaseEndDate   bool           `json:"is_purchase_end_date"`
	EndDate             time.Time      `json:"end_date"`
	IsSwidtag           bool           `json:"is_swidtag"`
	Swidtag             sql.NullString `json:"swidtag"`
	IsAggregationID     bool           `json:"is_aggregation_id"`
	AggregationID       sql.NullInt32  `json:"aggregation_id"`
}

type GetConcurrentUsersByMonthRow struct {
	Purchasemonthyear interface{} `json:"purchasemonthyear"`
	Totalconusers     int64       `json:"totalconusers"`
}

func (q *Queries) GetConcurrentUsersByMonth(ctx context.Context, arg GetConcurrentUsersByMonthParams) ([]GetConcurrentUsersByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getConcurrentUsersByMonth,
		arg.Scope,
		arg.IsPurchaseStartDate,
		arg.StartDate,
		arg.IsPurchaseEndDate,
		arg.EndDate,
		arg.IsSwidtag,
		arg.Swidtag,
		arg.IsAggregationID,
		arg.AggregationID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConcurrentUsersByMonthRow
	for rows.Next() {
		var i GetConcurrentUsersByMonthRow
		if err := rows.Scan(&i.Purchasemonthyear, &i.Totalconusers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDashboardUpdates = `-- name: GetDashboardUpdates :one

select
    updated_at at time zone $2:: varchar as updated_at,
    next_update_at at time zone $2:: varchar as next_update_at
from dashboard_audit
where scope = $1
`

type GetDashboardUpdatesParams struct {
	Scope   string `json:"scope"`
	Column2 string `json:"column_2"`
}

type GetDashboardUpdatesRow struct {
	UpdatedAt    interface{} `json:"updated_at"`
	NextUpdateAt interface{} `json:"next_update_at"`
}

func (q *Queries) GetDashboardUpdates(ctx context.Context, arg GetDashboardUpdatesParams) (GetDashboardUpdatesRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardUpdates, arg.Scope, arg.Column2)
	var i GetDashboardUpdatesRow
	err := row.Scan(&i.UpdatedAt, &i.NextUpdateAt)
	return i, err
}

const getEditor = `-- name: GetEditor :many
SELECT name from editor_catalog
`

func (q *Queries) GetEditor(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditorExpensesByScopeData = `-- name: GetEditorExpensesByScopeData :many

SELECT
    editor,
    coalesce(SUM(total_purchase_cost), 0.0):: FLOAT as total_purchase_cost,
    coalesce(
        SUM(total_maintenance_cost),
        0.0
    ):: FLOAT as total_maintenance_cost,
    coalesce(SUM(total_cost), 0.0):: FLOAT as total_cost
FROM (
        SELECT
            product_editor as editor,
            total_purchase_cost,
            total_maintenance_cost,
            total_cost
        FROM acqrights
        WHERE
            acqrights.scope = ANY($1:: TEXT [])
        UNION ALL
        SELECT
            a.product_editor as editor,
            ar.total_purchase_cost,
            ar.total_maintenance_cost,
            ar.total_cost
        FROM aggregations as a
            INNER JOIN aggregated_rights as ar ON a.id = ar.aggregation_id
        WHERE
            a.scope = ANY($1:: TEXT [])
    ) as editorExpenseByScopeData
GROUP BY editor
`

type GetEditorExpensesByScopeDataRow struct {
	Editor               string  `json:"editor"`
	TotalPurchaseCost    float64 `json:"total_purchase_cost"`
	TotalMaintenanceCost float64 `json:"total_maintenance_cost"`
	TotalCost            float64 `json:"total_cost"`
}

func (q *Queries) GetEditorExpensesByScopeData(ctx context.Context, scope []string) ([]GetEditorExpensesByScopeDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getEditorExpensesByScopeData, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEditorExpensesByScopeDataRow
	for rows.Next() {
		var i GetEditorExpensesByScopeDataRow
		if err := rows.Scan(
			&i.Editor,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEditorProductExpensesByScopeData = `-- name: GetEditorProductExpensesByScopeData :many

SELECT
    name,
    coalesce(SUM(total_purchase_cost), 0.0):: FLOAT as total_purchase_cost,
    coalesce(
        SUM(total_maintenance_cost),
        0.0
    ):: FLOAT as total_maintenance_cost,
    coalesce(SUM(total_cost), 0.0):: FLOAT as total_cost
FROM (
        SELECT
            product_name as name,
            total_purchase_cost,
            total_maintenance_cost,
            total_cost
        FROM acqrights
        WHERE
            acqrights.scope = ANY($1:: TEXT [])
            and acqrights.product_editor = $2
        UNION ALL
        SELECT
            a.aggregation_name as name,
            ar.total_purchase_cost,
            ar.total_maintenance_cost,
            ar.total_cost
        FROM aggregations as a
            INNER JOIN aggregated_rights as ar ON a.id = ar.aggregation_id
        WHERE
            a.scope = ANY($1:: TEXT []) and a.product_editor = $2
    ) as editorExpenseByScopeData
GROUP BY name
`

type GetEditorProductExpensesByScopeDataParams struct {
	Scope     []string `json:"scope"`
	Reqeditor string   `json:"reqeditor"`
}

type GetEditorProductExpensesByScopeDataRow struct {
	Name                 string  `json:"name"`
	TotalPurchaseCost    float64 `json:"total_purchase_cost"`
	TotalMaintenanceCost float64 `json:"total_maintenance_cost"`
	TotalCost            float64 `json:"total_cost"`
}

func (q *Queries) GetEditorProductExpensesByScopeData(ctx context.Context, arg GetEditorProductExpensesByScopeDataParams) ([]GetEditorProductExpensesByScopeDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getEditorProductExpensesByScopeData, pq.Array(arg.Scope), arg.Reqeditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEditorProductExpensesByScopeDataRow
	for rows.Next() {
		var i GetEditorProductExpensesByScopeDataRow
		if err := rows.Scan(
			&i.Name,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEquipmentsBySwidtag = `-- name: GetEquipmentsBySwidtag :one

SELECT
    ARRAY_AGG(DISTINCT(equipment_id)):: TEXT [] as equipments
from products_equipments
WHERE
    scope = $1
    and swidtag = $2
`

type GetEquipmentsBySwidtagParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

func (q *Queries) GetEquipmentsBySwidtag(ctx context.Context, arg GetEquipmentsBySwidtagParams) ([]string, error) {
	row := q.db.QueryRowContext(ctx, getEquipmentsBySwidtag, arg.Scope, arg.Swidtag)
	var equipments []string
	err := row.Scan(pq.Array(&equipments))
	return equipments, err
}

const getIndividualProductDetailByAggregation = `-- name: GetIndividualProductDetailByAggregation :many

Select
    agg.aggregation_name,
    coalesce(num_of_applications, 0) as num_of_applications,
    coalesce(num_of_equipments, 0) as num_of_equipments,
    agg.product_editor,
    COALESCE(pname,'')::TEXT as name,
    COALESCE(pversion,'')::TEXT as version,
    prod_id,
    COALESCE(ar.total_cost,0)::NUMERIC(15,2) as total_cost
from
	aggregations agg
	LEFT JOIN (
		select 
			p.product_name as pname,
			p.product_version as pversion,
			p.swidtag as prod_id
			from products p 
		    where 
			p.scope =  $1
        UNION
		select
			pc.name as pname,
			v.name as pversion,
			v.swid_tag_system as prod_id
			from product_catalog pc
			left join version_catalog v on pc.id =v.p_id
	) p on prod_id  = ANY(agg.swidtags::TEXT[])
    LEFT JOIN (
        SELECT
            pa.swidtag,
            count(application_id) as num_of_applications
        FROM
            products_applications pa
        WHERE pa.scope = $1
        GROUP BY
            pa.swidtag
    ) pa ON prod_id = pa.swidtag
    LEFT JOIN (
        SELECT
            pe.swidtag,
            count(equipment_id) as num_of_equipments
        FROM
            products_equipments pe
        WHERE pe.scope = $1
        GROUP BY
            pe.swidtag
    ) pe ON prod_id = pe.swidtag
    LEFT JOIN (
        SELECT
            a.aggregation_id,
            SUM(a.total_cost):: Numeric(15, 2) as total_cost
        FROM
            aggregated_rights a
        WHERE a.scope = $1
        GROUP BY
            a.aggregation_id
    ) ar ON ar.aggregation_id = agg.id
WHERE
    agg.scope = $1
    and agg.aggregation_name = $2
`

type GetIndividualProductDetailByAggregationParams struct {
	Scope           string `json:"scope"`
	AggregationName string `json:"aggregation_name"`
}

type GetIndividualProductDetailByAggregationRow struct {
	AggregationName   string          `json:"aggregation_name"`
	NumOfApplications int64           `json:"num_of_applications"`
	NumOfEquipments   int64           `json:"num_of_equipments"`
	ProductEditor     string          `json:"product_editor"`
	Name              string          `json:"name"`
	Version           string          `json:"version"`
	ProdID            string          `json:"prod_id"`
	TotalCost         decimal.Decimal `json:"total_cost"`
}

func (q *Queries) GetIndividualProductDetailByAggregation(ctx context.Context, arg GetIndividualProductDetailByAggregationParams) ([]GetIndividualProductDetailByAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndividualProductDetailByAggregation, arg.Scope, arg.AggregationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndividualProductDetailByAggregationRow
	for rows.Next() {
		var i GetIndividualProductDetailByAggregationRow
		if err := rows.Scan(
			&i.AggregationName,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.ProductEditor,
			&i.Name,
			&i.Version,
			&i.ProdID,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndividualProductForAggregationCount = `-- name: GetIndividualProductForAggregationCount :one
SELECT count(*) 
FROM (
    Select p.product_name from products p WHERE p.scope = $1 
                                                AND p.swidtag = ANY($2::TEXT[])
    UNION
    select v.name from version_catalog v WHERE v.swid_tag_system = ANY($2::TEXT[]) AND v.name != '') t1
`

type GetIndividualProductForAggregationCountParams struct {
	Scope    string   `json:"scope"`
	Swidtags []string `json:"swidtags"`
}

func (q *Queries) GetIndividualProductForAggregationCount(ctx context.Context, arg GetIndividualProductForAggregationCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getIndividualProductForAggregationCount, arg.Scope, pq.Array(arg.Swidtags))
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getJobsInExecution = `-- name: GetJobsInExecution :one
SELECT count(*) FROM jobs WHERE status != 'FAILED' AND status != 'COMPLETED' and ppid = $1
`

func (q *Queries) GetJobsInExecution(ctx context.Context, ppid sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, getJobsInExecution, ppid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLicensesCost = `-- name: GetLicensesCost :one

SELECT
    COALESCE(SUM(total_cost), 0):: Numeric(15, 2) as total_cost,
    COALESCE(
        SUM(total_maintenance_cost),
        0
    ):: Numeric(15, 2) as total_maintenance_cost
FROM (
        SELECT
            SUM(total_cost):: Numeric(15, 2) as total_cost,
            SUM(total_maintenance_cost):: Numeric(15, 2) as total_maintenance_cost
        FROM acqrights
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY scope
        UNION ALL
        SELECT
            SUM(total_cost):: Numeric(15, 2) as total_cost,
            SUM(total_maintenance_cost):: Numeric(15, 2) as total_maintenance_cost
        FROM
            aggregated_rights
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY scope
    ) a
`

type GetLicensesCostRow struct {
	TotalCost            decimal.Decimal `json:"total_cost"`
	TotalMaintenanceCost decimal.Decimal `json:"total_maintenance_cost"`
}

func (q *Queries) GetLicensesCost(ctx context.Context, scope []string) (GetLicensesCostRow, error) {
	row := q.db.QueryRowContext(ctx, getLicensesCost, pq.Array(scope))
	var i GetLicensesCostRow
	err := row.Scan(&i.TotalCost, &i.TotalMaintenanceCost)
	return i, err
}

const getMetricsBySku = `-- name: GetMetricsBySku :one

Select sku, metric
from acqrights acq
where
    acq.sku = $1
    AND acq.scope = $2
UNION
select sku, metric
from aggregated_rights agg
where
    agg.sku = $1
    AND agg.scope = $2
`

type GetMetricsBySkuParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

type GetMetricsBySkuRow struct {
	Sku    string `json:"sku"`
	Metric string `json:"metric"`
}

func (q *Queries) GetMetricsBySku(ctx context.Context, arg GetMetricsBySkuParams) (GetMetricsBySkuRow, error) {
	row := q.db.QueryRowContext(ctx, getMetricsBySku, arg.Sku, arg.Scope)
	var i GetMetricsBySkuRow
	err := row.Scan(&i.Sku, &i.Metric)
	return i, err
}

const getNominativeUserByID = `-- name: GetNominativeUserByID :one

SELECT user_id, scope, swidtag, aggregations_id, activation_date, user_email, user_name, first_name, profile, product_editor, updated_at, created_at, created_by, updated_by FROM nominative_user WHERE scope = $1 AND user_id = $2
`

type GetNominativeUserByIDParams struct {
	Scope string `json:"scope"`
	ID    int32  `json:"id"`
}

func (q *Queries) GetNominativeUserByID(ctx context.Context, arg GetNominativeUserByIDParams) (NominativeUser, error) {
	row := q.db.QueryRowContext(ctx, getNominativeUserByID, arg.Scope, arg.ID)
	var i NominativeUser
	err := row.Scan(
		&i.UserID,
		&i.Scope,
		&i.Swidtag,
		&i.AggregationsID,
		&i.ActivationDate,
		&i.UserEmail,
		&i.UserName,
		&i.FirstName,
		&i.Profile,
		&i.ProductEditor,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
	)
	return i, err
}

const getOpenSourceCloseSourceData = `-- name: GetOpenSourceCloseSourceData :many
SELECT
    COALESCE(sum(openSourceCount),0):: INTEGER as osCount,
    COALESCE(sum(closeSourceCount),0):: INTEGER as csCount
from
    (
        SELECT
            vc.p_id as result
        FROM
            version_catalog vc
            JOIN products p ON vc.swid_tag_system = p.swidtag
        WHERE
            p.scope = $1
        GROUP BY
            vc.p_id
    ) as ver
    JOIN (
        select
            id, name, editorid, genearl_information, contract_tips, support_vendors, metrics, is_opensource, licences_opensource, is_closesource, licenses_closesource, location, created_on, updated_on, useful_links, swid_tag_product, source, editor_name, opensource_type, recommendation, licensing,
            COALESCE(
                COUNT(
                    CASE
                        When licensing = 'OPENSOURCE' Then is_opensource
                    End
                ),
                0
            ) as openSourceCount,
            COALESCE(
                COUNT(
                    CASE
                        When licensing = 'CLOSEDSOURCE' Then is_closesource
                    End
                ),
                0
            ) as closeSourceCount
        from
            product_catalog
        GROUP BY
            id
    ) pc ON pc.id = ver.result
`

type GetOpenSourceCloseSourceDataRow struct {
	Oscount int32 `json:"oscount"`
	Cscount int32 `json:"cscount"`
}

func (q *Queries) GetOpenSourceCloseSourceData(ctx context.Context, scope string) ([]GetOpenSourceCloseSourceDataRow, error) {
	rows, err := q.db.QueryContext(ctx, getOpenSourceCloseSourceData, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOpenSourceCloseSourceDataRow
	for rows.Next() {
		var i GetOpenSourceCloseSourceDataRow
		if err := rows.Scan(&i.Oscount, &i.Cscount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverallCostByProduct = `-- name: GetOverallCostByProduct :many

SELECT
    scope,
    COALESCE(SUM(total_cost),0) :: Numeric(15, 2) as total_cost,
    COALESCE(SUM(
        CASE
            When delta_cost < 0 Then delta_cost
        End
    ),0) :: Numeric(15, 2) as counterfeiting_cost,
    COALESCE(SUM(
        CASE
            When delta_cost > 0 Then delta_cost
        End
    ),0) :: Numeric(15, 2) as underusage_cost
FROM
    overall_computed_licences
WHERE
    product_names = $1
    AND editor = $2
    AND scope = ANY($3 :: TEXT [])
GROUP BY
    scope
`

type GetOverallCostByProductParams struct {
	ProductName string   `json:"product_name"`
	Editor      string   `json:"editor"`
	Scope       []string `json:"scope"`
}

type GetOverallCostByProductRow struct {
	Scope              string          `json:"scope"`
	TotalCost          decimal.Decimal `json:"total_cost"`
	CounterfeitingCost decimal.Decimal `json:"counterfeiting_cost"`
	UnderusageCost     decimal.Decimal `json:"underusage_cost"`
}

func (q *Queries) GetOverallCostByProduct(ctx context.Context, arg GetOverallCostByProductParams) ([]GetOverallCostByProductRow, error) {
	rows, err := q.db.QueryContext(ctx, getOverallCostByProduct, arg.ProductName, arg.Editor, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOverallCostByProductRow
	for rows.Next() {
		var i GetOverallCostByProductRow
		if err := rows.Scan(
			&i.Scope,
			&i.TotalCost,
			&i.CounterfeitingCost,
			&i.UnderusageCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverallLicencesByProduct = `-- name: GetOverallLicencesByProduct :many

SELECT
    scope,
    COALESCE(SUM(num_computed_licences),0) :: Numeric(15, 2) as computed_licences,
    COALESCE(SUM(num_acquired_licences),0) :: Numeric(15, 2) as acquired_licences
FROM
    overall_computed_licences
WHERE
    product_names = $1
    AND editor = $2
    AND scope = ANY($3 :: TEXT [])
GROUP BY
    scope
`

type GetOverallLicencesByProductParams struct {
	ProductName string   `json:"product_name"`
	Editor      string   `json:"editor"`
	Scope       []string `json:"scope"`
}

type GetOverallLicencesByProductRow struct {
	Scope            string          `json:"scope"`
	ComputedLicences decimal.Decimal `json:"computed_licences"`
	AcquiredLicences decimal.Decimal `json:"acquired_licences"`
}

func (q *Queries) GetOverallLicencesByProduct(ctx context.Context, arg GetOverallLicencesByProductParams) ([]GetOverallLicencesByProductRow, error) {
	rows, err := q.db.QueryContext(ctx, getOverallLicencesByProduct, arg.ProductName, arg.Editor, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOverallLicencesByProductRow
	for rows.Next() {
		var i GetOverallLicencesByProductRow
		if err := rows.Scan(&i.Scope, &i.ComputedLicences, &i.AcquiredLicences); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByNameEditor = `-- name: GetProductByNameEditor :many
SELECT swidtag, product_name, product_version, product_edition, product_category, product_editor, scope, option_of, aggregation_id, aggregation_name, created_on, created_by, updated_on, updated_by, product_type from products 
    WHERE 
    product_name=ANY($1:: TEXT [])
    AND product_editor=ANY($2:: TEXT [])
`

type GetProductByNameEditorParams struct {
	ProductName   []string `json:"product_name"`
	ProductEditor []string `json:"product_editor"`
}

func (q *Queries) GetProductByNameEditor(ctx context.Context, arg GetProductByNameEditorParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, getProductByNameEditor, pq.Array(arg.ProductName), pq.Array(arg.ProductEditor))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductEdition,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.Scope,
			&i.OptionOf,
			&i.AggregationID,
			&i.AggregationName,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedOn,
			&i.UpdatedBy,
			&i.ProductType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCount = `-- name: GetProductCount :many

SELECT
    COUNT(pa.swidtag) as num_of_products,
    pa.application_id
FROM products_applications pa
WHERE pa.scope = $1
GROUP BY pa.application_id
`

type GetProductCountRow struct {
	NumOfProducts int64  `json:"num_of_products"`
	ApplicationID string `json:"application_id"`
}

func (q *Queries) GetProductCount(ctx context.Context, scope string) ([]GetProductCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCount, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCountRow
	for rows.Next() {
		var i GetProductCountRow
		if err := rows.Scan(&i.NumOfProducts, &i.ApplicationID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductInformation = `-- name: GetProductInformation :one

SELECT
    p.swidtag,
    p.product_name,
    p.product_editor,
    p.product_version,
    acq.metrics,
    COALESCE(papp.num_of_applications, 0):: INTEGER as num_of_applications,
    COALESCE(peq.num_of_equipments, 0):: INTEGER as num_of_equipments,
    p.product_type
FROM products p
    LEFT JOIN (
        SELECT
            pa.swidtag,
            count(pa.application_id) as num_of_applications
        FROM
            products_applications pa
        WHERE pa.scope = $1
        GROUP BY
            pa.swidtag
    ) papp ON p.swidtag = papp.swidtag
    LEFT JOIN (
        SELECT
            pe.swidtag,
            count(pe.equipment_id) as num_of_equipments
        FROM
            products_equipments pe
        WHERE pe.scope = $1
        GROUP BY
            pe.swidtag
    ) peq ON p.swidtag = peq.swidtag
    LEFT JOIN (
        SELECT
            ac.swidtag,
            ARRAY_AGG(DISTINCT acmetrics):: TEXT [] as metrics
        FROM
            acqrights ac,
            unnest(
                string_to_array(ac.metric, ',')
            ) as acmetrics
        WHERE ac.scope = $1
        GROUP BY
            ac.swidtag
    ) acq ON p.swidtag = acq.swidtag
WHERE
    p.swidtag = $2
    AND p.scope = $1
GROUP BY
    p.swidtag,
    p.product_name,
    p.product_editor,
    p.product_version,
    acq.metrics,
    papp.num_of_applications,
    peq.num_of_equipments,
    p.product_type
`

type GetProductInformationParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

type GetProductInformationRow struct {
	Swidtag           string      `json:"swidtag"`
	ProductName       string      `json:"product_name"`
	ProductEditor     string      `json:"product_editor"`
	ProductVersion    string      `json:"product_version"`
	Metrics           []string    `json:"metrics"`
	NumOfApplications int32       `json:"num_of_applications"`
	NumOfEquipments   int32       `json:"num_of_equipments"`
	ProductType       ProductType `json:"product_type"`
}

func (q *Queries) GetProductInformation(ctx context.Context, arg GetProductInformationParams) (GetProductInformationRow, error) {
	row := q.db.QueryRowContext(ctx, getProductInformation, arg.Scope, arg.Swidtag)
	var i GetProductInformationRow
	err := row.Scan(
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.ProductVersion,
		pq.Array(&i.Metrics),
		&i.NumOfApplications,
		&i.NumOfEquipments,
		&i.ProductType,
	)
	return i, err
}

const getProductInformationFromAcqright = `-- name: GetProductInformationFromAcqright :one
SELECT ac.swidtag,
       ac.product_name,
       ac.product_editor,
       ac.version,
       p.swid_tag_product as product_swid_tag,
       v.swid_tag_version as version_swid_tag,
       ARRAY_AGG(DISTINCT acmetrics)::TEXT[] as metrics
FROM acqrights ac
Left JOIN product_catalog p ON ac.product_name = p.name AND ac.product_editor = p.editor_name
Left JOIN version_catalog v ON p.id = v.p_id  AND v.name = ac.version,
unnest(string_to_array(ac.metric,',')) as acmetrics
WHERE ac.scope = $1
    AND ac.swidtag = $2
GROUP BY ac.swidtag,
         ac.product_name,
         ac.product_editor,
         ac.version,
         p.swid_tag_product,
         v.swid_tag_version
`

type GetProductInformationFromAcqrightParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

type GetProductInformationFromAcqrightRow struct {
	Swidtag        string         `json:"swidtag"`
	ProductName    string         `json:"product_name"`
	ProductEditor  string         `json:"product_editor"`
	Version        string         `json:"version"`
	ProductSwidTag sql.NullString `json:"product_swid_tag"`
	VersionSwidTag sql.NullString `json:"version_swid_tag"`
	Metrics        []string       `json:"metrics"`
}

func (q *Queries) GetProductInformationFromAcqright(ctx context.Context, arg GetProductInformationFromAcqrightParams) (GetProductInformationFromAcqrightRow, error) {
	row := q.db.QueryRowContext(ctx, getProductInformationFromAcqright, arg.Scope, arg.Swidtag)
	var i GetProductInformationFromAcqrightRow
	err := row.Scan(
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.Version,
		&i.ProductSwidTag,
		&i.VersionSwidTag,
		pq.Array(&i.Metrics),
	)
	return i, err
}

const getProductInformationFromAcqrightForAll = `-- name: GetProductInformationFromAcqrightForAll :one
SELECT ac.swidtag,
       ac.product_name,
       ac.product_editor,
       ac.version,
       p.swid_tag_product as product_swid_tag,
       v.swid_tag_version as version_swid_tag,
       ARRAY_AGG(DISTINCT acmetrics)::TEXT[] as metrics
FROM acqrights ac
Left JOIN product_catalog p ON ac.product_name = p.name AND ac.product_editor = p.editor_name
Left JOIN version_catalog v ON p.id = v.p_id  AND v.name = ac.version,
unnest(string_to_array(ac.metric,',')) as acmetrics
WHERE ac.scope = $1
    AND lower(ac.swidtag) = $2
GROUP BY ac.swidtag,
         ac.product_name,
         ac.product_editor,
         ac.version,
         p.swid_tag_product,
         v.swid_tag_version
`

type GetProductInformationFromAcqrightForAllParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

type GetProductInformationFromAcqrightForAllRow struct {
	Swidtag        string         `json:"swidtag"`
	ProductName    string         `json:"product_name"`
	ProductEditor  string         `json:"product_editor"`
	Version        string         `json:"version"`
	ProductSwidTag sql.NullString `json:"product_swid_tag"`
	VersionSwidTag sql.NullString `json:"version_swid_tag"`
	Metrics        []string       `json:"metrics"`
}

func (q *Queries) GetProductInformationFromAcqrightForAll(ctx context.Context, arg GetProductInformationFromAcqrightForAllParams) (GetProductInformationFromAcqrightForAllRow, error) {
	row := q.db.QueryRowContext(ctx, getProductInformationFromAcqrightForAll, arg.Scope, arg.Swidtag)
	var i GetProductInformationFromAcqrightForAllRow
	err := row.Scan(
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.Version,
		&i.ProductSwidTag,
		&i.VersionSwidTag,
		pq.Array(&i.Metrics),
	)
	return i, err
}

const getProductListByEditor = `-- name: GetProductListByEditor :many

SELECT
    DISTINCT p.product_name
FROM
    products as p
where
    p.product_editor = $1
    AND p.scope = ANY($2 :: TEXT [])
UNION
SELECT
    acq.product_name
FROM
    acqrights as acq
where
    acq.product_editor = $1
    AND acq.scope = ANY($2 :: TEXT [])
`

type GetProductListByEditorParams struct {
	Editor string   `json:"editor"`
	Scope  []string `json:"scope"`
}

func (q *Queries) GetProductListByEditor(ctx context.Context, arg GetProductListByEditorParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getProductListByEditor, arg.Editor, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_name string
		if err := rows.Scan(&product_name); err != nil {
			return nil, err
		}
		items = append(items, product_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductOptions = `-- name: GetProductOptions :many

SELECT
    p.swidtag,
    p.product_name,
    p.product_edition,
    p.product_editor,
    p.product_version
FROM products p
WHERE
    p.option_of = $1
    AND p.scope = $2
`

type GetProductOptionsParams struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

type GetProductOptionsRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEdition string `json:"product_edition"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductOptions(ctx context.Context, arg GetProductOptionsParams) ([]GetProductOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductOptions, arg.Swidtag, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductOptionsRow
	for rows.Next() {
		var i GetProductOptionsRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEdition,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSkuExipredMaintenance = `-- name: GetProductSkuExipredMaintenance :many
select product_name,sku, end_of_maintenance from acqrights 
where scope=ANY($1:: TEXT []) and end_of_maintenance = CURRENT_DATE - INTERVAL '1 day'
`

type GetProductSkuExipredMaintenanceRow struct {
	ProductName      string       `json:"product_name"`
	Sku              string       `json:"sku"`
	EndOfMaintenance sql.NullTime `json:"end_of_maintenance"`
}

func (q *Queries) GetProductSkuExipredMaintenance(ctx context.Context, scope []string) ([]GetProductSkuExipredMaintenanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductSkuExipredMaintenance, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductSkuExipredMaintenanceRow
	for rows.Next() {
		var i GetProductSkuExipredMaintenanceRow
		if err := rows.Scan(&i.ProductName, &i.Sku, &i.EndOfMaintenance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductSkuExpiringSoonMaintenance = `-- name: GetProductSkuExpiringSoonMaintenance :many
select product_name,sku, end_of_maintenance from acqrights 
where scope=ANY($1:: TEXT []) AND end_of_maintenance = CURRENT_DATE + INTERVAL '1 month'
`

type GetProductSkuExpiringSoonMaintenanceRow struct {
	ProductName      string       `json:"product_name"`
	Sku              string       `json:"sku"`
	EndOfMaintenance sql.NullTime `json:"end_of_maintenance"`
}

func (q *Queries) GetProductSkuExpiringSoonMaintenance(ctx context.Context, scope []string) ([]GetProductSkuExpiringSoonMaintenanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductSkuExpiringSoonMaintenance, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductSkuExpiringSoonMaintenanceRow
	for rows.Next() {
		var i GetProductSkuExpiringSoonMaintenanceRow
		if err := rows.Scan(&i.ProductName, &i.Sku, &i.EndOfMaintenance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByApplicationID = `-- name: GetProductsByApplicationID :many

SELECT swidtag
from products_applications
WHERE
    scope = $1
    AND application_id = $2
`

type GetProductsByApplicationIDParams struct {
	Scope         string `json:"scope"`
	ApplicationID string `json:"application_id"`
}

func (q *Queries) GetProductsByApplicationID(ctx context.Context, arg GetProductsByApplicationIDParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByApplicationID, arg.Scope, arg.ApplicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var swidtag string
		if err := rows.Scan(&swidtag); err != nil {
			return nil, err
		}
		items = append(items, swidtag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByEditor = `-- name: GetProductsByEditor :many

SELECT
    p.swidtag swidtag,
    p.product_name product_name,
    p.product_version product_version
FROM products p
    LEFT JOIN (
        SELECT swidtag
        FROM
            products_equipments
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) pe ON p.swidtag = pe.swidtag
WHERE
    p.product_editor = $2
    and p.scope = ANY($1:: TEXT [])
UNION
select
    vc.swid_tag_system swidtag,
    pc.name product_name,
    vc.name product_version
from product_catalog pc
    left join version_catalog vc on pc.id = vc.p_id
    left join editor_catalog ec on pc.editorid = ec.id
WHERE ec.name = $2
`

type GetProductsByEditorParams struct {
	Scopes        []string `json:"scopes"`
	ProductEditor string   `json:"product_editor"`
}

type GetProductsByEditorRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductsByEditor(ctx context.Context, arg GetProductsByEditorParams) ([]GetProductsByEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByEditor, pq.Array(arg.Scopes), arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByEditorRow
	for rows.Next() {
		var i GetProductsByEditorRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName, &i.ProductVersion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByEditorScope = `-- name: GetProductsByEditorScope :many

SELECT
    p.swidtag,
    p.product_name,
    p.product_version
FROM products p
    LEFT JOIN (
        SELECT swidtag
        FROM
            products_equipments
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) pe ON p.swidtag = pe.swidtag
WHERE
    p.product_editor = $2
    and p.scope = ANY($1:: TEXT [])
`

type GetProductsByEditorScopeParams struct {
	Scopes        []string `json:"scopes"`
	ProductEditor string   `json:"product_editor"`
}

type GetProductsByEditorScopeRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductsByEditorScope(ctx context.Context, arg GetProductsByEditorScopeParams) ([]GetProductsByEditorScopeRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByEditorScope, pq.Array(arg.Scopes), arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByEditorScopeRow
	for rows.Next() {
		var i GetProductsByEditorScopeRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName, &i.ProductVersion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScopeCounterfietAmountEditor = `-- name: GetScopeCounterfietAmountEditor :many
SELECT coalesce(sum(ocl.delta_cost), 0.0) :: FLOAT AS cost, ocl.scope
FROM overall_computed_licences ocl
WHERE
 ocl.delta_cost < 0
 AND cost_optimization = FALSE
 AND editor = $2
 AND scope = ANY($1::text[])
GROUP BY
 ocl.scope
`

type GetScopeCounterfietAmountEditorParams struct {
	Column1 []string `json:"column_1"`
	Editor  string   `json:"editor"`
}

type GetScopeCounterfietAmountEditorRow struct {
	Cost  float64 `json:"cost"`
	Scope string  `json:"scope"`
}

func (q *Queries) GetScopeCounterfietAmountEditor(ctx context.Context, arg GetScopeCounterfietAmountEditorParams) ([]GetScopeCounterfietAmountEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getScopeCounterfietAmountEditor, pq.Array(arg.Column1), arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScopeCounterfietAmountEditorRow
	for rows.Next() {
		var i GetScopeCounterfietAmountEditorRow
		if err := rows.Scan(&i.Cost, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScopeTotalAmountEditor = `-- name: GetScopeTotalAmountEditor :many
SELECT coalesce(sum(ocl.total_cost), 0.0) :: FLOAT AS cost, ocl.scope
FROM overall_computed_licences ocl
WHERE
cost_optimization = FALSE
 AND editor = $2
  AND scope = ANY($1::text[])
GROUP BY
 ocl.scope
`

type GetScopeTotalAmountEditorParams struct {
	Column1 []string `json:"column_1"`
	Editor  string   `json:"editor"`
}

type GetScopeTotalAmountEditorRow struct {
	Cost  float64 `json:"cost"`
	Scope string  `json:"scope"`
}

func (q *Queries) GetScopeTotalAmountEditor(ctx context.Context, arg GetScopeTotalAmountEditorParams) ([]GetScopeTotalAmountEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getScopeTotalAmountEditor, pq.Array(arg.Column1), arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScopeTotalAmountEditorRow
	for rows.Next() {
		var i GetScopeTotalAmountEditorRow
		if err := rows.Scan(&i.Cost, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScopeUnderUsageCostEditor = `-- name: GetScopeUnderUsageCostEditor :many
SELECT coalesce(sum(ocl.delta_cost), 0.0) :: FLOAT AS cost, ocl.scope
FROM overall_computed_licences ocl
WHERE
 ocl.delta_cost > 0
 AND cost_optimization = FALSE
 AND editor = $2
 AND scope = ANY($1::text[])
GROUP BY
 ocl.scope
`

type GetScopeUnderUsageCostEditorParams struct {
	Column1 []string `json:"column_1"`
	Editor  string   `json:"editor"`
}

type GetScopeUnderUsageCostEditorRow struct {
	Cost  float64 `json:"cost"`
	Scope string  `json:"scope"`
}

func (q *Queries) GetScopeUnderUsageCostEditor(ctx context.Context, arg GetScopeUnderUsageCostEditorParams) ([]GetScopeUnderUsageCostEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getScopeUnderUsageCostEditor, pq.Array(arg.Column1), arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScopeUnderUsageCostEditorRow
	for rows.Next() {
		var i GetScopeUnderUsageCostEditorRow
		if err := rows.Scan(&i.Cost, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedData = `-- name: GetSharedData :many

Select sku, scope, sharing_scope, shared_licences, recieved_licences from shared_licenses where scope = $1
`

func (q *Queries) GetSharedData(ctx context.Context, scope string) ([]SharedLicense, error) {
	rows, err := q.db.QueryContext(ctx, getSharedData, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SharedLicense
	for rows.Next() {
		var i SharedLicense
		if err := rows.Scan(
			&i.Sku,
			&i.Scope,
			&i.SharingScope,
			&i.SharedLicences,
			&i.RecievedLicences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedLicenses = `-- name: GetSharedLicenses :many

Select sku, scope, sharing_scope, shared_licences, recieved_licences
FROM shared_licenses
where sku = $1 AND scope = $2
Group By
    sku,
    scope,
    sharing_scope
HAVING
    shared_licences > 0
    OR recieved_licences > 0
`

type GetSharedLicensesParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

func (q *Queries) GetSharedLicenses(ctx context.Context, arg GetSharedLicensesParams) ([]SharedLicense, error) {
	rows, err := q.db.QueryContext(ctx, getSharedLicenses, arg.Sku, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SharedLicense
	for rows.Next() {
		var i SharedLicense
		if err := rows.Scan(
			&i.Sku,
			&i.Scope,
			&i.SharingScope,
			&i.SharedLicences,
			&i.RecievedLicences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalCounterfietAmount = `-- name: GetTotalCounterfietAmount :one

select
    coalesce(sum(ocl.delta_cost), 0.0):: FLOAT as counterfiet_amount
from
    overall_computed_licences ocl
where
    ocl.scope = $1
    AND ocl.delta_cost < 0
    AND cost_optimization = FALSE
`

func (q *Queries) GetTotalCounterfietAmount(ctx context.Context, scope string) (float64, error) {
	row := q.db.QueryRowContext(ctx, getTotalCounterfietAmount, scope)
	var counterfiet_amount float64
	err := row.Scan(&counterfiet_amount)
	return counterfiet_amount, err
}

const getTotalDeltaCost = `-- name: GetTotalDeltaCost :one

select
    coalesce(sum(ocl.delta_cost), 0.0):: FLOAT
FROM
    overall_computed_licences ocl
where
    cost_optimization = TRUE
    AND ocl.scope = $1
`

func (q *Queries) GetTotalDeltaCost(ctx context.Context, scope string) (float64, error) {
	row := q.db.QueryRowContext(ctx, getTotalDeltaCost, scope)
	var column_1 float64
	err := row.Scan(&column_1)
	return column_1, err
}

const getTotalSharedLicenses = `-- name: GetTotalSharedLicenses :one

Select
    COALESCE(SUM(shared_licences), 0):: INTEGER as total_shared_licences,
    COALESCE(SUM(recieved_licences), 0):: INTEGER as total_recieved_licences
FROM shared_licenses
where sku = $1 AND scope = $2
`

type GetTotalSharedLicensesParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

type GetTotalSharedLicensesRow struct {
	TotalSharedLicences   int32 `json:"total_shared_licences"`
	TotalRecievedLicences int32 `json:"total_recieved_licences"`
}

func (q *Queries) GetTotalSharedLicenses(ctx context.Context, arg GetTotalSharedLicensesParams) (GetTotalSharedLicensesRow, error) {
	row := q.db.QueryRowContext(ctx, getTotalSharedLicenses, arg.Sku, arg.Scope)
	var i GetTotalSharedLicensesRow
	err := row.Scan(&i.TotalSharedLicences, &i.TotalRecievedLicences)
	return i, err
}

const getTotalUnderusageAmount = `-- name: GetTotalUnderusageAmount :one

select
    coalesce(sum(ocl.delta_cost), 0.0):: FLOAT as underusage_amount
from
    overall_computed_licences ocl
where
    ocl.scope = $1
    AND ocl.delta_cost > 0
    AND cost_optimization = FALSE
`

func (q *Queries) GetTotalUnderusageAmount(ctx context.Context, scope string) (float64, error) {
	row := q.db.QueryRowContext(ctx, getTotalUnderusageAmount, scope)
	var underusage_amount float64
	err := row.Scan(&underusage_amount)
	return underusage_amount, err
}

const getUnitPriceBySku = `-- name: GetUnitPriceBySku :one

Select
    ac.sku,
    ac.avg_unit_price
from acqrights ac
where
    ac.scope = $1
    and ac.sku = $2
union
SELECT
    ag.sku,
    ag.avg_unit_price
from aggregated_rights ag
where
    ag.scope = $1
    and ag.sku = $2
`

type GetUnitPriceBySkuParams struct {
	Scope string `json:"scope"`
	Sku   string `json:"sku"`
}

type GetUnitPriceBySkuRow struct {
	Sku          string          `json:"sku"`
	AvgUnitPrice decimal.Decimal `json:"avg_unit_price"`
}

func (q *Queries) GetUnitPriceBySku(ctx context.Context, arg GetUnitPriceBySkuParams) (GetUnitPriceBySkuRow, error) {
	row := q.db.QueryRowContext(ctx, getUnitPriceBySku, arg.Scope, arg.Sku)
	var i GetUnitPriceBySkuRow
	err := row.Scan(&i.Sku, &i.AvgUnitPrice)
	return i, err
}

const insertAggregation = `-- name: InsertAggregation :one

INSERT INTO
    aggregations (
        aggregation_name,
        scope,
        product_editor,
        products,
        swidtags,
        created_by
    )
VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type InsertAggregationParams struct {
	AggregationName string   `json:"aggregation_name"`
	Scope           string   `json:"scope"`
	ProductEditor   string   `json:"product_editor"`
	Products        []string `json:"products"`
	Swidtags        []string `json:"swidtags"`
	CreatedBy       string   `json:"created_by"`
}

func (q *Queries) InsertAggregation(ctx context.Context, arg InsertAggregationParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertAggregation,
		arg.AggregationName,
		arg.Scope,
		arg.ProductEditor,
		pq.Array(arg.Products),
		pq.Array(arg.Swidtags),
		arg.CreatedBy,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertNominativeUserFileUploadDetails = `-- name: InsertNominativeUserFileUploadDetails :exec

INSERT INTO
    nominative_user_file_uploaded_details (
        upload_id,
        scope,
        swidtag,
        aggregations_id,
        product_editor,
        uploaded_by,
        nominative_users_details,
        record_succeed,
        record_failed,
        file_name,
        sheet_name,
        file_status,
        ppid
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    )
`

type InsertNominativeUserFileUploadDetailsParams struct {
	UploadID               string                `json:"upload_id"`
	Scope                  string                `json:"scope"`
	Swidtag                sql.NullString        `json:"swidtag"`
	AggregationsID         sql.NullInt32         `json:"aggregations_id"`
	ProductEditor          sql.NullString        `json:"product_editor"`
	UploadedBy             string                `json:"uploaded_by"`
	NominativeUsersDetails pqtype.NullRawMessage `json:"nominative_users_details"`
	RecordSucceed          sql.NullInt32         `json:"record_succeed"`
	RecordFailed           sql.NullInt32         `json:"record_failed"`
	FileName               sql.NullString        `json:"file_name"`
	SheetName              sql.NullString        `json:"sheet_name"`
	FileStatus             FileStatus            `json:"file_status"`
	Ppid                   sql.NullString        `json:"ppid"`
}

func (q *Queries) InsertNominativeUserFileUploadDetails(ctx context.Context, arg InsertNominativeUserFileUploadDetailsParams) error {
	_, err := q.db.ExecContext(ctx, insertNominativeUserFileUploadDetails,
		arg.UploadID,
		arg.Scope,
		arg.Swidtag,
		arg.AggregationsID,
		arg.ProductEditor,
		arg.UploadedBy,
		arg.NominativeUsersDetails,
		arg.RecordSucceed,
		arg.RecordFailed,
		arg.FileName,
		arg.SheetName,
		arg.FileStatus,
		arg.Ppid,
	)
	return err
}

const insertOverAllComputedLicences = `-- name: InsertOverAllComputedLicences :exec

INSERT INTO
    overall_computed_licences (
        sku,
        swidtags,
        scope,
        product_names,
        aggregation_name,
        metrics,
        num_computed_licences,
        num_acquired_licences,
        total_cost,
        purchase_cost,
        computed_cost,
        delta_number,
        cost_optimization,
        delta_cost,
        avg_unit_price,
        computed_details,
        metic_not_defined,
        not_deployed,
        editor
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19
    ) ON CONFLICT (
        sku,
        swidtags,
        scope
    )
DO
UPDATE
SET
    product_names = $4,
    aggregation_name = $5,
    metrics = $6,
    num_computed_licences = $7,
    num_acquired_licences = $8,
    total_cost = $9,
    purchase_cost = $10,
    computed_cost = $11,
    delta_number = $12,
    cost_optimization = $13,
    delta_cost = $14,
    computed_details = $16,
    metic_not_defined = $17,
    not_deployed = $18
`

type InsertOverAllComputedLicencesParams struct {
	Sku                 string          `json:"sku"`
	Swidtags            string          `json:"swidtags"`
	Scope               string          `json:"scope"`
	ProductNames        string          `json:"product_names"`
	AggregationName     string          `json:"aggregation_name"`
	Metrics             string          `json:"metrics"`
	NumComputedLicences int32           `json:"num_computed_licences"`
	NumAcquiredLicences int32           `json:"num_acquired_licences"`
	TotalCost           decimal.Decimal `json:"total_cost"`
	PurchaseCost        decimal.Decimal `json:"purchase_cost"`
	ComputedCost        decimal.Decimal `json:"computed_cost"`
	DeltaNumber         int32           `json:"delta_number"`
	CostOptimization    sql.NullBool    `json:"cost_optimization"`
	DeltaCost           decimal.Decimal `json:"delta_cost"`
	AvgUnitPrice        decimal.Decimal `json:"avg_unit_price"`
	ComputedDetails     string          `json:"computed_details"`
	MeticNotDefined     sql.NullBool    `json:"metic_not_defined"`
	NotDeployed         sql.NullBool    `json:"not_deployed"`
	Editor              string          `json:"editor"`
}

func (q *Queries) InsertOverAllComputedLicences(ctx context.Context, arg InsertOverAllComputedLicencesParams) error {
	_, err := q.db.ExecContext(ctx, insertOverAllComputedLicences,
		arg.Sku,
		arg.Swidtags,
		arg.Scope,
		arg.ProductNames,
		arg.AggregationName,
		arg.Metrics,
		arg.NumComputedLicences,
		arg.NumAcquiredLicences,
		arg.TotalCost,
		arg.PurchaseCost,
		arg.ComputedCost,
		arg.DeltaNumber,
		arg.CostOptimization,
		arg.DeltaCost,
		arg.AvgUnitPrice,
		arg.ComputedDetails,
		arg.MeticNotDefined,
		arg.NotDeployed,
		arg.Editor,
	)
	return err
}

const listAcqRightsAggregation = `-- name: ListAcqRightsAggregation :many

SELECT
    count(*) OVER() AS totalRecords,
    a.sku,
    a.aggregation_id,
    a.metric,
    a.ordering_date,
    a.corporate_sourcing_contract,
    a.software_provider,
    a.scope,
    a.num_licenses_acquired,
    a.num_licences_computed,
    a.num_licences_maintenance,
    a.avg_unit_price,
    a.avg_maintenance_unit_price,
    a.total_purchase_cost,
    a.total_computed_cost,
    a.total_maintenance_cost,
    a.total_cost,
    a.start_of_maintenance,
    a.end_of_maintenance,
    a.last_purchased_order,
    a.support_numbers,
    a.maintenance_provider,
    a.comment,
    a.created_on,
    a.created_by,
    a.updated_on,
    a.updated_by,
    a.file_name,
    a.repartition,
    agg.aggregation_name,
    agg.product_editor,
    agg.products,
    agg.swidtags,
    ec.id as editor_id,
    agg.mapping
from
    aggregated_rights a
    LEFT JOIN (
        SELECT
            ag.id,
            ag.aggregation_name,
            ag.scope,
            ag.product_editor,
            ag.products,
            ag.swidtags,
            (
                Select
                    coalesce(
                        (
                            SELECT
                                array_to_json(array_agg(row_to_json(mapping)))
                            from
                                (
                                    SELECT
                                        products.product_name,
                                        products.product_version
                                    FROM
                                        products
                                    where
                                        swidtag in (
                                            SELECT
                                                UNNEST (ag.swidtags)
                                        )
                                    UNION
                                    select
                                        pc.name product_name,
                                        vc.name product_version
                                    from
                                        product_catalog pc
                                        join version_catalog vc on pc.id = vc.p_id
                                    where
                                        vc.swid_tag_system in (
                                            SELECT
                                                UNNEST (ag.swidtags)
                                        )
                                    UNION
                                    SELECT
                                        acqrights.product_name,
                                        acqrights.version
                                    FROM
                                        acqrights
                                    where
                                        swidtag in (
                                            SELECT
                                                UNNEST (ag.swidtags)
                                        )
                                ) as mapping
                        ),
                        '[]' :: json
                    ) 
            ) as mapping
        FROM
            aggregations ag
        WHERE
            ag.scope = $1
        GROUP BY
            ag.id
    ) agg ON agg.id = a.aggregation_id
    LEFT JOIN editor_catalog as ec on ec.name = agg.product_editor
WHERE a.scope = $1
  AND (CASE WHEN $2::bool THEN lower(agg.aggregation_name) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(agg.aggregation_name) LIKE '%' || lower($3) || '%' ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(agg.product_editor) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(agg.product_editor) LIKE '%' || lower($6) || '%' ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(a.sku) = lower($9) ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(a.sku) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower($12) = any(string_to_array(lower(a.metric) , ',') :: text[]) ELSE TRUE END)
  AND (CASE WHEN $13::bool THEN lower(a.metric) LIKE '%' || lower($12::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN a.ordering_date <= $15 ELSE TRUE END)
  AND (CASE WHEN $16::bool THEN lower(a.software_provider) LIKE '%' || lower($17::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $18::bool THEN lower(a.software_provider) = lower($17) ELSE TRUE END)
  ORDER BY
  CASE WHEN $19::bool THEN ARRAY_Length(agg.swidtags, 1) END asc,
  CASE WHEN $20::bool THEN ARRAY_Length(agg.swidtags, 1) END desc,
  CASE WHEN $21::bool THEN agg.aggregation_name END asc,
  CASE WHEN $22::bool THEN agg.aggregation_name END desc,
  CASE WHEN $23::bool THEN agg.product_editor END asc,
  CASE WHEN $24::bool THEN agg.product_editor END desc,
  CASE WHEN $25::bool THEN a.sku END asc,
  CASE WHEN $26::bool THEN a.sku END desc,
  CASE WHEN $27::bool THEN a.metric END asc,
  CASE WHEN $28::bool THEN a.metric END desc,
  CASE WHEN $29::bool THEN a.num_licenses_acquired END asc,
  CASE WHEN $30::bool THEN a.num_licenses_acquired END desc,
  CASE WHEN $31::bool THEN a.num_licences_maintenance END asc,
  CASE WHEN $32::bool THEN a.num_licences_maintenance END desc,
  CASE WHEN $33::bool THEN a.avg_unit_price END asc,
  CASE WHEN $34::bool THEN a.avg_unit_price END desc,  
  CASE WHEN $35::bool THEN a.avg_maintenance_unit_price END asc,
  CASE WHEN $36::bool THEN a.avg_maintenance_unit_price END desc,
  CASE WHEN $37::bool THEN a.total_purchase_cost END asc,
  CASE WHEN $38::bool THEN a.total_purchase_cost END desc,
  CASE WHEN $39::bool THEN a.total_maintenance_cost END asc,
  CASE WHEN $40::bool THEN a.total_maintenance_cost END desc,
  CASE WHEN $41::bool THEN a.total_cost END asc,
  CASE WHEN $42::bool THEN a.total_cost END desc,
  CASE WHEN $43::bool THEN a.start_of_maintenance END asc,
  CASE WHEN $44::bool THEN a.start_of_maintenance END desc,
  CASE WHEN $45::bool THEN a.end_of_maintenance END asc,
  CASE WHEN $46::bool THEN a.end_of_maintenance END desc,
  CASE WHEN $47::bool THEN age(end_of_maintenance, start_of_maintenance) END desc,
  CASE WHEN $48::bool  THEN age(end_of_maintenance, start_of_maintenance) END asc
LIMIT $50 OFFSET $49
`

type ListAcqRightsAggregationParams struct {
	Scope                       string       `json:"scope"`
	IsAggName                   bool         `json:"is_agg_name"`
	AggregationName             string       `json:"aggregation_name"`
	LkAggName                   bool         `json:"lk_agg_name"`
	IsEditor                    bool         `json:"is_editor"`
	ProductEditor               string       `json:"product_editor"`
	LkEditor                    bool         `json:"lk_editor"`
	IsSku                       bool         `json:"is_sku"`
	Sku                         string       `json:"sku"`
	LkSku                       bool         `json:"lk_sku"`
	IsMetric                    bool         `json:"is_metric"`
	Metric                      string       `json:"metric"`
	LkMetric                    bool         `json:"lk_metric"`
	IsOrderingDate              bool         `json:"is_ordering_date"`
	OrderingDate                sql.NullTime `json:"ordering_date"`
	LkSoftwareProvider          bool         `json:"lk_software_provider"`
	SoftwareProvider            string       `json:"software_provider"`
	IsSoftwareProvider          bool         `json:"is_software_provider"`
	SwidtagAsc                  bool         `json:"swidtag_asc"`
	SwidtagDesc                 bool         `json:"swidtag_desc"`
	AggNameAsc                  bool         `json:"agg_name_asc"`
	AggNameDesc                 bool         `json:"agg_name_desc"`
	ProductEditorAsc            bool         `json:"product_editor_asc"`
	ProductEditorDesc           bool         `json:"product_editor_desc"`
	SkuAsc                      bool         `json:"sku_asc"`
	SkuDesc                     bool         `json:"sku_desc"`
	MetricAsc                   bool         `json:"metric_asc"`
	MetricDesc                  bool         `json:"metric_desc"`
	NumLicensesAcquiredAsc      bool         `json:"num_licenses_acquired_asc"`
	NumLicensesAcquiredDesc     bool         `json:"num_licenses_acquired_desc"`
	NumLicencesMaintenanceAsc   bool         `json:"num_licences_maintenance_asc"`
	NumLicencesMaintenanceDesc  bool         `json:"num_licences_maintenance_desc"`
	AvgUnitPriceAsc             bool         `json:"avg_unit_price_asc"`
	AvgUnitPriceDesc            bool         `json:"avg_unit_price_desc"`
	AvgMaintenanceUnitPriceAsc  bool         `json:"avg_maintenance_unit_price_asc"`
	AvgMaintenanceUnitPriceDesc bool         `json:"avg_maintenance_unit_price_desc"`
	TotalPurchaseCostAsc        bool         `json:"total_purchase_cost_asc"`
	TotalPurchaseCostDesc       bool         `json:"total_purchase_cost_desc"`
	TotalMaintenanceCostAsc     bool         `json:"total_maintenance_cost_asc"`
	TotalMaintenanceCostDesc    bool         `json:"total_maintenance_cost_desc"`
	TotalCostAsc                bool         `json:"total_cost_asc"`
	TotalCostDesc               bool         `json:"total_cost_desc"`
	StartOfMaintenanceAsc       bool         `json:"start_of_maintenance_asc"`
	StartOfMaintenanceDesc      bool         `json:"start_of_maintenance_desc"`
	EndOfMaintenanceAsc         bool         `json:"end_of_maintenance_asc"`
	EndOfMaintenanceDesc        bool         `json:"end_of_maintenance_desc"`
	LicenseUnderMaintenanceAsc  bool         `json:"license_under_maintenance_asc"`
	LicenseUnderMaintenanceDesc bool         `json:"license_under_maintenance_desc"`
	PageNum                     int32        `json:"page_num"`
	PageSize                    int32        `json:"page_size"`
}

type ListAcqRightsAggregationRow struct {
	Totalrecords              int64           `json:"totalrecords"`
	Sku                       string          `json:"sku"`
	AggregationID             int32           `json:"aggregation_id"`
	Metric                    string          `json:"metric"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	SoftwareProvider          string          `json:"software_provider"`
	Scope                     string          `json:"scope"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	NumLicencesComputed       int32           `json:"num_licences_computed"`
	NumLicencesMaintenance    int32           `json:"num_licences_maintenance"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost         decimal.Decimal `json:"total_computed_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	Comment                   sql.NullString  `json:"comment"`
	CreatedOn                 time.Time       `json:"created_on"`
	CreatedBy                 string          `json:"created_by"`
	UpdatedOn                 time.Time       `json:"updated_on"`
	UpdatedBy                 sql.NullString  `json:"updated_by"`
	FileName                  string          `json:"file_name"`
	Repartition               bool            `json:"repartition"`
	AggregationName           string          `json:"aggregation_name"`
	ProductEditor             string          `json:"product_editor"`
	Products                  []string        `json:"products"`
	Swidtags                  []string        `json:"swidtags"`
	EditorID                  sql.NullString  `json:"editor_id"`
	Mapping                   interface{}     `json:"mapping"`
}

func (q *Queries) ListAcqRightsAggregation(ctx context.Context, arg ListAcqRightsAggregationParams) ([]ListAcqRightsAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsAggregation,
		arg.Scope,
		arg.IsAggName,
		arg.AggregationName,
		arg.LkAggName,
		arg.IsEditor,
		arg.ProductEditor,
		arg.LkEditor,
		arg.IsSku,
		arg.Sku,
		arg.LkSku,
		arg.IsMetric,
		arg.Metric,
		arg.LkMetric,
		arg.IsOrderingDate,
		arg.OrderingDate,
		arg.LkSoftwareProvider,
		arg.SoftwareProvider,
		arg.IsSoftwareProvider,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.AggNameAsc,
		arg.AggNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.SkuAsc,
		arg.SkuDesc,
		arg.MetricAsc,
		arg.MetricDesc,
		arg.NumLicensesAcquiredAsc,
		arg.NumLicensesAcquiredDesc,
		arg.NumLicencesMaintenanceAsc,
		arg.NumLicencesMaintenanceDesc,
		arg.AvgUnitPriceAsc,
		arg.AvgUnitPriceDesc,
		arg.AvgMaintenanceUnitPriceAsc,
		arg.AvgMaintenanceUnitPriceDesc,
		arg.TotalPurchaseCostAsc,
		arg.TotalPurchaseCostDesc,
		arg.TotalMaintenanceCostAsc,
		arg.TotalMaintenanceCostDesc,
		arg.TotalCostAsc,
		arg.TotalCostDesc,
		arg.StartOfMaintenanceAsc,
		arg.StartOfMaintenanceDesc,
		arg.EndOfMaintenanceAsc,
		arg.EndOfMaintenanceDesc,
		arg.LicenseUnderMaintenanceAsc,
		arg.LicenseUnderMaintenanceDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsAggregationRow
	for rows.Next() {
		var i ListAcqRightsAggregationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Sku,
			&i.AggregationID,
			&i.Metric,
			&i.OrderingDate,
			&i.CorporateSourcingContract,
			&i.SoftwareProvider,
			&i.Scope,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.NumLicencesMaintenance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.LastPurchasedOrder,
			pq.Array(&i.SupportNumbers),
			&i.MaintenanceProvider,
			&i.Comment,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedOn,
			&i.UpdatedBy,
			&i.FileName,
			&i.Repartition,
			&i.AggregationName,
			&i.ProductEditor,
			pq.Array(&i.Products),
			pq.Array(&i.Swidtags),
			&i.EditorID,
			&i.Mapping,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsIndividual = `-- name: ListAcqRightsIndividual :many
SELECT count(*) OVER() AS totalRecords,a.sku,a.swidtag,a.product_name,a.product_editor,a.metric,a.num_licenses_acquired,a.num_licences_maintainance,a.avg_unit_price,a.avg_maintenance_unit_price,a.total_purchase_cost,a.total_maintenance_cost,a.total_cost ,a.start_of_maintenance, a.end_of_maintenance , a.version, a.comment, a.ordering_date, a.software_provider, a.corporate_sourcing_contract, a.last_purchased_order, a.support_numbers, a.maintenance_provider, a.file_name, a.repartition, p.swid_tag_product as product_swid_tag,
       v.swid_tag_version as version_swid_tag,ec.id as editor_id,p.id as product_id
FROM 
acqrights a
Left JOIN product_catalog p ON a.product_name = p.name AND a.product_editor = p.editor_name
Left JOIN version_catalog v ON p.id = v.p_id  AND v.name = a.version
LEFT JOIN editor_catalog as ec ON ec.name = a.product_editor
WHERE 
  a.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(a.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(a.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(a.product_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(a.product_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(a.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(a.product_editor) = lower($9) ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(a.sku) LIKE '%' || lower($12::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $13::bool THEN lower(a.sku) = lower($12) ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN a.ordering_date <= $15 ELSE TRUE END)
  AND (CASE WHEN $16::bool THEN lower(a.software_provider) LIKE '%' || lower($17::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $18::bool THEN lower(a.software_provider) = lower($17) ELSE TRUE END)
  AND (CASE WHEN $19::bool THEN lower(a.metric) LIKE '%' || lower($20::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $21::bool THEN lower(a.metric) = lower($20) ELSE TRUE END)
  ORDER BY
  CASE WHEN $22::bool THEN a.swidtag END asc,
  CASE WHEN $23::bool THEN a.swidtag END desc,
  CASE WHEN $24::bool THEN a.product_name END asc,
  CASE WHEN $25::bool THEN a.product_name END desc,
  CASE WHEN $26::bool THEN a.product_editor END asc,
  CASE WHEN $27::bool THEN a.product_editor END desc,
  CASE WHEN $28::bool THEN a.sku END asc,
  CASE WHEN $29::bool THEN a.sku END desc,
  CASE WHEN $30::bool THEN a.metric END asc,
  CASE WHEN $31::bool THEN a.metric END desc,
  CASE WHEN $32::bool THEN a.num_licenses_acquired END asc,
  CASE WHEN $33::bool THEN a.num_licenses_acquired END desc,
  CASE WHEN $34::bool THEN a.num_licences_maintainance END asc,
  CASE WHEN $35::bool THEN a.num_licences_maintainance END desc,
  CASE WHEN $36::bool THEN a.avg_unit_price END asc,
  CASE WHEN $37::bool THEN a.avg_unit_price END desc,  
  CASE WHEN $38::bool THEN a.avg_maintenance_unit_price END asc,
  CASE WHEN $39::bool THEN a.avg_maintenance_unit_price END desc,
  CASE WHEN $40::bool THEN a.total_purchase_cost END asc,
  CASE WHEN $41::bool THEN a.total_purchase_cost END desc,
  CASE WHEN $42::bool THEN a.total_maintenance_cost END asc,
  CASE WHEN $43::bool THEN a.total_maintenance_cost END desc,
  CASE WHEN $44::bool THEN a.total_cost END asc,
  CASE WHEN $45::bool THEN a.total_cost END desc,
  CASE WHEN $46::bool THEN a.start_of_maintenance END asc,
  CASE WHEN $47::bool THEN a.start_of_maintenance END desc,
  CASE WHEN $48::bool THEN a.end_of_maintenance END asc,
  CASE WHEN $49::bool THEN a.end_of_maintenance END desc
  LIMIT $51 OFFSET $50
`

type ListAcqRightsIndividualParams struct {
	Scope                       []string     `json:"scope"`
	LkSwidtag                   bool         `json:"lk_swidtag"`
	Swidtag                     string       `json:"swidtag"`
	IsSwidtag                   bool         `json:"is_swidtag"`
	LkProductName               bool         `json:"lk_product_name"`
	ProductName                 string       `json:"product_name"`
	IsProductName               bool         `json:"is_product_name"`
	LkProductEditor             bool         `json:"lk_product_editor"`
	ProductEditor               string       `json:"product_editor"`
	IsProductEditor             bool         `json:"is_product_editor"`
	LkSku                       bool         `json:"lk_sku"`
	Sku                         string       `json:"sku"`
	IsSku                       bool         `json:"is_sku"`
	IsOrderingDate              bool         `json:"is_ordering_date"`
	OrderingDate                sql.NullTime `json:"ordering_date"`
	LkSoftwareProvider          bool         `json:"lk_software_provider"`
	SoftwareProvider            string       `json:"software_provider"`
	IsSoftwareProvider          bool         `json:"is_software_provider"`
	LkMetric                    bool         `json:"lk_metric"`
	Metric                      string       `json:"metric"`
	IsMetric                    bool         `json:"is_metric"`
	SwidtagAsc                  bool         `json:"swidtag_asc"`
	SwidtagDesc                 bool         `json:"swidtag_desc"`
	ProductNameAsc              bool         `json:"product_name_asc"`
	ProductNameDesc             bool         `json:"product_name_desc"`
	ProductEditorAsc            bool         `json:"product_editor_asc"`
	ProductEditorDesc           bool         `json:"product_editor_desc"`
	SkuAsc                      bool         `json:"sku_asc"`
	SkuDesc                     bool         `json:"sku_desc"`
	MetricAsc                   bool         `json:"metric_asc"`
	MetricDesc                  bool         `json:"metric_desc"`
	NumLicensesAcquiredAsc      bool         `json:"num_licenses_acquired_asc"`
	NumLicensesAcquiredDesc     bool         `json:"num_licenses_acquired_desc"`
	NumLicencesMaintainanceAsc  bool         `json:"num_licences_maintainance_asc"`
	NumLicencesMaintainanceDesc bool         `json:"num_licences_maintainance_desc"`
	AvgUnitPriceAsc             bool         `json:"avg_unit_price_asc"`
	AvgUnitPriceDesc            bool         `json:"avg_unit_price_desc"`
	AvgMaintenanceUnitPriceAsc  bool         `json:"avg_maintenance_unit_price_asc"`
	AvgMaintenanceUnitPriceDesc bool         `json:"avg_maintenance_unit_price_desc"`
	TotalPurchaseCostAsc        bool         `json:"total_purchase_cost_asc"`
	TotalPurchaseCostDesc       bool         `json:"total_purchase_cost_desc"`
	TotalMaintenanceCostAsc     bool         `json:"total_maintenance_cost_asc"`
	TotalMaintenanceCostDesc    bool         `json:"total_maintenance_cost_desc"`
	TotalCostAsc                bool         `json:"total_cost_asc"`
	TotalCostDesc               bool         `json:"total_cost_desc"`
	StartOfMaintenanceAsc       bool         `json:"start_of_maintenance_asc"`
	StartOfMaintenanceDesc      bool         `json:"start_of_maintenance_desc"`
	EndOfMaintenanceAsc         bool         `json:"end_of_maintenance_asc"`
	EndOfMaintenanceDesc        bool         `json:"end_of_maintenance_desc"`
	PageNum                     int32        `json:"page_num"`
	PageSize                    int32        `json:"page_size"`
}

type ListAcqRightsIndividualRow struct {
	Totalrecords              int64           `json:"totalrecords"`
	Sku                       string          `json:"sku"`
	Swidtag                   string          `json:"swidtag"`
	ProductName               string          `json:"product_name"`
	ProductEditor             string          `json:"product_editor"`
	Metric                    string          `json:"metric"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	NumLicencesMaintainance   int32           `json:"num_licences_maintainance"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	Version                   string          `json:"version"`
	Comment                   sql.NullString  `json:"comment"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	SoftwareProvider          string          `json:"software_provider"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	FileName                  string          `json:"file_name"`
	Repartition               bool            `json:"repartition"`
	ProductSwidTag            sql.NullString  `json:"product_swid_tag"`
	VersionSwidTag            sql.NullString  `json:"version_swid_tag"`
	EditorID                  sql.NullString  `json:"editor_id"`
	ProductID                 sql.NullString  `json:"product_id"`
}

func (q *Queries) ListAcqRightsIndividual(ctx context.Context, arg ListAcqRightsIndividualParams) ([]ListAcqRightsIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsIndividual,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.LkSku,
		arg.Sku,
		arg.IsSku,
		arg.IsOrderingDate,
		arg.OrderingDate,
		arg.LkSoftwareProvider,
		arg.SoftwareProvider,
		arg.IsSoftwareProvider,
		arg.LkMetric,
		arg.Metric,
		arg.IsMetric,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.SkuAsc,
		arg.SkuDesc,
		arg.MetricAsc,
		arg.MetricDesc,
		arg.NumLicensesAcquiredAsc,
		arg.NumLicensesAcquiredDesc,
		arg.NumLicencesMaintainanceAsc,
		arg.NumLicencesMaintainanceDesc,
		arg.AvgUnitPriceAsc,
		arg.AvgUnitPriceDesc,
		arg.AvgMaintenanceUnitPriceAsc,
		arg.AvgMaintenanceUnitPriceDesc,
		arg.TotalPurchaseCostAsc,
		arg.TotalPurchaseCostDesc,
		arg.TotalMaintenanceCostAsc,
		arg.TotalMaintenanceCostDesc,
		arg.TotalCostAsc,
		arg.TotalCostDesc,
		arg.StartOfMaintenanceAsc,
		arg.StartOfMaintenanceDesc,
		arg.EndOfMaintenanceAsc,
		arg.EndOfMaintenanceDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsIndividualRow
	for rows.Next() {
		var i ListAcqRightsIndividualRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Version,
			&i.Comment,
			&i.OrderingDate,
			&i.SoftwareProvider,
			&i.CorporateSourcingContract,
			&i.LastPurchasedOrder,
			pq.Array(&i.SupportNumbers),
			&i.MaintenanceProvider,
			&i.FileName,
			&i.Repartition,
			&i.ProductSwidTag,
			&i.VersionSwidTag,
			&i.EditorID,
			&i.ProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqrightsProducts = `-- name: ListAcqrightsProducts :many

SELECT DISTINCT swidtag,scope FROM acqrights
`

type ListAcqrightsProductsRow struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

func (q *Queries) ListAcqrightsProducts(ctx context.Context) ([]ListAcqrightsProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqrightsProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqrightsProductsRow
	for rows.Next() {
		var i ListAcqrightsProductsRow
		if err := rows.Scan(&i.Swidtag, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqrightsProductsByScope = `-- name: ListAcqrightsProductsByScope :many

SELECT DISTINCT swidtag, scope
FROM acqrights
where
    acqrights.scope = $1
    and swidtag not in (
        select
            unnest(aggregations.swidtags)
        from aggregations
            inner join aggregated_rights on aggregations.id = aggregated_rights.aggregation_id and aggregations.scope = $1
    )
`

type ListAcqrightsProductsByScopeRow struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

func (q *Queries) ListAcqrightsProductsByScope(ctx context.Context, scope string) ([]ListAcqrightsProductsByScopeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqrightsProductsByScope, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqrightsProductsByScopeRow
	for rows.Next() {
		var i ListAcqrightsProductsByScopeRow
		if err := rows.Scan(&i.Swidtag, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregationNameByScope = `-- name: ListAggregationNameByScope :many

SELECT aggregation_name
from aggregations
    inner join aggregated_rights on aggregations.id = aggregated_rights.aggregation_id
where aggregations.scope = $1
`

func (q *Queries) ListAggregationNameByScope(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAggregationNameByScope, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var aggregation_name string
		if err := rows.Scan(&aggregation_name); err != nil {
			return nil, err
		}
		items = append(items, aggregation_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregationNameWithScope = `-- name: ListAggregationNameWithScope :many

SELECT
    aggregation_name,
    aggregations.scope
from aggregations
    inner join aggregated_rights on aggregations.id = aggregated_rights.aggregation_id
`

type ListAggregationNameWithScopeRow struct {
	AggregationName string `json:"aggregation_name"`
	Scope           string `json:"scope"`
}

func (q *Queries) ListAggregationNameWithScope(ctx context.Context) ([]ListAggregationNameWithScopeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregationNameWithScope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationNameWithScopeRow
	for rows.Next() {
		var i ListAggregationNameWithScopeRow
		if err := rows.Scan(&i.AggregationName, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregations = `-- name: ListAggregations :many
SELECT
    count(aggregations.id) OVER() AS totalRecords,
    aggregations.id,
    aggregation_name,
    product_editor,
    products,
    swidtags,
    scope,
    ec.id as editor_id, (
        Select coalesce( (
                    SELECT
                        array_to_json(
                            array_agg(row_to_json(mapping))
                        )
                    from (
                            SELECT
                                products.product_name,
                                products.product_version
                            FROM
                                products
                            where
                                swidtag in (
                                    SELECT
                                        UNNEST (swidtags)
                                )
                            UNION
                            select
                                pc.name product_name,
                                vc.name product_version
                            from
                                product_catalog pc
                                join version_catalog vc on pc.id = vc.p_id
                            where
                                vc.swid_tag_system in (
                                    SELECT
                                        UNNEST (swidtags)
                                )
                            UNION
                            SELECT
                                acqrights.product_name,
                                acqrights.version
                            FROM
                                acqrights
                            where
                                swidtag in (
                                    SELECT
                                        UNNEST (swidtags)
                                )
                        ) as mapping
                ),
                '[]':: json
            )
    )
FROM
    aggregations
    LEFT join editor_catalog as ec on ec.name = aggregations.product_editor
WHERE
    aggregations.scope = $1
    AND (
        CASE
            WHEN $2 :: bool THEN lower(aggregation_name) = lower($3)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4 :: bool THEN lower(aggregation_name) LIKE '%' || lower($3) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5 :: bool THEN lower(product_editor) = lower($6)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $7 :: bool THEN lower(product_editor) LIKE '%' || lower($6) || '%'
            ELSE TRUE
        END
    )
ORDER BY
    CASE
        WHEN $8 :: bool THEN aggregation_name
    END asc,
    CASE
        WHEN $9 :: bool THEN aggregation_name
    END desc,
    CASE
        WHEN $10 :: bool THEN product_editor
    END asc,
    CASE
        WHEN $11 :: bool THEN product_editor
    END desc
LIMIT
    $13 OFFSET $12
`

type ListAggregationsParams struct {
	Scope             string `json:"scope"`
	IsAggName         bool   `json:"is_agg_name"`
	AggregationName   string `json:"aggregation_name"`
	LsAggName         bool   `json:"ls_agg_name"`
	IsProductEditor   bool   `json:"is_product_editor"`
	ProductEditor     string `json:"product_editor"`
	LkProductEditor   bool   `json:"lk_product_editor"`
	AggNameAsc        bool   `json:"agg_name_asc"`
	AggNameDesc       bool   `json:"agg_name_desc"`
	ProductEditorAsc  bool   `json:"product_editor_asc"`
	ProductEditorDesc bool   `json:"product_editor_desc"`
	PageNum           int32  `json:"page_num"`
	PageSize          int32  `json:"page_size"`
}

type ListAggregationsRow struct {
	Totalrecords    int64          `json:"totalrecords"`
	ID              int32          `json:"id"`
	AggregationName string         `json:"aggregation_name"`
	ProductEditor   string         `json:"product_editor"`
	Products        []string       `json:"products"`
	Swidtags        []string       `json:"swidtags"`
	Scope           string         `json:"scope"`
	EditorID        sql.NullString `json:"editor_id"`
	Coalesce        interface{}    `json:"coalesce"`
}

func (q *Queries) ListAggregations(ctx context.Context, arg ListAggregationsParams) ([]ListAggregationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregations,
		arg.Scope,
		arg.IsAggName,
		arg.AggregationName,
		arg.LsAggName,
		arg.IsProductEditor,
		arg.ProductEditor,
		arg.LkProductEditor,
		arg.AggNameAsc,
		arg.AggNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationsRow
	for rows.Next() {
		var i ListAggregationsRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ID,
			&i.AggregationName,
			&i.ProductEditor,
			pq.Array(&i.Products),
			pq.Array(&i.Swidtags),
			&i.Scope,
			&i.EditorID,
			&i.Coalesce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConcurrentUsers = `-- name: ListConcurrentUsers :many

SELECT
    count(*) OVER() AS totalRecords,
    pcu.id,
    pcu.swidtag,
    pcu.purchase_date,
    pcu.number_of_users,
    pcu.profile_user,
    pcu.team,
    pcu.updated_on,
    pcu.created_on,
    pcu.created_by,
    pcu.updated_by,
    pcu.aggregation_id,
    agg.aggregation_name,
    p.product_version,
    p.product_name,
    p.product_editor,
    pcu.is_aggregations
FROM
    product_concurrent_user pcu
    LEFT JOIN aggregations agg on pcu.aggregation_id = agg.id
    LEFT JOIN products p on pcu.swidtag = p.swidtag
    AND p.scope = ANY($1:: TEXT [])
WHERE
    pcu.scope = ANY($1:: TEXT [])
    AND pcu.is_aggregations = $2:: bool
    AND (
        CASE
            WHEN $3:: bool THEN lower(p.product_name) LIKE '%' || lower($4:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(p.product_name) = lower($4)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $6:: bool THEN lower(agg.aggregation_name) LIKE '%' || lower($7:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(agg.aggregation_name) = lower($7)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $9:: bool THEN lower(p.product_version) LIKE '%' || lower($10:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(p.product_version) = lower($10)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $12:: bool THEN lower(pcu.profile_user) LIKE '%' || lower($13:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(pcu.profile_user) = lower($13)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $15:: bool THEN lower(pcu.team) LIKE '%' || lower($16:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $17:: bool THEN lower(pcu.team) = lower($16)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $18:: bool THEN lower(pcu.number_of_users) LIKE '%' || lower($19:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $20:: bool THEN lower(pcu.number_of_users) = lower($19)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $21:: bool THEN DATE(pcu.updated_on) = DATE($22)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $23:: bool THEN lower(p.product_editor) LIKE '%' || lower($24:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $25:: bool THEN lower(p.product_editor) = lower($24)
            ELSE TRUE
        END
    )
GROUP BY
    pcu.id,
    pcu.swidtag,
    pcu.purchase_date,
    pcu.number_of_users,
    pcu.profile_user,
    pcu.team,
    pcu.updated_on,
    pcu.created_on,
    pcu.created_by,
    pcu.updated_by,
    pcu.aggregation_id,
    agg.aggregation_name,
    p.product_version,
    p.product_name,
    p.product_editor
ORDER BY
    CASE
        WHEN $26:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $27:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $28:: bool THEN agg.aggregation_name
    END asc,
    CASE
        WHEN $29:: bool THEN agg.aggregation_name
    END desc,
    CASE
        WHEN $30:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $31:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $32:: bool THEN pcu.profile_user
    END asc,
    CASE
        WHEN $33:: bool THEN pcu.profile_user
    END desc,
    CASE
        WHEN $34:: bool THEN pcu.team
    END asc,
    CASE
        WHEN $35:: bool THEN pcu.team
    END desc,
    CASE
        WHEN $36:: bool THEN pcu.number_of_users
    END asc,
    CASE
        WHEN $37:: bool THEN pcu.number_of_users
    END desc,
    CASE
        WHEN $38:: bool THEN pcu.updated_on
    END asc,
    CASE
        WHEN $39:: bool THEN pcu.updated_on
    END desc,
    CASE
        WHEN $40:: bool THEN p.product_editor
    END asc,
    CASE
        WHEN $41:: bool THEN p.product_editor
    END desc
LIMIT $43
OFFSET $42
`

type ListConcurrentUsersParams struct {
	Scope               []string    `json:"scope"`
	IsAggregations      bool        `json:"is_aggregations"`
	LkProductName       bool        `json:"lk_product_name"`
	ProductName         string      `json:"product_name"`
	IsProductName       bool        `json:"is_product_name"`
	LkAggregationName   bool        `json:"lk_aggregation_name"`
	AggregationName     string      `json:"aggregation_name"`
	IsAggregationName   bool        `json:"is_aggregation_name"`
	LkProductVersion    bool        `json:"lk_product_version"`
	ProductVersion      string      `json:"product_version"`
	IsProductVersion    bool        `json:"is_product_version"`
	LkProfileUser       bool        `json:"lk_profile_user"`
	ProfileUser         string      `json:"profile_user"`
	IsProfileUser       bool        `json:"is_profile_user"`
	LkTeam              bool        `json:"lk_team"`
	Team                string      `json:"team"`
	IsTeam              bool        `json:"is_team"`
	LkNumberOfUsers     bool        `json:"lk_number_of_users"`
	NumberOfUsers       string      `json:"number_of_users"`
	IsNumberOfUsers     bool        `json:"is_number_of_users"`
	IsPurchaseDate      bool        `json:"is_purchase_date"`
	PurchaseDate        interface{} `json:"purchase_date"`
	LkEditorName        bool        `json:"lk_editor_name"`
	ProductEditor       string      `json:"product_editor"`
	IsEditorName        bool        `json:"is_editor_name"`
	ProductNameAsc      bool        `json:"product_name_asc"`
	ProductNameDesc     bool        `json:"product_name_desc"`
	AggregationNameAsc  bool        `json:"aggregation_name_asc"`
	AggregationNameDesc bool        `json:"aggregation_name_desc"`
	ProductVersionAsc   bool        `json:"product_version_asc"`
	ProductVersionDesc  bool        `json:"product_version_desc"`
	ProfileUserAsc      bool        `json:"profile_user_asc"`
	ProfileUserDesc     bool        `json:"profile_user_desc"`
	TeamAsc             bool        `json:"team_asc"`
	TeamDesc            bool        `json:"team_desc"`
	NumberOfUsersAsc    bool        `json:"number_of_users_asc"`
	NumberOfUsersDesc   bool        `json:"number_of_users_desc"`
	PurchaseDateAsc     bool        `json:"purchase_date_asc"`
	PurchaseDateDesc    bool        `json:"purchase_date_desc"`
	ProductEditorAsc    bool        `json:"product_editor_asc"`
	ProductEditorDesc   bool        `json:"product_editor_desc"`
	PageNum             int32       `json:"page_num"`
	PageSize            int32       `json:"page_size"`
}

type ListConcurrentUsersRow struct {
	Totalrecords    int64          `json:"totalrecords"`
	ID              int32          `json:"id"`
	Swidtag         sql.NullString `json:"swidtag"`
	PurchaseDate    time.Time      `json:"purchase_date"`
	NumberOfUsers   sql.NullInt32  `json:"number_of_users"`
	ProfileUser     sql.NullString `json:"profile_user"`
	Team            sql.NullString `json:"team"`
	UpdatedOn       time.Time      `json:"updated_on"`
	CreatedOn       time.Time      `json:"created_on"`
	CreatedBy       string         `json:"created_by"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	AggregationID   sql.NullInt32  `json:"aggregation_id"`
	AggregationName sql.NullString `json:"aggregation_name"`
	ProductVersion  sql.NullString `json:"product_version"`
	ProductName     sql.NullString `json:"product_name"`
	ProductEditor   sql.NullString `json:"product_editor"`
	IsAggregations  sql.NullBool   `json:"is_aggregations"`
}

func (q *Queries) ListConcurrentUsers(ctx context.Context, arg ListConcurrentUsersParams) ([]ListConcurrentUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listConcurrentUsers,
		pq.Array(arg.Scope),
		arg.IsAggregations,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkProductVersion,
		arg.ProductVersion,
		arg.IsProductVersion,
		arg.LkProfileUser,
		arg.ProfileUser,
		arg.IsProfileUser,
		arg.LkTeam,
		arg.Team,
		arg.IsTeam,
		arg.LkNumberOfUsers,
		arg.NumberOfUsers,
		arg.IsNumberOfUsers,
		arg.IsPurchaseDate,
		arg.PurchaseDate,
		arg.LkEditorName,
		arg.ProductEditor,
		arg.IsEditorName,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProfileUserAsc,
		arg.ProfileUserDesc,
		arg.TeamAsc,
		arg.TeamDesc,
		arg.NumberOfUsersAsc,
		arg.NumberOfUsersDesc,
		arg.PurchaseDateAsc,
		arg.PurchaseDateDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConcurrentUsersRow
	for rows.Next() {
		var i ListConcurrentUsersRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ID,
			&i.Swidtag,
			&i.PurchaseDate,
			&i.NumberOfUsers,
			&i.ProfileUser,
			&i.Team,
			&i.UpdatedOn,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.AggregationID,
			&i.AggregationName,
			&i.ProductVersion,
			&i.ProductName,
			&i.ProductEditor,
			&i.IsAggregations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeployedAndAcquiredEditors = `-- name: ListDeployedAndAcquiredEditors :many

SELECT
    DISTINCT acq.product_editor
FROM acqrights acq
WHERE
    acq.scope = $1
    AND acq.product_editor <> ''
INTERSECT
SELECT
    DISTINCT prd.product_editor
FROM products prd
WHERE
    prd.scope = $1
    AND prd.product_editor <> ''
`

func (q *Queries) ListDeployedAndAcquiredEditors(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listDeployedAndAcquiredEditors, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditors = `-- name: ListEditors :many

SELECT
    DISTINCT (p.product_editor) AS product_editor
FROM products p
WHERE
    p.scope = ANY($1:: TEXT [])
    AND LENGTH(p.product_editor) > 0
UNION
SELECT
    DISTINCT (ec.name) AS product_editor
FROM editor_catalog AS ec
WHERE LENGTH(ec.name) > 0
`

func (q *Queries) ListEditors(ctx context.Context, scope []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEditors, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditorsForAggregation = `-- name: ListEditorsForAggregation :many

SELECT
    DISTINCT acq.product_editor
FROM acqrights acq
WHERE
    acq.scope =  ANY($1:: TEXT [])
    AND acq.product_editor <> ''
UNION
SELECT DISTINCT prd.product_editor 
FROM products prd 
WHERE prd.scope =ANY($1:: TEXT []) AND prd.product_editor <> ''
`

func (q *Queries) ListEditorsForAggregation(ctx context.Context, scope []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEditorsForAggregation, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditorsScope = `-- name: ListEditorsScope :many

SELECT
    DISTINCT ON (p.product_editor) p.product_editor
FROM products p
WHERE
    p.scope = ANY($1:: TEXT [])
    AND LENGTH(p.product_editor) > 0
`

func (q *Queries) ListEditorsScope(ctx context.Context, scope []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEditorsScope, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricsForAggregation = `-- name: ListMetricsForAggregation :many

SELECT DISTINCT acq.metric FROM acqrights acq WHERE acq.scope = $1
`

func (q *Queries) ListMetricsForAggregation(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listMetricsForAggregation, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var metric string
		if err := rows.Scan(&metric); err != nil {
			return nil, err
		}
		items = append(items, metric)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNominativeUsersAggregation = `-- name: ListNominativeUsersAggregation :many

SELECT
    count(*) OVER() AS totalRecords,
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    nu.aggregations_id,
    agg.aggregation_name
FROM nominative_user nU
    LEFT JOIN aggregations agg on nu.aggregations_id = agg.id
WHERE
    nu.aggregations_id != 0
    AND nu.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $2:: bool THEN lower(agg.aggregation_name) LIKE '%' || lower($3:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN lower(agg.aggregation_name) = lower($3)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(nu.user_name) LIKE '%' || lower($6:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $7:: bool THEN lower(nu.user_name) = lower($6)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(nu.first_name) LIKE '%' || lower($9:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $10:: bool THEN lower(nu.first_name) = lower($9)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(nu.user_email) LIKE '%' || lower($12:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $13:: bool THEN lower(nu.user_email) = lower($12)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(nu.profile) LIKE '%' || lower($15:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $16:: bool THEN lower(nu.profile) = lower($15)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $17:: bool THEN date(nu.activation_date):: text = $18:: text
            ELSE TRUE
        END
    )
GROUP BY
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    nu.aggregations_id,
    agg.aggregation_name
ORDER BY
    CASE
        WHEN $19:: bool THEN agg.aggregation_name
    END asc,
    CASE
        WHEN $20:: bool THEN agg.aggregation_name
    END desc,
    CASE
        WHEN $21:: bool THEN nu.user_name
    END asc,
    CASE
        WHEN $22:: bool THEN nu.user_name
    END desc,
    CASE
        WHEN $23:: bool THEN nu.first_name
    END asc,
    CASE
        WHEN $24:: bool THEN nu.first_name
    END desc,
    CASE
        WHEN $25:: bool THEN nu.user_email
    END asc,
    CASE
        WHEN $26:: bool THEN nu.user_email
    END desc,
    CASE
        WHEN $27:: bool THEN nu.profile
    END asc,
    CASE
        WHEN $28:: bool THEN nu.profile
    END desc,
    CASE
        WHEN $29:: bool THEN nu.activation_date
    END asc,
    CASE
        WHEN $30:: bool THEN nu.activation_date
    END desc
LIMIT $32
OFFSET $31
`

type ListNominativeUsersAggregationParams struct {
	Scope               []string `json:"scope"`
	LkAggregationName   bool     `json:"lk_aggregation_name"`
	AggregationName     string   `json:"aggregation_name"`
	IsAggregationName   bool     `json:"is_aggregation_name"`
	LkUserName          bool     `json:"lk_user_name"`
	UserName            string   `json:"user_name"`
	IsUserName          bool     `json:"is_user_name"`
	LkFirstName         bool     `json:"lk_first_name"`
	FirstName           string   `json:"first_name"`
	IsFirstName         bool     `json:"is_first_name"`
	LkUserEmail         bool     `json:"lk_user_email"`
	UserEmail           string   `json:"user_email"`
	IsUserEmail         bool     `json:"is_user_email"`
	LkProfile           bool     `json:"lk_profile"`
	Profile             string   `json:"profile"`
	IsProfile           bool     `json:"is_profile"`
	IsActivationDate    bool     `json:"is_activation_date"`
	ActivationDate      string   `json:"activation_date"`
	AggregationNameAsc  bool     `json:"aggregation_name_asc"`
	AggregationNameDesc bool     `json:"aggregation_name_desc"`
	UserNameAsc         bool     `json:"user_name_asc"`
	UserNameDesc        bool     `json:"user_name_desc"`
	FirstNameAsc        bool     `json:"first_name_asc"`
	FirstNameDesc       bool     `json:"first_name_desc"`
	UserEmailAsc        bool     `json:"user_email_asc"`
	UserEmailDesc       bool     `json:"user_email_desc"`
	ProfileAsc          bool     `json:"profile_asc"`
	ProfileDesc         bool     `json:"profile_desc"`
	ActivationDateAsc   bool     `json:"activation_date_asc"`
	ActivationDateDesc  bool     `json:"activation_date_desc"`
	PageNum             int32    `json:"page_num"`
	PageSize            int32    `json:"page_size"`
}

type ListNominativeUsersAggregationRow struct {
	Totalrecords    int64          `json:"totalrecords"`
	UserID          int32          `json:"user_id"`
	Swidtag         sql.NullString `json:"swidtag"`
	ActivationDate  sql.NullTime   `json:"activation_date"`
	UserEmail       string         `json:"user_email"`
	UserName        sql.NullString `json:"user_name"`
	FirstName       sql.NullString `json:"first_name"`
	Profile         sql.NullString `json:"profile"`
	ProductEditor   sql.NullString `json:"product_editor"`
	UpdatedAt       time.Time      `json:"updated_at"`
	CreatedAt       time.Time      `json:"created_at"`
	CreatedBy       string         `json:"created_by"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	AggregationsID  sql.NullInt32  `json:"aggregations_id"`
	AggregationName sql.NullString `json:"aggregation_name"`
}

func (q *Queries) ListNominativeUsersAggregation(ctx context.Context, arg ListNominativeUsersAggregationParams) ([]ListNominativeUsersAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listNominativeUsersAggregation,
		pq.Array(arg.Scope),
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkUserName,
		arg.UserName,
		arg.IsUserName,
		arg.LkFirstName,
		arg.FirstName,
		arg.IsFirstName,
		arg.LkUserEmail,
		arg.UserEmail,
		arg.IsUserEmail,
		arg.LkProfile,
		arg.Profile,
		arg.IsProfile,
		arg.IsActivationDate,
		arg.ActivationDate,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.UserNameAsc,
		arg.UserNameDesc,
		arg.FirstNameAsc,
		arg.FirstNameDesc,
		arg.UserEmailAsc,
		arg.UserEmailDesc,
		arg.ProfileAsc,
		arg.ProfileDesc,
		arg.ActivationDateAsc,
		arg.ActivationDateDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNominativeUsersAggregationRow
	for rows.Next() {
		var i ListNominativeUsersAggregationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UserID,
			&i.Swidtag,
			&i.ActivationDate,
			&i.UserEmail,
			&i.UserName,
			&i.FirstName,
			&i.Profile,
			&i.ProductEditor,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.AggregationsID,
			&i.AggregationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNominativeUsersProducts = `-- name: ListNominativeUsersProducts :many

SELECT
    count(*) OVER() AS totalRecords,
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    p.product_version,
    p.product_name
FROM nominative_user nU
    INNER JOIN products p on nu.swidtag = p.swidtag and nu.scope = ANY($1:: TEXT []) AND p.scope = ANY($1:: TEXT [])
where
    nu.swidtag != ''
    AND (
        CASE
            WHEN $2:: bool THEN lower(p.product_name) LIKE '%' || lower($3:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN lower(p.product_name) = lower($3)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(p.product_version) LIKE '%' || lower($6:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $7:: bool THEN lower(p.product_version) = lower($6)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(nu.user_name) LIKE '%' || lower($9:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $10:: bool THEN lower(nu.user_name) = lower($9)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(nu.first_name) LIKE '%' || lower($12:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $13:: bool THEN lower(nu.first_name) = lower($12)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(nu.user_email) LIKE '%' || lower($15:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $16:: bool THEN lower(nu.user_email) = lower($15)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $17:: bool THEN lower(nu.profile) LIKE '%' || lower($18:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $19:: bool THEN lower(nu.profile) = lower($18)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $20:: bool THEN date(nu.activation_date):: text = $21:: text
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $22:: bool THEN lower(nu.product_editor) LIKE '%' || lower($23:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $24:: bool THEN lower(nu.product_editor) = lower($23)
            ELSE TRUE
        END
    )
GROUP BY
    nu.user_id,
    nu.swidtag,
    nu.activation_date,
    nu.user_email,
    nu.user_name,
    nu.first_name,
    nu.profile,
    nu.product_editor,
    nu.updated_at,
    nu.created_at,
    nu.created_by,
    nu.updated_by,
    p.product_version,
    p.product_name
ORDER BY
    CASE
        WHEN $25:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $26:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $27:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $28:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $29:: bool THEN nu.user_name
    END asc,
    CASE
        WHEN $30:: bool THEN nu.user_name
    END desc,
    CASE
        WHEN $31:: bool THEN nu.first_name
    END asc,
    CASE
        WHEN $32:: bool THEN nu.first_name
    END desc,
    CASE
        WHEN $33:: bool THEN nu.user_email
    END asc,
    CASE
        WHEN $34:: bool THEN nu.user_email
    END desc,
    CASE
        WHEN $35:: bool THEN nu.profile
    END asc,
    CASE
        WHEN $36:: bool THEN nu.profile
    END desc,
    CASE
        WHEN $37:: bool THEN nu.activation_date
    END asc,
    CASE
        WHEN $38:: bool THEN nu.activation_date
    END desc,
    CASE
        WHEN $39:: bool THEN nu.product_editor
    END asc,
    CASE
        WHEN $40:: bool THEN nu.product_editor
    END desc
LIMIT $42
OFFSET $41
`

type ListNominativeUsersProductsParams struct {
	Scope              []string `json:"scope"`
	LkProductName      bool     `json:"lk_product_name"`
	ProductName        string   `json:"product_name"`
	IsProductName      bool     `json:"is_product_name"`
	LkProductVersion   bool     `json:"lk_product_version"`
	ProductVersion     string   `json:"product_version"`
	IsProductVersion   bool     `json:"is_product_version"`
	LkUserName         bool     `json:"lk_user_name"`
	UserName           string   `json:"user_name"`
	IsUserName         bool     `json:"is_user_name"`
	LkFirstName        bool     `json:"lk_first_name"`
	FirstName          string   `json:"first_name"`
	IsFirstName        bool     `json:"is_first_name"`
	LkUserEmail        bool     `json:"lk_user_email"`
	UserEmail          string   `json:"user_email"`
	IsUserEmail        bool     `json:"is_user_email"`
	LkProfile          bool     `json:"lk_profile"`
	Profile            string   `json:"profile"`
	IsProfile          bool     `json:"is_profile"`
	IsActivationDate   bool     `json:"is_activation_date"`
	ActivationDate     string   `json:"activation_date"`
	LkProductEditor    bool     `json:"lk_product_editor"`
	ProductEditor      string   `json:"product_editor"`
	IsProductEditor    bool     `json:"is_product_editor"`
	ProductNameAsc     bool     `json:"product_name_asc"`
	ProductNameDesc    bool     `json:"product_name_desc"`
	ProductVersionAsc  bool     `json:"product_version_asc"`
	ProductVersionDesc bool     `json:"product_version_desc"`
	UserNameAsc        bool     `json:"user_name_asc"`
	UserNameDesc       bool     `json:"user_name_desc"`
	FirstNameAsc       bool     `json:"first_name_asc"`
	FirstNameDesc      bool     `json:"first_name_desc"`
	UserEmailAsc       bool     `json:"user_email_asc"`
	UserEmailDesc      bool     `json:"user_email_desc"`
	ProfileAsc         bool     `json:"profile_asc"`
	ProfileDesc        bool     `json:"profile_desc"`
	ActivationDateAsc  bool     `json:"activation_date_asc"`
	ActivationDateDesc bool     `json:"activation_date_desc"`
	ProductEditorAsc   bool     `json:"product_editor_asc"`
	ProductEditorDesc  bool     `json:"product_editor_desc"`
	PageNum            int32    `json:"page_num"`
	PageSize           int32    `json:"page_size"`
}

type ListNominativeUsersProductsRow struct {
	Totalrecords   int64          `json:"totalrecords"`
	UserID         int32          `json:"user_id"`
	Swidtag        sql.NullString `json:"swidtag"`
	ActivationDate sql.NullTime   `json:"activation_date"`
	UserEmail      string         `json:"user_email"`
	UserName       sql.NullString `json:"user_name"`
	FirstName      sql.NullString `json:"first_name"`
	Profile        sql.NullString `json:"profile"`
	ProductEditor  sql.NullString `json:"product_editor"`
	UpdatedAt      time.Time      `json:"updated_at"`
	CreatedAt      time.Time      `json:"created_at"`
	CreatedBy      string         `json:"created_by"`
	UpdatedBy      sql.NullString `json:"updated_by"`
	ProductVersion string         `json:"product_version"`
	ProductName    string         `json:"product_name"`
}

func (q *Queries) ListNominativeUsersProducts(ctx context.Context, arg ListNominativeUsersProductsParams) ([]ListNominativeUsersProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listNominativeUsersProducts,
		pq.Array(arg.Scope),
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductVersion,
		arg.ProductVersion,
		arg.IsProductVersion,
		arg.LkUserName,
		arg.UserName,
		arg.IsUserName,
		arg.LkFirstName,
		arg.FirstName,
		arg.IsFirstName,
		arg.LkUserEmail,
		arg.UserEmail,
		arg.IsUserEmail,
		arg.LkProfile,
		arg.Profile,
		arg.IsProfile,
		arg.IsActivationDate,
		arg.ActivationDate,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.UserNameAsc,
		arg.UserNameDesc,
		arg.FirstNameAsc,
		arg.FirstNameDesc,
		arg.UserEmailAsc,
		arg.UserEmailDesc,
		arg.ProfileAsc,
		arg.ProfileDesc,
		arg.ActivationDateAsc,
		arg.ActivationDateDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNominativeUsersProductsRow
	for rows.Next() {
		var i ListNominativeUsersProductsRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.UserID,
			&i.Swidtag,
			&i.ActivationDate,
			&i.UserEmail,
			&i.UserName,
			&i.FirstName,
			&i.Profile,
			&i.ProductEditor,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.ProductVersion,
			&i.ProductName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNominativeUsersUploadedFiles = `-- name: ListNominativeUsersUploadedFiles :many

SELECT
   	count(*) OVER() AS totalRecords,
    fd.id,
    upload_id,
    fd.scope,
    fd.swidtag,
    aggregations_id,
    fd.product_editor,
    uploaded_by,
    uploaded_at,
    nominative_users_details,
    record_succeed,
    record_failed,
    file_name,
    sheet_name,
    file_status,
        CASE 
   	     WHEN aggregations_id IS NOT NULL THEN a.aggregation_name
        ELSE  p.product_name
  	    END AS pname,
        CASE 
   	    WHEN aggregations_id IS NOT NULL THEN 'aggregation'
        ELSE  'individual'
  	    END AS nametype,
    p.product_name,
    p.product_version,
    a.aggregation_name,
    (select count(*) from jobs where status != 'COMPLETED' and ppid = fd.ppid) as jobNotCompleted
FROM
    nominative_user_file_uploaded_details fd
    left join products p on fd.swidtag=p.swidtag and fd.scope=p.scope
    left join aggregations a on fd.aggregations_id=a.id and fd.scope=a.scope
where
    fd.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $2:: bool THEN fd.id = $3
            ELSE TRUE
        END
    )
    ORDER BY
    CASE
        WHEN $4:: bool THEN file_name
    END asc,
    CASE
        WHEN $5:: bool THEN file_name
    END desc,
    CASE
        WHEN $6:: bool THEN file_status
    END asc,
    CASE
        WHEN $7:: bool THEN file_status
    END desc,
    CASE
        WHEN $8:: bool THEN fd.product_editor
    END asc,
    CASE
        WHEN $9:: bool THEN fd.product_editor
    END desc,
    CASE
        WHEN $10:: bool THEN  CASE 
                WHEN aggregations_id IS NOT NULL THEN a.aggregation_name
                ELSE  p.product_name
            END
    END asc,
    CASE
        WHEN $11:: bool THEN  CASE 
                WHEN aggregations_id IS NOT NULL THEN a.aggregation_name
                ELSE  p.product_name
            END
    END desc,
    CASE
        WHEN $12:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $13:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $14:: bool THEN uploaded_by
    END asc,
    CASE
        WHEN $15:: bool THEN uploaded_by
    END desc,
    CASE
        WHEN $16:: bool THEN uploaded_at
    END asc,
    CASE
        WHEN $17:: bool THEN uploaded_at
    END desc,
    CASE
        WHEN $18:: bool THEN CASE 
   	    WHEN aggregations_id IS NOT NULL THEN 'aggregation'
        ELSE  'individual'
  	    END
    END asc,
    CASE
        WHEN $19:: bool THEN CASE 
   	    WHEN aggregations_id IS NOT NULL THEN 'aggregation'
        ELSE  'individual'
  	    END
    END desc
    LIMIT $21
    OFFSET $20
`

type ListNominativeUsersUploadedFilesParams struct {
	Scope              []string `json:"scope"`
	FileUploadID       bool     `json:"file_upload_id"`
	ID                 int32    `json:"id"`
	FileNameAsc        bool     `json:"file_name_asc"`
	FileNameDesc       bool     `json:"file_name_desc"`
	FileStatusAsc      bool     `json:"file_status_asc"`
	FileStatusDesc     bool     `json:"file_status_desc"`
	ProductEditorAsc   bool     `json:"product_editor_asc"`
	ProductEditorDesc  bool     `json:"product_editor_desc"`
	NameAsc            bool     `json:"name_asc"`
	NameDesc           bool     `json:"name_desc"`
	ProductVersionAsc  bool     `json:"product_version_asc"`
	ProductVersionDesc bool     `json:"product_version_desc"`
	UploadedByAsc      bool     `json:"uploaded_by_asc"`
	UploadedByDesc     bool     `json:"uploaded_by_desc"`
	UploadedOnAsc      bool     `json:"uploaded_on_asc"`
	UploadedOnDesc     bool     `json:"uploaded_on_desc"`
	ProducttypeAsc     bool     `json:"producttype_asc"`
	ProducttypeDesc    bool     `json:"producttype_desc"`
	PageNum            int32    `json:"page_num"`
	PageSize           int32    `json:"page_size"`
}

type ListNominativeUsersUploadedFilesRow struct {
	Totalrecords           int64                 `json:"totalrecords"`
	ID                     int32                 `json:"id"`
	UploadID               string                `json:"upload_id"`
	Scope                  string                `json:"scope"`
	Swidtag                sql.NullString        `json:"swidtag"`
	AggregationsID         sql.NullInt32         `json:"aggregations_id"`
	ProductEditor          sql.NullString        `json:"product_editor"`
	UploadedBy             string                `json:"uploaded_by"`
	UploadedAt             time.Time             `json:"uploaded_at"`
	NominativeUsersDetails pqtype.NullRawMessage `json:"nominative_users_details"`
	RecordSucceed          sql.NullInt32         `json:"record_succeed"`
	RecordFailed           sql.NullInt32         `json:"record_failed"`
	FileName               sql.NullString        `json:"file_name"`
	SheetName              sql.NullString        `json:"sheet_name"`
	FileStatus             FileStatus            `json:"file_status"`
	Pname                  interface{}           `json:"pname"`
	Nametype               interface{}           `json:"nametype"`
	ProductName            sql.NullString        `json:"product_name"`
	ProductVersion         sql.NullString        `json:"product_version"`
	AggregationName        sql.NullString        `json:"aggregation_name"`
	Jobnotcompleted        int64                 `json:"jobnotcompleted"`
}

func (q *Queries) ListNominativeUsersUploadedFiles(ctx context.Context, arg ListNominativeUsersUploadedFilesParams) ([]ListNominativeUsersUploadedFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listNominativeUsersUploadedFiles,
		pq.Array(arg.Scope),
		arg.FileUploadID,
		arg.ID,
		arg.FileNameAsc,
		arg.FileNameDesc,
		arg.FileStatusAsc,
		arg.FileStatusDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NameAsc,
		arg.NameDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.UploadedByAsc,
		arg.UploadedByDesc,
		arg.UploadedOnAsc,
		arg.UploadedOnDesc,
		arg.ProducttypeAsc,
		arg.ProducttypeDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNominativeUsersUploadedFilesRow
	for rows.Next() {
		var i ListNominativeUsersUploadedFilesRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ID,
			&i.UploadID,
			&i.Scope,
			&i.Swidtag,
			&i.AggregationsID,
			&i.ProductEditor,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.NominativeUsersDetails,
			&i.RecordSucceed,
			&i.RecordFailed,
			&i.FileName,
			&i.SheetName,
			&i.FileStatus,
			&i.Pname,
			&i.Nametype,
			&i.ProductName,
			&i.ProductVersion,
			&i.AggregationName,
			&i.Jobnotcompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductAggregation = `-- name: ListProductAggregation :many

Select
    DISTINCT agg.aggregation_name,
    agg.product_editor,
    ec.id as editor_id,
    agg.swidtags,
    COALESCE( (
            SELECT
                sum(y.num_of_applications)
            FROM (
                    SELECT
                        count(DISTINCT pa.application_id) as num_of_applications
                    FROM
                        products_applications pa
                    WHERE
                        pa.scope = $1
                        AND pa.swidtag = ANY(agg.swidtags)
                ) y
        ),
        0
    ):: INTEGER as num_of_applications,
    COALESCE( (
            SELECT
                sum(z.num_of_equipments)
            FROM (
                    SELECT
                        count(DISTINCT pe.equipment_id) as num_of_equipments
                    FROM
                        products_equipments pe
                    WHERE
                        pe.scope = $1
                        AND pe.swidtag = ANY(agg.swidtags)
                ) z
        ),
        0
    ):: INTEGER as num_of_equipments,
    COALESCE( (
            SELECT
                sum(z.num_of_users)
            FROM (
                    SELECT
                        sum(DISTINCT pe.num_of_users) as num_of_users
                    FROM
                        products_equipments pe
                    WHERE
                        pe.scope = $1
                        AND pe.swidtag = ANY(agg.swidtags)
                ) z
        ),
        0
    ):: INTEGER as num_of_users,
    agg.id,
    COALESCE(ar.total_cost, 0):: NUMERIC(15, 2) as total_cost,
    COALESCE(nu.nom_users, 0):: INTEGER as nominative_users,
    COALESCE(cu.con_users, 0):: INTEGER as concurrent_users
from aggregations agg
    LEFT JOIN (
        select
            p.product_name as name,
            p.product_version as version,
            p.swidtag as p_id
        from products p
        where
            p.scope = $1
    ) p on p_id = ANY(agg.swidtags:: TEXT [])
    LEFT JOIN (
        SELECT
            a.aggregation_id,
            sum(a.total_cost):: NUMERIC(15, 2) as total_cost
        FROM
            aggregated_rights a
        WHERE a.scope = $1
        GROUP BY
            a.aggregation_id
    ) ar ON agg.id = ar.aggregation_id
    LEFT JOIN (
        select
            count(nu.user_email) as nom_users,
            aggregations_id as agg_id
        from
            nominative_user nu
        where nu.scope = $1
        GROUP BY
            agg_id
    ) nu on agg.id = nu.agg_id
    LEFT JOIN (
        select
            sum(number_of_users) as con_users,
            aggregation_id as agg_id
        from
            product_concurrent_user cu
        where cu.scope = $1
        GROUP BY
            agg_id
    ) cu on agg.id = cu.agg_id
    LEFT JOIN editor_catalog as ec on ec.name = agg.product_editor
WHERE
    agg.scope = $1
GROUP BY
    agg.aggregation_name,
    agg.product_editor,
    agg.swidtags,
    agg.id,
    ar.total_cost,
    nu.nom_users,
    cu.con_users,
    ec.id
LIMIT
    $3 OFFSET $2
`

type ListProductAggregationParams struct {
	Scope    string `json:"scope"`
	PageNum  int32  `json:"page_num"`
	PageSize int32  `json:"page_size"`
}

type ListProductAggregationRow struct {
	AggregationName   string          `json:"aggregation_name"`
	ProductEditor     string          `json:"product_editor"`
	EditorID          sql.NullString  `json:"editor_id"`
	Swidtags          []string        `json:"swidtags"`
	NumOfApplications int32           `json:"num_of_applications"`
	NumOfEquipments   int32           `json:"num_of_equipments"`
	NumOfUsers        int32           `json:"num_of_users"`
	ID                int32           `json:"id"`
	TotalCost         decimal.Decimal `json:"total_cost"`
	NominativeUsers   int32           `json:"nominative_users"`
	ConcurrentUsers   int32           `json:"concurrent_users"`
}

func (q *Queries) ListProductAggregation(ctx context.Context, arg ListProductAggregationParams) ([]ListProductAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductAggregation, arg.Scope, arg.PageNum, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductAggregationRow
	for rows.Next() {
		var i ListProductAggregationRow
		if err := rows.Scan(
			&i.AggregationName,
			&i.ProductEditor,
			&i.EditorID,
			pq.Array(&i.Swidtags),
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.NumOfUsers,
			&i.ID,
			&i.TotalCost,
			&i.NominativeUsers,
			&i.ConcurrentUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsAggregationIndividual = `-- name: ListProductsAggregationIndividual :many

SELECT
    p.swidtag, product_name, product_version, product_edition, product_category, p.product_editor, p.scope, option_of, aggregation_id, p.aggregation_name, p.created_on, p.created_by, p.updated_on, p.updated_by, product_type, pa.swidtag, num_of_applications, products_applications.swidtag, application_id, products_applications.scope, pe.swidtag, num_of_equipments, products_equipments.swidtag, equipment_id, num_of_users, allocated_metric, products_equipments.scope, ar.id, ar.aggregation_name, ar.scope, ar.product_editor, ar.products, ar.swidtags, ar.created_on, ar.created_by, ar.updated_on, ar.updated_by, aggregations.id, aggregations.aggregation_name, aggregations.scope, aggregations.product_editor, aggregations.products, aggregations.swidtags, aggregations.created_on, aggregations.created_by, aggregations.updated_on, aggregations.updated_by,
    COALESCE(pa.num_of_applications, 0):: INTEGER as num_of_applications,
    COALESCE(pe.num_of_equipments, 0):: INTEGER as num_of_equipments
FROM products p
    LEFT JOIN (
        SELECT
            swidtag,
            count(application_id) as num_of_applications
        FROM
            products_applications
        WHERE scope = p.scope
        GROUP BY
            swidtag
    ) pa ON p.swidtag = pa.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            count(equipment_id) as num_of_equipments
        FROM
            products_equipments
        WHERE scope = p.scope
        GROUP BY
            swidtag
    ) pe ON p.swidtag = pe.swidtag
    LEFT JOIN (
        SELECT id, aggregation_name, scope, product_editor, products, swidtags, created_on, created_by, updated_on, updated_by
        FROM aggregations
        WHERE
            scope = p.scope
    ) ar ON p.swidtag = ar.swidtag
WHERE
    p.aggregation_name = $1
    and p.scope = ANY($2:: TEXT [])
`

type ListProductsAggregationIndividualParams struct {
	AggregationName string   `json:"aggregation_name"`
	Scope           []string `json:"scope"`
}

type ListProductsAggregationIndividualRow struct {
	Swidtag             string         `json:"swidtag"`
	ProductName         string         `json:"product_name"`
	ProductVersion      string         `json:"product_version"`
	ProductEdition      string         `json:"product_edition"`
	ProductCategory     string         `json:"product_category"`
	ProductEditor       string         `json:"product_editor"`
	Scope               string         `json:"scope"`
	OptionOf            string         `json:"option_of"`
	AggregationID       int32          `json:"aggregation_id"`
	AggregationName     string         `json:"aggregation_name"`
	CreatedOn           time.Time      `json:"created_on"`
	CreatedBy           string         `json:"created_by"`
	UpdatedOn           time.Time      `json:"updated_on"`
	UpdatedBy           sql.NullString `json:"updated_by"`
	ProductType         ProductType    `json:"product_type"`
	Swidtag_2           string         `json:"swidtag_2"`
	NumOfApplications   int64          `json:"num_of_applications"`
	Swidtag_3           string         `json:"swidtag_3"`
	ApplicationID       string         `json:"application_id"`
	Scope_2             string         `json:"scope_2"`
	Swidtag_4           string         `json:"swidtag_4"`
	NumOfEquipments     int64          `json:"num_of_equipments"`
	Swidtag_5           string         `json:"swidtag_5"`
	EquipmentID         string         `json:"equipment_id"`
	NumOfUsers          sql.NullInt32  `json:"num_of_users"`
	AllocatedMetric     string         `json:"allocated_metric"`
	Scope_3             string         `json:"scope_3"`
	ID                  int32          `json:"id"`
	AggregationName_2   string         `json:"aggregation_name_2"`
	Scope_4             string         `json:"scope_4"`
	ProductEditor_2     string         `json:"product_editor_2"`
	Products            []string       `json:"products"`
	Swidtags            []string       `json:"swidtags"`
	CreatedOn_2         time.Time      `json:"created_on_2"`
	CreatedBy_2         string         `json:"created_by_2"`
	UpdatedOn_2         sql.NullTime   `json:"updated_on_2"`
	UpdatedBy_2         sql.NullString `json:"updated_by_2"`
	ID_2                int32          `json:"id_2"`
	AggregationName_3   string         `json:"aggregation_name_3"`
	Scope_5             string         `json:"scope_5"`
	ProductEditor_3     string         `json:"product_editor_3"`
	Products_2          []string       `json:"products_2"`
	Swidtags_2          []string       `json:"swidtags_2"`
	CreatedOn_3         time.Time      `json:"created_on_3"`
	CreatedBy_3         string         `json:"created_by_3"`
	UpdatedOn_3         sql.NullTime   `json:"updated_on_3"`
	UpdatedBy_3         sql.NullString `json:"updated_by_3"`
	NumOfApplications_2 int32          `json:"num_of_applications_2"`
	NumOfEquipments_2   int32          `json:"num_of_equipments_2"`
}

func (q *Queries) ListProductsAggregationIndividual(ctx context.Context, arg ListProductsAggregationIndividualParams) ([]ListProductsAggregationIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsAggregationIndividual, arg.AggregationName, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsAggregationIndividualRow
	for rows.Next() {
		var i ListProductsAggregationIndividualRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductEdition,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.Scope,
			&i.OptionOf,
			&i.AggregationID,
			&i.AggregationName,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedOn,
			&i.UpdatedBy,
			&i.ProductType,
			&i.Swidtag_2,
			&i.NumOfApplications,
			&i.Swidtag_3,
			&i.ApplicationID,
			&i.Scope_2,
			&i.Swidtag_4,
			&i.NumOfEquipments,
			&i.Swidtag_5,
			&i.EquipmentID,
			&i.NumOfUsers,
			&i.AllocatedMetric,
			&i.Scope_3,
			&i.ID,
			&i.AggregationName_2,
			&i.Scope_4,
			&i.ProductEditor_2,
			pq.Array(&i.Products),
			pq.Array(&i.Swidtags),
			&i.CreatedOn_2,
			&i.CreatedBy_2,
			&i.UpdatedOn_2,
			&i.UpdatedBy_2,
			&i.ID_2,
			&i.AggregationName_3,
			&i.Scope_5,
			&i.ProductEditor_3,
			pq.Array(&i.Products_2),
			pq.Array(&i.Swidtags_2),
			&i.CreatedOn_3,
			&i.CreatedBy_3,
			&i.UpdatedOn_3,
			&i.UpdatedBy_3,
			&i.NumOfApplications_2,
			&i.NumOfEquipments_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByApplication = `-- name: ListProductsByApplication :many

Select
    count(*) OVER() AS totalRecords,
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_editor,
    COALESCE(acq.total_cost, 0):: FLOAT as total_cost,
    COALESCE(pe.num_of_equipments, 0):: INTEGER as num_of_equipments
from products p
    LEFT JOIN (
        SELECT
            swidtag,
            sum(total_cost) as total_cost
        FROM acqrights
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) acq ON p.swidtag = acq.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            count(equipment_id) as num_of_equipments
        FROM
            products_equipments
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) pe ON p.swidtag = pe.swidtag
where
    scope = ANY($1:: TEXT [])
    AND p.swidtag = ANY($2:: TEXT [])
    AND (
        CASE
            WHEN $3:: bool THEN lower(p.product_name) LIKE '%' || lower($4:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(p.product_name) = lower($4)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $6:: bool THEN lower(p.product_editor) LIKE '%' || lower($7:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(p.product_editor) = lower($7)
            ELSE TRUE
        END
    )
ORDER BY
    CASE
        WHEN $9:: bool THEN p.swidtag
    END asc,
    CASE
        WHEN $10:: bool THEN p.swidtag
    END desc,
    CASE
        WHEN $11:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $12:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $13:: bool THEN p.product_edition
    END asc,
    CASE
        WHEN $14:: bool THEN p.product_edition
    END desc,
    CASE
        WHEN $15:: bool THEN p.product_category
    END asc,
    CASE
        WHEN $16:: bool THEN p.product_category
    END desc,
    CASE
        WHEN $17:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $18:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $19:: bool THEN p.product_editor
    END asc,
    CASE
        WHEN $20:: bool THEN p.product_editor
    END desc,
    CASE
        WHEN $21:: bool THEN acq.total_cost
    END asc,
    CASE
        WHEN $22:: bool THEN acq.total_cost
    END desc
LIMIT $24
OFFSET $23
`

type ListProductsByApplicationParams struct {
	Scope               []string `json:"scope"`
	Swidtag             []string `json:"swidtag"`
	LkProductName       bool     `json:"lk_product_name"`
	ProductName         string   `json:"product_name"`
	IsProductName       bool     `json:"is_product_name"`
	LkProductEditor     bool     `json:"lk_product_editor"`
	ProductEditor       string   `json:"product_editor"`
	IsProductEditor     bool     `json:"is_product_editor"`
	SwidtagAsc          bool     `json:"swidtag_asc"`
	SwidtagDesc         bool     `json:"swidtag_desc"`
	ProductNameAsc      bool     `json:"product_name_asc"`
	ProductNameDesc     bool     `json:"product_name_desc"`
	ProductEditionAsc   bool     `json:"product_edition_asc"`
	ProductEditionDesc  bool     `json:"product_edition_desc"`
	ProductCategoryAsc  bool     `json:"product_category_asc"`
	ProductCategoryDesc bool     `json:"product_category_desc"`
	ProductVersionAsc   bool     `json:"product_version_asc"`
	ProductVersionDesc  bool     `json:"product_version_desc"`
	ProductEditorAsc    bool     `json:"product_editor_asc"`
	ProductEditorDesc   bool     `json:"product_editor_desc"`
	TotalCostAsc        bool     `json:"total_cost_asc"`
	TotalCostDesc       bool     `json:"total_cost_desc"`
	PageNum             int32    `json:"page_num"`
	PageSize            int32    `json:"page_size"`
}

type ListProductsByApplicationRow struct {
	Totalrecords    int64   `json:"totalrecords"`
	Swidtag         string  `json:"swidtag"`
	ProductName     string  `json:"product_name"`
	ProductVersion  string  `json:"product_version"`
	ProductEditor   string  `json:"product_editor"`
	TotalCost       float64 `json:"total_cost"`
	NumOfEquipments int32   `json:"num_of_equipments"`
}

func (q *Queries) ListProductsByApplication(ctx context.Context, arg ListProductsByApplicationParams) ([]ListProductsByApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByApplication,
		pq.Array(arg.Scope),
		pq.Array(arg.Swidtag),
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.TotalCostAsc,
		arg.TotalCostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsByApplicationRow
	for rows.Next() {
		var i ListProductsByApplicationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductEditor,
			&i.TotalCost,
			&i.NumOfEquipments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsForAggregation = `-- name: ListProductsForAggregation :many
SELECT acq.swidtag, acq.product_name, acq.product_editor ,acq.version as product_version
FROM acqrights acq 
WHERE acq.scope = $1 
AND acq.swidtag NOT IN (SELECT UNNEST(agg.swidtags) from aggregations agg where agg.scope = $1) 
AND acq.product_editor = $2
UNION
SELECT prd.swidtag, prd.product_name, prd.product_editor,prd.product_version
FROM products prd 
WHERE prd.scope = $1 
AND prd.swidtag NOT IN (SELECT UNNEST(agg.swidtags) from aggregations agg where agg.scope = $1)
AND prd.product_editor = $2
UNION
select vc.swid_tag_system swidtag,pc.name product_name,ec.name as product_editor,vc.name product_version from product_catalog pc 
join version_catalog vc on pc.id = vc.p_id 
left join editor_catalog as ec on pc.editorid = ec.id
WHERE ec.name = $2
AND vc.swid_tag_system NOT IN (SELECT UNNEST(agg.swidtags) from aggregations agg where agg.scope = $1)
`

type ListProductsForAggregationParams struct {
	Scope  string `json:"scope"`
	Editor string `json:"editor"`
}

type ListProductsForAggregationRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) ListProductsForAggregation(ctx context.Context, arg ListProductsForAggregationParams) ([]ListProductsForAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsForAggregation, arg.Scope, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsForAggregationRow
	for rows.Next() {
		var i ListProductsForAggregationRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsView = `-- name: ListProductsView :many

SELECT
    count(*) OVER() AS totalRecords,
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_category,
    p.product_editor,
    p.product_edition,
    pc.swid_tag_product as product_swid_tag,
    pc.id as product_id,
    v.swid_tag_version as version_swid_tag,
    ec.id as editor_id,
    COALESCE(pa.num_of_applications, 0):: INTEGER as num_of_applications,
    COALESCE(pe.num_of_equipments, 0):: INTEGER as num_of_equipments,
    COALESCE(acq.total_cost, 0):: FLOAT as cost,
    COALESCE(nom_users.nominative_users, 0):: INTEGER as nominative_users,
    COALESCE(
        conc_users.concurrent_users,
        0
    ):: INTEGER as concurrent_users,
    p.product_type:: text,
    COALESCE(pe.equipment_users, 0):: INTEGER as equipment_users
FROM products p
    LEFT JOIN (
        SELECT
            swidtag,
            count(application_id) as num_of_applications
        FROM
            products_applications
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) pa ON p.swidtag = pa.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            count(equipment_id) as num_of_equipments,
            sum(num_of_users) as equipment_users
        FROM
            products_equipments
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) pe ON p.swidtag = pe.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            sum(total_cost) as total_cost
        FROM acqrights
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) acq ON p.swidtag = acq.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            count(user_email) as nominative_users
        FROM nominative_user
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) nom_users ON p.swidtag = nom_users.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            sum(number_of_users) as concurrent_users
        FROM
            product_concurrent_user
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) conc_users ON p.swidtag = conc_users.swidtag
    Left JOIN product_catalog pc ON p.product_name = pc.name
    AND p.product_editor = pc.editor_name
    Left JOIN version_catalog v ON pc.id = v.p_id
    AND v.name = p.product_version
    LEFT JOIN editor_catalog ec ON ec.name = p.product_editor
WHERE
    p.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $2:: bool THEN lower(p.swidtag) LIKE '%' || lower($3:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $4:: bool THEN lower(p.swidtag) = lower($3)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $5:: bool THEN lower(p.product_name) LIKE '%' || lower($6:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $7:: bool THEN lower(p.product_name) = lower($6)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(p.product_editor) LIKE '%' || lower($9:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $10:: bool THEN lower(p.product_editor) = lower($9)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(p.product_type:: text) = lower($12)
            ELSE TRUE
        END
    )
GROUP BY
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_category,
    p.product_editor,
    p.product_edition,
    pa.num_of_applications,
    pe.num_of_equipments,
    pe.equipment_users,
    acq.total_cost,
    pc.swid_tag_product,
    pc.id,
    v.swid_tag_version,
    ec.id,
    nom_users.nominative_users,
    conc_users.concurrent_users,
    p.product_type
ORDER BY
    CASE
        WHEN $13:: bool THEN p.swidtag
    END asc,
    CASE
        WHEN $14:: bool THEN p.swidtag
    END desc,
    CASE
        WHEN $15:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $16:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $17:: bool THEN p.product_edition
    END asc,
    CASE
        WHEN $18:: bool THEN p.product_edition
    END desc,
    CASE
        WHEN $19:: bool THEN p.product_category
    END asc,
    CASE
        WHEN $20:: bool THEN p.product_category
    END desc,
    CASE
        WHEN $21:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $22:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $23:: bool THEN p.product_editor
    END asc,
    CASE
        WHEN $24:: bool THEN p.product_editor
    END desc,
    CASE
        WHEN $25:: bool THEN num_of_applications
    END asc,
    CASE
        WHEN $26:: bool THEN num_of_applications
    END desc,
    CASE
        WHEN $27:: bool THEN num_of_equipments
    END asc,
    CASE
        WHEN $28:: bool THEN num_of_equipments
    END desc,
    CASE
        WHEN $29:: bool THEN acq.total_cost
    END asc,
    CASE
        WHEN $30:: bool THEN acq.total_cost
    END desc,
    CASE
        WHEN $31:: bool THEN p.product_type
    END asc,
    CASE
        WHEN $32:: bool THEN p.product_type
    END desc,
    CASE
        WHEN $33:: bool  THEN concurrent_users
    END desc,
        CASE
        WHEN $34:: bool  THEN concurrent_users
    END desc,
    CASE 
        WHEN $33:: bool THEN nominative_users
    END desc,
    CASE
        WHEN $34:: bool THEN nominative_users
    END desc,
     CASE
        WHEN $33:: bool THEN equipment_users
    END desc,
    CASE
        WHEN $34:: bool THEN equipment_users
    END desc
LIMIT $36
OFFSET $35
`

type ListProductsViewParams struct {
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	IsProductType         bool     `json:"is_product_type"`
	ProductType           string   `json:"product_type"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductCategoryAsc    bool     `json:"product_category_asc"`
	ProductCategoryDesc   bool     `json:"product_category_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	ProductTypeAsc        bool     `json:"product_type_asc"`
	ProductTypeDesc       bool     `json:"product_type_desc"`
	UsersAsc              bool     `json:"users_asc"`
	UsersDesc             bool     `json:"users_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRow struct {
	Totalrecords      int64          `json:"totalrecords"`
	Swidtag           string         `json:"swidtag"`
	ProductName       string         `json:"product_name"`
	ProductVersion    string         `json:"product_version"`
	ProductCategory   string         `json:"product_category"`
	ProductEditor     string         `json:"product_editor"`
	ProductEdition    string         `json:"product_edition"`
	ProductSwidTag    sql.NullString `json:"product_swid_tag"`
	ProductID         sql.NullString `json:"product_id"`
	VersionSwidTag    sql.NullString `json:"version_swid_tag"`
	EditorID          sql.NullString `json:"editor_id"`
	NumOfApplications int32          `json:"num_of_applications"`
	NumOfEquipments   int32          `json:"num_of_equipments"`
	Cost              float64        `json:"cost"`
	NominativeUsers   int32          `json:"nominative_users"`
	ConcurrentUsers   int32          `json:"concurrent_users"`
	PProductType      string         `json:"p_product_type"`
	EquipmentUsers    int32          `json:"equipment_users"`
}

func (q *Queries) ListProductsView(ctx context.Context, arg ListProductsViewParams) ([]ListProductsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsView,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.IsProductType,
		arg.ProductType,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.ProductTypeAsc,
		arg.ProductTypeDesc,
		arg.UsersAsc,
		arg.UsersDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRow
	for rows.Next() {
		var i ListProductsViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.ProductSwidTag,
			&i.ProductID,
			&i.VersionSwidTag,
			&i.EditorID,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
			&i.NominativeUsers,
			&i.ConcurrentUsers,
			&i.PProductType,
			&i.EquipmentUsers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsViewRedirectedApplication = `-- name: ListProductsViewRedirectedApplication :many

SELECT
    count(*) OVER() AS totalRecords,
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_category,
    p.product_editor,
    p.product_edition,
    COALESCE(pa.num_of_applications, 0):: INTEGER as num_of_applications,
    COALESCE(pe.num_of_equipments, 0):: INTEGER as num_of_equipments,
    pe.equipment_ids,
    COALESCE(acq.total_cost, 0):: FLOAT as cost
FROM products p
    INNER JOIN (
        SELECT
            swidtag,
            count(application_id) as num_of_applications
        FROM
            products_applications
        WHERE
            scope = ANY($1:: TEXT [])
            AND (
                CASE
                    WHEN $2:: bool THEN application_id = $3
                    ELSE TRUE
                END
            )
        GROUP BY
            swidtag
    ) pa ON p.swidtag = pa.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            count(equipment_id) as num_of_equipments,
            ARRAY_AGG(equipment_id):: TEXT [] as equipment_ids
        FROM
            products_equipments
        WHERE
            scope = ANY($1:: TEXT [])
            AND (
                CASE
                    WHEN $4:: bool THEN equipment_id = ANY($5:: TEXT [])
                    ELSE TRUE
                END
            )
        GROUP BY
            swidtag
    ) pe ON p.swidtag = pe.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            sum(total_cost) as total_cost
        FROM acqrights
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) acq ON p.swidtag = acq.swidtag
WHERE
    p.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $6:: bool THEN lower(p.swidtag) LIKE '%' || lower($7:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(p.swidtag) = lower($7)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $9:: bool THEN lower(p.product_name) LIKE '%' || lower($10:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(p.product_name) = lower($10)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $12:: bool THEN lower(p.product_editor) LIKE '%' || lower($13:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(p.product_editor) = lower($13)
            ELSE TRUE
        END
    )
GROUP BY
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_category,
    p.product_editor,
    p.product_edition,
    pa.num_of_applications,
    pe.num_of_equipments,
    pe.equipment_ids,
    acq.total_cost
ORDER BY
    CASE
        WHEN $15:: bool THEN p.swidtag
    END asc,
    CASE
        WHEN $16:: bool THEN p.swidtag
    END desc,
    CASE
        WHEN $17:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $18:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $19:: bool THEN p.product_edition
    END asc,
    CASE
        WHEN $20:: bool THEN p.product_edition
    END desc,
    CASE
        WHEN $21:: bool THEN p.product_category
    END asc,
    CASE
        WHEN $22:: bool THEN p.product_category
    END desc,
    CASE
        WHEN $23:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $24:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $25:: bool THEN p.product_editor
    END asc,
    CASE
        WHEN $26:: bool THEN p.product_editor
    END desc,
    CASE
        WHEN $27:: bool THEN num_of_applications
    END asc,
    CASE
        WHEN $28:: bool THEN num_of_applications
    END desc,
    CASE
        WHEN $29:: bool THEN num_of_equipments
    END asc,
    CASE
        WHEN $30:: bool THEN num_of_equipments
    END desc,
    CASE
        WHEN $31:: bool THEN acq.total_cost
    END asc,
    CASE
        WHEN $32:: bool THEN acq.total_cost
    END desc
LIMIT $34
OFFSET $33
`

type ListProductsViewRedirectedApplicationParams struct {
	Scope                 []string `json:"scope"`
	IsApplicationID       bool     `json:"is_application_id"`
	ApplicationID         string   `json:"application_id"`
	IsEquipmentID         bool     `json:"is_equipment_id"`
	EquipmentIds          []string `json:"equipment_ids"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductCategoryAsc    bool     `json:"product_category_asc"`
	ProductCategoryDesc   bool     `json:"product_category_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRedirectedApplicationRow struct {
	Totalrecords      int64    `json:"totalrecords"`
	Swidtag           string   `json:"swidtag"`
	ProductName       string   `json:"product_name"`
	ProductVersion    string   `json:"product_version"`
	ProductCategory   string   `json:"product_category"`
	ProductEditor     string   `json:"product_editor"`
	ProductEdition    string   `json:"product_edition"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	EquipmentIds      []string `json:"equipment_ids"`
	Cost              float64  `json:"cost"`
}

func (q *Queries) ListProductsViewRedirectedApplication(ctx context.Context, arg ListProductsViewRedirectedApplicationParams) ([]ListProductsViewRedirectedApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsViewRedirectedApplication,
		pq.Array(arg.Scope),
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.IsEquipmentID,
		pq.Array(arg.EquipmentIds),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRedirectedApplicationRow
	for rows.Next() {
		var i ListProductsViewRedirectedApplicationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			pq.Array(&i.EquipmentIds),
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsViewRedirectedEquipment = `-- name: ListProductsViewRedirectedEquipment :many

SELECT
    count(*) OVER() AS totalRecords,
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_category,
    p.product_editor,
    p.product_edition,
    pe.allocated_metric,
    COALESCE(pa.num_of_applications, 0):: INTEGER as num_of_applications,
    COALESCE(pe.equipment_users, 0):: INTEGER as equipment_users,
    COALESCE(pe.num_of_equipments, 0):: INTEGER as num_of_equipments,
    COALESCE(acq.total_cost, 0):: FLOAT as cost
FROM products p
    LEFT JOIN (
        SELECT
            swidtag,
            count(application_id) as num_of_applications
        FROM
            products_applications
        WHERE
            scope = ANY($1:: TEXT [])
            AND (
                CASE
                    WHEN $2:: bool THEN application_id = $3
                    ELSE TRUE
                END
            )
        GROUP BY
            swidtag
    ) pa ON p.swidtag = pa.swidtag
    INNER JOIN (
        SELECT
            swidtag,
            count(equipment_id) as num_of_equipments,
            sum(num_of_users) as equipment_users,
            allocated_metric
        FROM
            products_equipments
        WHERE
            scope = ANY($1:: TEXT [])
            AND (
                CASE
                    WHEN $4:: bool THEN equipment_id = $5
                    ELSE TRUE
                END
            )
        GROUP BY
            swidtag,
            allocated_metric
    ) pe ON p.swidtag = pe.swidtag
    LEFT JOIN (
        SELECT
            swidtag,
            sum(total_cost) as total_cost
        FROM acqrights
        WHERE
            scope = ANY($1:: TEXT [])
        GROUP BY
            swidtag
    ) acq ON p.swidtag = acq.swidtag
WHERE
    p.scope = ANY($1:: TEXT [])
    AND (
        CASE
            WHEN $6:: bool THEN lower(p.swidtag) LIKE '%' || lower($7:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $8:: bool THEN lower(p.swidtag) = lower($7)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $9:: bool THEN lower(p.product_name) LIKE '%' || lower($10:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $11:: bool THEN lower(p.product_name) = lower($10)
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $12:: bool THEN lower(p.product_editor) LIKE '%' || lower($13:: TEXT) || '%'
            ELSE TRUE
        END
    )
    AND (
        CASE
            WHEN $14:: bool THEN lower(p.product_editor) = lower($13)
            ELSE TRUE
        END
    )
GROUP BY
    p.swidtag,
    p.product_name,
    p.product_version,
    p.product_category,
    p.product_editor,
    p.product_edition,
    pa.num_of_applications,
    pe.equipment_users,
    pe.allocated_metric,
    pe.num_of_equipments,
    acq.total_cost
ORDER BY
    CASE
        WHEN $15:: bool THEN p.swidtag
    END asc,
    CASE
        WHEN $16:: bool THEN p.swidtag
    END desc,
    CASE
        WHEN $17:: bool THEN p.product_name
    END asc,
    CASE
        WHEN $18:: bool THEN p.product_name
    END desc,
    CASE
        WHEN $19:: bool THEN p.product_edition
    END asc,
    CASE
        WHEN $20:: bool THEN p.product_edition
    END desc,
    CASE
        WHEN $21:: bool THEN p.product_category
    END asc,
    CASE
        WHEN $22:: bool THEN p.product_category
    END desc,
    CASE
        WHEN $23:: bool THEN p.product_version
    END asc,
    CASE
        WHEN $24:: bool THEN p.product_version
    END desc,
    CASE
        WHEN $25:: bool THEN p.product_editor
    END asc,
    CASE
        WHEN $26:: bool THEN p.product_editor
    END desc,
    CASE
        WHEN $27:: bool THEN num_of_applications
    END asc,
    CASE
        WHEN $28:: bool THEN num_of_applications
    END desc,
    CASE
        WHEN $29:: bool THEN num_of_equipments
    END asc,
    CASE
        WHEN $30:: bool THEN num_of_equipments
    END desc,
    CASE
        WHEN $31:: bool THEN acq.total_cost
    END asc,
    CASE
        WHEN $32:: bool THEN acq.total_cost
    END desc
LIMIT $34
OFFSET $33
`

type ListProductsViewRedirectedEquipmentParams struct {
	Scope                 []string `json:"scope"`
	IsApplicationID       bool     `json:"is_application_id"`
	ApplicationID         string   `json:"application_id"`
	IsEquipmentID         bool     `json:"is_equipment_id"`
	EquipmentID           string   `json:"equipment_id"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductCategoryAsc    bool     `json:"product_category_asc"`
	ProductCategoryDesc   bool     `json:"product_category_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRedirectedEquipmentRow struct {
	Totalrecords      int64   `json:"totalrecords"`
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	AllocatedMetric   string  `json:"allocated_metric"`
	NumOfApplications int32   `json:"num_of_applications"`
	EquipmentUsers    int32   `json:"equipment_users"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListProductsViewRedirectedEquipment(ctx context.Context, arg ListProductsViewRedirectedEquipmentParams) ([]ListProductsViewRedirectedEquipmentRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsViewRedirectedEquipment,
		pq.Array(arg.Scope),
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.IsEquipmentID,
		arg.EquipmentID,
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRedirectedEquipmentRow
	for rows.Next() {
		var i ListProductsViewRedirectedEquipmentRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.AllocatedMetric,
			&i.NumOfApplications,
			&i.EquipmentUsers,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSelectedProductsForAggregration = `-- name: ListSelectedProductsForAggregration :many
SELECT acq.swidtag, acq.product_name, acq.product_editor,acq.version as product_version
FROM acqrights acq 
WHERE acq.scope = $1 
AND acq.swidtag IN (SELECT UNNEST(agg.swidtags) from aggregations agg where agg.scope = $1 and agg.id = $2) 
UNION
SELECT prd.swidtag, prd.product_name, prd.product_editor, prd.product_version
FROM products prd 
WHERE prd.scope = $1 
AND prd.swidtag IN (SELECT UNNEST(agg.swidtags) from aggregations agg where agg.scope = $1 and agg.id = $2)
UNION
select vc.swid_tag_system swidtag,pc.name product_name,ec.name as product_editor,vc.name product_version from product_catalog pc 
join version_catalog vc on pc.id = vc.p_id 
left join editor_catalog ec on pc.editorid = ec.id
WHERE ec.name =  $3
AND vc.swid_tag_system  IN (SELECT UNNEST(agg.swidtags) from aggregations agg where agg.scope = $1 and agg.id = $2)
`

type ListSelectedProductsForAggregrationParams struct {
	Scope  string `json:"scope"`
	ID     int32  `json:"id"`
	Editor string `json:"editor"`
}

type ListSelectedProductsForAggregrationRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) ListSelectedProductsForAggregration(ctx context.Context, arg ListSelectedProductsForAggregrationParams) ([]ListSelectedProductsForAggregrationRow, error) {
	rows, err := q.db.QueryContext(ctx, listSelectedProductsForAggregration, arg.Scope, arg.ID, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSelectedProductsForAggregrationRow
	for rows.Next() {
		var i ListSelectedProductsForAggregrationRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnderusageByEditor = `-- name: ListUnderusageByEditor :many
SELECT 
    count(*) OVER() AS totalRecords,
    (delta_number):: Numeric(15, 2) as delta,
    metrics,
    product_names,
    aggregation_name,
    scope  FROM
    overall_computed_licences
WHERE
    scope = ANY($1:: TEXT [])
    AND cost_optimization = FALSE
    AND metic_not_defined = FALSE
    AND (
        CASE
            WHEN $2:: bool THEN lower(editor) = lower($3)
            ELSE TRUE
        END 
    )
    AND (
        CASE
            WHEN $4:: bool THEN lower(product_names) = lower($5)
            ELSE TRUE
        END 
    )
GROUP BY
    overall_computed_licences.scope,
    overall_computed_licences.metrics,
    overall_computed_licences.delta_number,
    overall_computed_licences.product_names,
    overall_computed_licences.aggregation_name
HAVING (overall_computed_licences.delta_number) > 0
ORDER BY
    CASE
        WHEN $6:: bool THEN overall_computed_licences.scope
    END asc,
    CASE
        WHEN $7:: bool THEN overall_computed_licences.scope
    END desc,
    CASE
        WHEN $8:: bool THEN overall_computed_licences.metrics
    END asc,
    CASE
        WHEN $9:: bool THEN overall_computed_licences.metrics
    END desc,
    CASE
        WHEN $10:: bool THEN overall_computed_licences.delta_number
    END asc,
    CASE
        WHEN $11:: bool THEN overall_computed_licences.delta_number
    END desc
`

type ListUnderusageByEditorParams struct {
	Scope           []string `json:"scope"`
	LkEditor        bool     `json:"lk_editor"`
	Editor          string   `json:"editor"`
	LkProductNames  bool     `json:"lk_product_names"`
	ProductNames    string   `json:"product_names"`
	ScopeAsc        bool     `json:"scope_asc"`
	ScopeDesc       bool     `json:"scope_desc"`
	MetricsAsc      bool     `json:"metrics_asc"`
	MetricsDesc     bool     `json:"metrics_desc"`
	DeltaNumberAsc  bool     `json:"delta_number_asc"`
	DeltaNumberDesc bool     `json:"delta_number_desc"`
}

type ListUnderusageByEditorRow struct {
	Totalrecords    int64           `json:"totalrecords"`
	Delta           decimal.Decimal `json:"delta"`
	Metrics         string          `json:"metrics"`
	ProductNames    string          `json:"product_names"`
	AggregationName string          `json:"aggregation_name"`
	Scope           string          `json:"scope"`
}

func (q *Queries) ListUnderusageByEditor(ctx context.Context, arg ListUnderusageByEditorParams) ([]ListUnderusageByEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, listUnderusageByEditor,
		pq.Array(arg.Scope),
		arg.LkEditor,
		arg.Editor,
		arg.LkProductNames,
		arg.ProductNames,
		arg.ScopeAsc,
		arg.ScopeDesc,
		arg.MetricsAsc,
		arg.MetricsDesc,
		arg.DeltaNumberAsc,
		arg.DeltaNumberDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnderusageByEditorRow
	for rows.Next() {
		var i ListUnderusageByEditorRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Delta,
			&i.Metrics,
			&i.ProductNames,
			&i.AggregationName,
			&i.Scope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overDeployedProductsCosts = `-- name: OverDeployedProductsCosts :many

SELECT
    swidtags as swid_tags,
    product_names as product_names,
    aggregation_name as aggregation_name,
    computed_cost:: Numeric(15, 2) as computed_cost,
    purchase_cost:: Numeric(15, 2) as purchase_cost, (delta_cost):: Numeric(15, 2) as delta_cost
FROM
    overall_computed_licences
WHERE
    scope = $1
    AND editor = $2
    AND cost_optimization = FALSE
GROUP BY
    swidtags,
    product_names,
    aggregation_name,
    purchase_cost,
    computed_cost,
    delta_cost
HAVING (delta_cost) > 0
ORDER BY delta_cost ASC
LIMIT 5
`

type OverDeployedProductsCostsParams struct {
	Scope  string `json:"scope"`
	Editor string `json:"editor"`
}

type OverDeployedProductsCostsRow struct {
	SwidTags        string          `json:"swid_tags"`
	ProductNames    string          `json:"product_names"`
	AggregationName string          `json:"aggregation_name"`
	ComputedCost    decimal.Decimal `json:"computed_cost"`
	PurchaseCost    decimal.Decimal `json:"purchase_cost"`
	DeltaCost       decimal.Decimal `json:"delta_cost"`
}

func (q *Queries) OverDeployedProductsCosts(ctx context.Context, arg OverDeployedProductsCostsParams) ([]OverDeployedProductsCostsRow, error) {
	rows, err := q.db.QueryContext(ctx, overDeployedProductsCosts, arg.Scope, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverDeployedProductsCostsRow
	for rows.Next() {
		var i OverDeployedProductsCostsRow
		if err := rows.Scan(
			&i.SwidTags,
			&i.ProductNames,
			&i.AggregationName,
			&i.ComputedCost,
			&i.PurchaseCost,
			&i.DeltaCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overDeployedProductsLicences = `-- name: OverDeployedProductsLicences :many

SELECT
    swidtags as swid_tags,
    product_names as product_names,
    aggregation_name as aggregation_name,
    num_computed_licences:: Numeric(15, 2) as num_computed_licences,
    num_acquired_licences:: Numeric(15, 2) as num_acquired_licences, (delta_number):: Numeric(15, 2) as delta
FROM
    overall_computed_licences
WHERE
    scope = $1
    AND editor = $2
    AND cost_optimization = FALSE
GROUP BY
    swidtags,
    product_names,
    aggregation_name,
    num_acquired_licences,
    num_computed_licences,
    delta_number
HAVING (delta_number) > 0
ORDER BY delta ASC
LIMIT 5
`

type OverDeployedProductsLicencesParams struct {
	Scope  string `json:"scope"`
	Editor string `json:"editor"`
}

type OverDeployedProductsLicencesRow struct {
	SwidTags            string          `json:"swid_tags"`
	ProductNames        string          `json:"product_names"`
	AggregationName     string          `json:"aggregation_name"`
	NumComputedLicences decimal.Decimal `json:"num_computed_licences"`
	NumAcquiredLicences decimal.Decimal `json:"num_acquired_licences"`
	Delta               decimal.Decimal `json:"delta"`
}

func (q *Queries) OverDeployedProductsLicences(ctx context.Context, arg OverDeployedProductsLicencesParams) ([]OverDeployedProductsLicencesRow, error) {
	rows, err := q.db.QueryContext(ctx, overDeployedProductsLicences, arg.Scope, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverDeployedProductsLicencesRow
	for rows.Next() {
		var i OverDeployedProductsLicencesRow
		if err := rows.Scan(
			&i.SwidTags,
			&i.ProductNames,
			&i.AggregationName,
			&i.NumComputedLicences,
			&i.NumAcquiredLicences,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overdeployPercent = `-- name: OverdeployPercent :one

select
    coalesce(sum(num_acquired_licences), 0):: Numeric(15, 2) as acq,
    coalesce(abs(sum(delta_number)), 0):: Numeric(15, 2) as delta_rights
from
    overall_computed_licences ocl
where
    ocl.scope = $1
    AND ocl.delta_number >= 0
`

type OverdeployPercentRow struct {
	Acq         decimal.Decimal `json:"acq"`
	DeltaRights decimal.Decimal `json:"delta_rights"`
}

func (q *Queries) OverdeployPercent(ctx context.Context, scope string) (OverdeployPercentRow, error) {
	row := q.db.QueryRowContext(ctx, overdeployPercent, scope)
	var i OverdeployPercentRow
	err := row.Scan(&i.Acq, &i.DeltaRights)
	return i, err
}

const productCatalogVersion = `-- name: ProductCatalogVersion :many

Select final.version,
       final.swidtag
 FROM   
 ( SELECT
    COALESCE(vc.name, '') AS version,
    vc.swid_tag_system AS swidtag
FROM
    version_catalog vc
WHERE
    vc.swid_tag_system = ANY($1 :: TEXT [])
 UNION
   SELECT
            acq.version as vesrion,
            acq.swidtag as swidtag
        FROM
            acqrights acq
        WHERE
            acq.swidtag = ANY($1 :: TEXT [])
            AND acq.scope = $2 ) AS final
`

type ProductCatalogVersionParams struct {
	Swidtag []string `json:"swidtag"`
	Scope   string   `json:"scope"`
}

type ProductCatalogVersionRow struct {
	Version string `json:"version"`
	Swidtag string `json:"swidtag"`
}

func (q *Queries) ProductCatalogVersion(ctx context.Context, arg ProductCatalogVersionParams) ([]ProductCatalogVersionRow, error) {
	rows, err := q.db.QueryContext(ctx, productCatalogVersion, pq.Array(arg.Swidtag), arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductCatalogVersionRow
	for rows.Next() {
		var i ProductCatalogVersionRow
		if err := rows.Scan(&i.Version, &i.Swidtag); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productMaintenanceCount = `-- name: ProductMaintenanceCount :many

WITH swidtag_union AS (
    SELECT
        unnest(a.swidtags) as swidtag
    FROM
        aggregations a
    WHERE
        scope = $1
    UNION
    SELECT
        swidtag
    FROM
        acqrights
    WHERE
        scope = $1
)
SELECT
    (
        SELECT COUNT(final.swidtag)
        FROM (
            SELECT unnest(a.swidtags) AS swidtag
            FROM aggregated_rights AS ar
            JOIN aggregations AS a ON ar.aggregation_id = a.id
            WHERE ar.scope = $1
                AND (
                    ar.start_of_maintenance IS NOT NULL
                    AND ar.end_of_maintenance > CURRENT_DATE
                    AND ar.start_of_maintenance < CURRENT_DATE
                )
            UNION
            SELECT acq.swidtag
            FROM acqrights AS acq
            WHERE acq.scope = $1
                AND (
                    acq.start_of_maintenance IS NOT NULL
                    AND acq.end_of_maintenance > CURRENT_DATE
                    AND acq.start_of_maintenance < CURRENT_DATE
                )
        ) AS final
    ) AS number_of_swidtag,
    (
        SELECT COUNT(swidtag)
        FROM swidtag_union
    ) AS total
`

type ProductMaintenanceCountRow struct {
	NumberOfSwidtag int64 `json:"number_of_swidtag"`
	Total           int64 `json:"total"`
}

func (q *Queries) ProductMaintenanceCount(ctx context.Context, scope string) ([]ProductMaintenanceCountRow, error) {
	rows, err := q.db.QueryContext(ctx, productMaintenanceCount, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductMaintenanceCountRow
	for rows.Next() {
		var i ProductMaintenanceCountRow
		if err := rows.Scan(&i.NumberOfSwidtag, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productNoMaintenance = `-- name: ProductNoMaintenance :many
SELECT
    final.swidtag,
    final.product_name
FROM
    (
        SELECT
            acq.product_name,
            acq.swidtag
        FROM
            acqrights acq
        WHERE
            acq.swidtag = ANY($1 :: TEXT [])
            AND acq.scope = $2
        UNION
        SELECT
            CASE WHEN agg.product_name IS NULL THEN '' ELSE agg.product_name END AS product_name,
            agg.swidtag AS swidtag
        FROM 
        (
        SELECT
            UNNEST(ag.products) AS product_name,
            UNNEST(ag.swidtags) AS swidtag
        FROM
            aggregations ag
        WHERE
            ($1 :: TEXT []) && ag.swidtags 
            AND ag.scope = $2
        ) AS agg
    ) AS final
`

type ProductNoMaintenanceParams struct {
	Swidtag []string `json:"swidtag"`
	Scope   string   `json:"scope"`
}

type ProductNoMaintenanceRow struct {
	Swidtag     string `json:"swidtag"`
	ProductName string `json:"product_name"`
}

func (q *Queries) ProductNoMaintenance(ctx context.Context, arg ProductNoMaintenanceParams) ([]ProductNoMaintenanceRow, error) {
	rows, err := q.db.QueryContext(ctx, productNoMaintenance, pq.Array(arg.Swidtag), arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductNoMaintenanceRow
	for rows.Next() {
		var i ProductNoMaintenanceRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productsNotAcquired = `-- name: ProductsNotAcquired :many
SELECT swidtag, product_name, product_editor, product_version,ec.id  FROM products
Left Join editor_catalog as ec on ec.name = products.product_editor
WHERE products.swidtag NOT IN (SELECT swidtag FROM acqrights WHERE acqrights.scope = $1 UNION SELECT unnest(swidtags) as swidtags from aggregations INNER JOIN aggregated_rights ON aggregations.id = aggregated_rights.aggregation_id where aggregations.scope = $1)
AND products.product_name NOT IN (  SELECT product_name FROM acqrights WHERE acqrights.scope =  $1)
AND products.swidtag IN (SELECT swidtag FROM products_equipments WHERE products_equipments.scope = $1)
AND products.scope = $1
`

type ProductsNotAcquiredRow struct {
	Swidtag        string         `json:"swidtag"`
	ProductName    string         `json:"product_name"`
	ProductEditor  string         `json:"product_editor"`
	ProductVersion string         `json:"product_version"`
	ID             sql.NullString `json:"id"`
}

func (q *Queries) ProductsNotAcquired(ctx context.Context, scope string) ([]ProductsNotAcquiredRow, error) {
	rows, err := q.db.QueryContext(ctx, productsNotAcquired, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsNotAcquiredRow
	for rows.Next() {
		var i ProductsNotAcquiredRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.ProductVersion,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productsNotDeployed = `-- name: ProductsNotDeployed :many
SELECT DISTINCT(acqrights.swidtag), acqrights.product_name, acqrights.product_editor,ec.id, version FROM acqrights 
LEFT JOIN products as p on p.product_name=acqrights.product_name AND p.product_editor=acqrights.product_editor 
Left Join editor_catalog as ec on ec.name = acqrights.product_editor
WHERE acqrights.swidtag NOT IN (SELECT swidtag FROM products_equipments WHERE products_equipments.scope = $1)
AND acqrights.scope = $1 AND p.product_type='ONPREMISE'
`

type ProductsNotDeployedRow struct {
	Swidtag       string         `json:"swidtag"`
	ProductName   string         `json:"product_name"`
	ProductEditor string         `json:"product_editor"`
	ID            sql.NullString `json:"id"`
	Version       string         `json:"version"`
}

func (q *Queries) ProductsNotDeployed(ctx context.Context, scope string) ([]ProductsNotDeployedRow, error) {
	rows, err := q.db.QueryContext(ctx, productsNotDeployed, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsNotDeployedRow
	for rows.Next() {
		var i ProductsNotDeployedRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.ID,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productsPerMetric = `-- name: ProductsPerMetric :many

SELECT
    x.metric as metric,
    SUM(x.composition) as composition
FROM(
        SELECT
            acq.metric,
            count(acq.swidtag) as composition
        FROM acqrights acq
        Where
            acq.scope = $1
        GROUP BY acq.metric
        UNION ALL
        SELECT
            agr.metric,
            count(agr.aggregation_id) as composition
        FROM
            aggregated_rights agr
        Where
            agr.scope = $1
        GROUP BY agr.metric
    ) x
GROUP BY x.metric
`

type ProductsPerMetricRow struct {
	Metric      string `json:"metric"`
	Composition int64  `json:"composition"`
}

func (q *Queries) ProductsPerMetric(ctx context.Context, scope string) ([]ProductsPerMetricRow, error) {
	rows, err := q.db.QueryContext(ctx, productsPerMetric, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsPerMetricRow
	for rows.Next() {
		var i ProductsPerMetricRow
		if err := rows.Scan(&i.Metric, &i.Composition); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalCostOfEachScope = `-- name: TotalCostOfEachScope :many
    
SELECT
    COALESCE(SUM(total_cost), 0)::NUMERIC(15, 2) AS total_cost,
    a.scope
FROM (
    SELECT
        SUM(total_cost)::NUMERIC(15, 2) AS total_cost,
        scope
    FROM acqrights
    WHERE
        scope = ANY($1::TEXT[])
    GROUP BY scope
    UNION ALL
    SELECT
        SUM(total_cost)::NUMERIC(15, 2) AS total_cost,
        scope
    FROM aggregated_rights
    WHERE
        scope = ANY($1::TEXT[])
    GROUP BY scope
) a
GROUP BY a.scope
`

type TotalCostOfEachScopeRow struct {
	TotalCost decimal.Decimal `json:"total_cost"`
	Scope     string          `json:"scope"`
}

func (q *Queries) TotalCostOfEachScope(ctx context.Context, scope []string) ([]TotalCostOfEachScopeRow, error) {
	rows, err := q.db.QueryContext(ctx, totalCostOfEachScope, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TotalCostOfEachScopeRow
	for rows.Next() {
		var i TotalCostOfEachScopeRow
		if err := rows.Scan(&i.TotalCost, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const totalProductsOfScope = `-- name: TotalProductsOfScope :many

SELECT Coalesce(COUNT(proacq.product_name),0):: INTEGER as total from
(SELECT
    DISTINCT p.product_name
FROM
    products as p
where
    p.scope = $1
UNION
SELECT
    DISTINCT acq.product_name
FROM
    acqrights as acq
where
    acq.scope = $1) as proacq
`

func (q *Queries) TotalProductsOfScope(ctx context.Context, scope string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, totalProductsOfScope, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var total int32
		if err := rows.Scan(&total); err != nil {
			return nil, err
		}
		items = append(items, total)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trueCost = `-- name: TrueCost :many
SELECT editor, product_names,aggregation_name, coalesce(sum(delta_cost), 0.0) :: FLOAT AS cost
FROM overall_computed_licences
WHERE delta_cost < 0 and scope = $1
GROUP BY editor, product_names,aggregation_name
`

type TrueCostRow struct {
	Editor          string  `json:"editor"`
	ProductNames    string  `json:"product_names"`
	AggregationName string  `json:"aggregation_name"`
	Cost            float64 `json:"cost"`
}

func (q *Queries) TrueCost(ctx context.Context, scope string) ([]TrueCostRow, error) {
	rows, err := q.db.QueryContext(ctx, trueCost, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TrueCostRow
	for rows.Next() {
		var i TrueCostRow
		if err := rows.Scan(
			&i.Editor,
			&i.ProductNames,
			&i.AggregationName,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAggregation = `-- name: UpdateAggregation :exec

UPDATE aggregations
SET
    aggregation_name = $1,
    product_editor = $2,
    products = $3,
    swidtags = $4,
    updated_by = $5
WHERE id = $6 AND scope = $7
`

type UpdateAggregationParams struct {
	AggregationName string         `json:"aggregation_name"`
	ProductEditor   string         `json:"product_editor"`
	ProductNames    []string       `json:"product_names"`
	Swidtags        []string       `json:"swidtags"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	ID              int32          `json:"id"`
	Scope           string         `json:"scope"`
}

func (q *Queries) UpdateAggregation(ctx context.Context, arg UpdateAggregationParams) error {
	_, err := q.db.ExecContext(ctx, updateAggregation,
		arg.AggregationName,
		arg.ProductEditor,
		pq.Array(arg.ProductNames),
		pq.Array(arg.Swidtags),
		arg.UpdatedBy,
		arg.ID,
		arg.Scope,
	)
	return err
}

const upsertAcqRights = `-- name: UpsertAcqRights :exec

INSERT INTO
    acqrights (
        sku,
        swidtag,
        product_name,
        product_editor,
        scope,
        metric,
        num_licenses_acquired,
        avg_unit_price,
        avg_maintenance_unit_price,
        total_purchase_cost,
        total_maintenance_cost,
        total_cost,
        created_by,
        start_of_maintenance,
        end_of_maintenance,
        num_licences_maintainance,
        version,
        comment,
        last_purchased_order,
        support_numbers,
        maintenance_provider,
        ordering_date,
        corporate_sourcing_contract,
        software_provider,
        file_name,
        file_data,
        repartition
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20,
        $21,
        $22,
        $23,
        $24,
        $25,
        $26,
        $27
    ) ON CONFLICT (sku, scope)
DO
UPDATE
SET
    swidtag = $2,
    product_name = $3,
    product_editor = $4,
    scope = $5,
    metric = $6,
    num_licenses_acquired = $7,
    avg_unit_price = $8,
    avg_maintenance_unit_price = $9,
    total_purchase_cost = $10,
    total_maintenance_cost = $11,
    total_cost = $12,
    updated_by = $13,
    start_of_maintenance = $14,
    end_of_maintenance = $15,
    num_licences_maintainance = $16,
    version = $17,
    comment = $18,
    last_purchased_order = $19,
    support_numbers = $20,
    maintenance_provider = $21,
    ordering_date = $22,
    corporate_sourcing_contract = $23,
    software_provider = $24,
    file_name = $25,
    file_data = $26,
    repartition = $27
`

type UpsertAcqRightsParams struct {
	Sku                       string          `json:"sku"`
	Swidtag                   string          `json:"swidtag"`
	ProductName               string          `json:"product_name"`
	ProductEditor             string          `json:"product_editor"`
	Scope                     string          `json:"scope"`
	Metric                    string          `json:"metric"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	CreatedBy                 string          `json:"created_by"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	NumLicencesMaintainance   int32           `json:"num_licences_maintainance"`
	Version                   string          `json:"version"`
	Comment                   sql.NullString  `json:"comment"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	SoftwareProvider          string          `json:"software_provider"`
	FileName                  string          `json:"file_name"`
	FileData                  []byte          `json:"file_data"`
	Repartition               bool            `json:"repartition"`
}

func (q *Queries) UpsertAcqRights(ctx context.Context, arg UpsertAcqRightsParams) error {
	_, err := q.db.ExecContext(ctx, upsertAcqRights,
		arg.Sku,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductEditor,
		arg.Scope,
		arg.Metric,
		arg.NumLicensesAcquired,
		arg.AvgUnitPrice,
		arg.AvgMaintenanceUnitPrice,
		arg.TotalPurchaseCost,
		arg.TotalMaintenanceCost,
		arg.TotalCost,
		arg.CreatedBy,
		arg.StartOfMaintenance,
		arg.EndOfMaintenance,
		arg.NumLicencesMaintainance,
		arg.Version,
		arg.Comment,
		arg.LastPurchasedOrder,
		pq.Array(arg.SupportNumbers),
		arg.MaintenanceProvider,
		arg.OrderingDate,
		arg.CorporateSourcingContract,
		arg.SoftwareProvider,
		arg.FileName,
		arg.FileData,
		arg.Repartition,
	)
	return err
}

const upsertAggregatedRights = `-- name: UpsertAggregatedRights :exec

INSERT INTO
    aggregated_rights (
        sku,
        scope,
        aggregation_id,
        metric,
        ordering_date,
        corporate_sourcing_contract,
        software_provider,
        num_licenses_acquired,
        avg_unit_price,
        avg_maintenance_unit_price,
        total_purchase_cost,
        total_maintenance_cost,
        total_cost,
        created_by,
        start_of_maintenance,
        end_of_maintenance,
        last_purchased_order,
        support_numbers,
        maintenance_provider,
        num_licences_maintenance,
        comment,
        file_name,
        file_data,
        repartition
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18,
        $19,
        $20,
        $21,
        $22,
        $23,
        $24
    ) ON CONFLICT (sku, scope)
DO
UPDATE
SET
    aggregation_id = $3,
    metric = $4,
    ordering_date = $5,
    corporate_sourcing_contract = $6,
    software_provider = $7,
    num_licenses_acquired = $8,
    avg_unit_price = $9,
    avg_maintenance_unit_price = $10,
    total_purchase_cost = $11,
    total_maintenance_cost = $12,
    total_cost = $13,
    updated_by = $14,
    start_of_maintenance = $15,
    end_of_maintenance = $16,
    last_purchased_order = $17,
    support_numbers = $18,
    maintenance_provider = $19,
    num_licences_maintenance = $20,
    comment = $21,
    file_name = $22,
    file_data = $23,
    repartition = $24
`

type UpsertAggregatedRightsParams struct {
	Sku                       string          `json:"sku"`
	Scope                     string          `json:"scope"`
	AggregationID             int32           `json:"aggregation_id"`
	Metric                    string          `json:"metric"`
	OrderingDate              sql.NullTime    `json:"ordering_date"`
	CorporateSourcingContract string          `json:"corporate_sourcing_contract"`
	SoftwareProvider          string          `json:"software_provider"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	CreatedBy                 string          `json:"created_by"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	LastPurchasedOrder        string          `json:"last_purchased_order"`
	SupportNumbers            []string        `json:"support_numbers"`
	MaintenanceProvider       string          `json:"maintenance_provider"`
	NumLicencesMaintenance    int32           `json:"num_licences_maintenance"`
	Comment                   sql.NullString  `json:"comment"`
	FileName                  string          `json:"file_name"`
	FileData                  []byte          `json:"file_data"`
	Repartition               bool            `json:"repartition"`
}

func (q *Queries) UpsertAggregatedRights(ctx context.Context, arg UpsertAggregatedRightsParams) error {
	_, err := q.db.ExecContext(ctx, upsertAggregatedRights,
		arg.Sku,
		arg.Scope,
		arg.AggregationID,
		arg.Metric,
		arg.OrderingDate,
		arg.CorporateSourcingContract,
		arg.SoftwareProvider,
		arg.NumLicensesAcquired,
		arg.AvgUnitPrice,
		arg.AvgMaintenanceUnitPrice,
		arg.TotalPurchaseCost,
		arg.TotalMaintenanceCost,
		arg.TotalCost,
		arg.CreatedBy,
		arg.StartOfMaintenance,
		arg.EndOfMaintenance,
		arg.LastPurchasedOrder,
		pq.Array(arg.SupportNumbers),
		arg.MaintenanceProvider,
		arg.NumLicencesMaintenance,
		arg.Comment,
		arg.FileName,
		arg.FileData,
		arg.Repartition,
	)
	return err
}

const upsertAggregationConcurrentUser = `-- name: UpsertAggregationConcurrentUser :exec

INSERT INTO
    product_concurrent_user (
        is_aggregations,
        aggregation_id,
        swidtag,
        number_of_users,
        profile_user,
        team,
        scope,
        purchase_date,
        created_by,
        updated_by,
        created_on,
        updated_on
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    ) ON CONFLICT (
        aggregation_id,
        scope,
        purchase_date
    )
DO
UPDATE
SET
    number_of_users = $4,
    profile_user = $5,
    team = $6,
    updated_by = $10,
    updated_on = $12
`

type UpsertAggregationConcurrentUserParams struct {
	IsAggregations sql.NullBool   `json:"is_aggregations"`
	AggregationID  sql.NullInt32  `json:"aggregation_id"`
	Swidtag        sql.NullString `json:"swidtag"`
	NumberOfUsers  sql.NullInt32  `json:"number_of_users"`
	ProfileUser    sql.NullString `json:"profile_user"`
	Team           sql.NullString `json:"team"`
	Scope          string         `json:"scope"`
	PurchaseDate   time.Time      `json:"purchase_date"`
	CreatedBy      string         `json:"created_by"`
	UpdatedBy      sql.NullString `json:"updated_by"`
	CreatedOn      time.Time      `json:"created_on"`
	UpdatedOn      time.Time      `json:"updated_on"`
}

func (q *Queries) UpsertAggregationConcurrentUser(ctx context.Context, arg UpsertAggregationConcurrentUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertAggregationConcurrentUser,
		arg.IsAggregations,
		arg.AggregationID,
		arg.Swidtag,
		arg.NumberOfUsers,
		arg.ProfileUser,
		arg.Team,
		arg.Scope,
		arg.PurchaseDate,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	return err
}

const upsertAggrigationNominativeUser = `-- name: UpsertAggrigationNominativeUser :exec

INSERT INTO
    nominative_user (
        scope,
        swidtag,
        aggregations_id,
        activation_date,
        user_email,
        user_name,
        first_name,
        profile,
        product_editor,
        created_by,
        updated_by,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    ) ON CONFLICT (
        aggregations_id,
        scope,
        user_email,
        profile
    )
DO
UPDATE
SET
    activation_date = $4,
    user_name = $6,
    first_name = $7,
    updated_by = $11,
    updated_at = $13
`

type UpsertAggrigationNominativeUserParams struct {
	Scope          string         `json:"scope"`
	Swidtag        sql.NullString `json:"swidtag"`
	AggregationsID sql.NullInt32  `json:"aggregations_id"`
	ActivationDate sql.NullTime   `json:"activation_date"`
	UserEmail      string         `json:"user_email"`
	UserName       sql.NullString `json:"user_name"`
	FirstName      sql.NullString `json:"first_name"`
	Profile        sql.NullString `json:"profile"`
	ProductEditor  sql.NullString `json:"product_editor"`
	CreatedBy      string         `json:"created_by"`
	UpdatedBy      sql.NullString `json:"updated_by"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) UpsertAggrigationNominativeUser(ctx context.Context, arg UpsertAggrigationNominativeUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertAggrigationNominativeUser,
		arg.Scope,
		arg.Swidtag,
		arg.AggregationsID,
		arg.ActivationDate,
		arg.UserEmail,
		arg.UserName,
		arg.FirstName,
		arg.Profile,
		arg.ProductEditor,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertConcurrentUser = `-- name: UpsertConcurrentUser :exec

INSERT INTO
    product_concurrent_user (
        is_aggregations,
        aggregation_id,
        swidtag,
        number_of_users,
        profile_user,
        team,
        scope,
        purchase_date,
        created_by,
        updated_by,
        created_on,
        updated_on
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    ) ON CONFLICT (swidtag, scope, purchase_date)
DO
UPDATE
SET
    number_of_users = $4,
    profile_user = $5,
    team = $6,
    updated_by = $10,
    updated_on = $12
`

type UpsertConcurrentUserParams struct {
	IsAggregations sql.NullBool   `json:"is_aggregations"`
	AggregationID  sql.NullInt32  `json:"aggregation_id"`
	Swidtag        sql.NullString `json:"swidtag"`
	NumberOfUsers  sql.NullInt32  `json:"number_of_users"`
	ProfileUser    sql.NullString `json:"profile_user"`
	Team           sql.NullString `json:"team"`
	Scope          string         `json:"scope"`
	PurchaseDate   time.Time      `json:"purchase_date"`
	CreatedBy      string         `json:"created_by"`
	UpdatedBy      sql.NullString `json:"updated_by"`
	CreatedOn      time.Time      `json:"created_on"`
	UpdatedOn      time.Time      `json:"updated_on"`
}

func (q *Queries) UpsertConcurrentUser(ctx context.Context, arg UpsertConcurrentUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertConcurrentUser,
		arg.IsAggregations,
		arg.AggregationID,
		arg.Swidtag,
		arg.NumberOfUsers,
		arg.ProfileUser,
		arg.Team,
		arg.Scope,
		arg.PurchaseDate,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	return err
}

const upsertDashboardUpdates = `-- name: UpsertDashboardUpdates :exec

Insert into
    dashboard_audit (
        updated_at,
        next_update_at,
        updated_by,
        scope
    )
values ($1, $2, $3, $4) on CONFLICT (scope)
Do
update
set
    updated_at = $1,
    next_update_at = $2,
    updated_by = $3
`

type UpsertDashboardUpdatesParams struct {
	UpdatedAt    time.Time    `json:"updated_at"`
	NextUpdateAt sql.NullTime `json:"next_update_at"`
	UpdatedBy    string       `json:"updated_by"`
	Scope        string       `json:"scope"`
}

func (q *Queries) UpsertDashboardUpdates(ctx context.Context, arg UpsertDashboardUpdatesParams) error {
	_, err := q.db.ExecContext(ctx, upsertDashboardUpdates,
		arg.UpdatedAt,
		arg.NextUpdateAt,
		arg.UpdatedBy,
		arg.Scope,
	)
	return err
}

const upsertProduct = `-- name: UpsertProduct :exec











INSERT INTO
    products (
        swidtag,
        product_name,
        product_version,
        product_edition,
        product_category,
        product_editor,
        scope,
        option_of,
        created_on,
        created_by,
        product_type
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $13
    ) ON CONFLICT (swidtag, scope)
DO
UPDATE
SET
    product_name = $2,
    product_version = $3,
    product_edition = $4,
    product_category = $5,
    product_editor = $6,
    option_of = $8,
    updated_on = $11,
    updated_by = $12
`

type UpsertProductParams struct {
	Swidtag         string         `json:"swidtag"`
	ProductName     string         `json:"product_name"`
	ProductVersion  string         `json:"product_version"`
	ProductEdition  string         `json:"product_edition"`
	ProductCategory string         `json:"product_category"`
	ProductEditor   string         `json:"product_editor"`
	Scope           string         `json:"scope"`
	OptionOf        string         `json:"option_of"`
	CreatedOn       time.Time      `json:"created_on"`
	CreatedBy       string         `json:"created_by"`
	UpdatedOn       time.Time      `json:"updated_on"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	ProductType     ProductType    `json:"product_type"`
}

// -- name: ProductAggregationChildOptions :many
// SELECT p.swidtag,p.product_name,p.product_edition,p.product_editor,p.product_version
// FROM products p
// WHERE p.option_of in (
// SELECT p.swidtag
// FROM products p
// WHERE
//
//	p.aggregation_id = @aggregation_id
//	AND p.scope = ANY(@scope::TEXT[]))
//
// AND p.scope = ANY(@scope::TEXT[]) ;
func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) error {
	_, err := q.db.ExecContext(ctx, upsertProduct,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductVersion,
		arg.ProductEdition,
		arg.ProductCategory,
		arg.ProductEditor,
		arg.Scope,
		arg.OptionOf,
		arg.CreatedOn,
		arg.CreatedBy,
		arg.UpdatedOn,
		arg.UpdatedBy,
		arg.ProductType,
	)
	return err
}

const upsertProductApplications = `-- name: UpsertProductApplications :exec

Insert into
    products_applications (swidtag, application_id, scope)
Values ($1, $2, $3) ON CONFLICT (swidtag, application_id, scope)
Do NOTHING
`

type UpsertProductApplicationsParams struct {
	Swidtag       string `json:"swidtag"`
	ApplicationID string `json:"application_id"`
	Scope         string `json:"scope"`
}

func (q *Queries) UpsertProductApplications(ctx context.Context, arg UpsertProductApplicationsParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductApplications, arg.Swidtag, arg.ApplicationID, arg.Scope)
	return err
}

const upsertProductEquipments = `-- name: UpsertProductEquipments :exec

Insert into
    products_equipments (
        swidtag,
        equipment_id,
        num_of_users,
        scope,
        allocated_metric
    )
Values ($1, $2, $3, $4, $5) ON CONFLICT (swidtag, equipment_id, scope)
Do
Update
set
    num_of_users = $3,
    allocated_metric = $5
`

type UpsertProductEquipmentsParams struct {
	Swidtag         string        `json:"swidtag"`
	EquipmentID     string        `json:"equipment_id"`
	NumOfUsers      sql.NullInt32 `json:"num_of_users"`
	Scope           string        `json:"scope"`
	AllocatedMetric string        `json:"allocated_metric"`
}

func (q *Queries) UpsertProductEquipments(ctx context.Context, arg UpsertProductEquipmentsParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductEquipments,
		arg.Swidtag,
		arg.EquipmentID,
		arg.NumOfUsers,
		arg.Scope,
		arg.AllocatedMetric,
	)
	return err
}

const upsertProductNominativeUser = `-- name: UpsertProductNominativeUser :exec

INSERT INTO
    nominative_user (
        scope,
        swidtag,
        aggregations_id,
        activation_date,
        user_email,
        user_name,
        first_name,
        profile,
        product_editor,
        created_by,
        updated_by,
        created_at,
        updated_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13
    ) ON CONFLICT (
        swidtag,
        scope,
        user_email,
        profile
    )
DO
UPDATE
SET
    activation_date = $4,
    user_name = $6,
    first_name = $7,
    updated_by = $11,
    updated_at = $13
`

type UpsertProductNominativeUserParams struct {
	Scope          string         `json:"scope"`
	Swidtag        sql.NullString `json:"swidtag"`
	AggregationsID sql.NullInt32  `json:"aggregations_id"`
	ActivationDate sql.NullTime   `json:"activation_date"`
	UserEmail      string         `json:"user_email"`
	UserName       sql.NullString `json:"user_name"`
	FirstName      sql.NullString `json:"first_name"`
	Profile        sql.NullString `json:"profile"`
	ProductEditor  sql.NullString `json:"product_editor"`
	CreatedBy      string         `json:"created_by"`
	UpdatedBy      sql.NullString `json:"updated_by"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
}

func (q *Queries) UpsertProductNominativeUser(ctx context.Context, arg UpsertProductNominativeUserParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductNominativeUser,
		arg.Scope,
		arg.Swidtag,
		arg.AggregationsID,
		arg.ActivationDate,
		arg.UserEmail,
		arg.UserName,
		arg.FirstName,
		arg.Profile,
		arg.ProductEditor,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertProductPartial = `-- name: UpsertProductPartial :exec

INSERT INTO
    products (swidtag, scope, created_by)
VALUES ($1, $2, $3) ON CONFLICT (swidtag, scope)
DO NOTHING
`

type UpsertProductPartialParams struct {
	Swidtag   string `json:"swidtag"`
	Scope     string `json:"scope"`
	CreatedBy string `json:"created_by"`
}

func (q *Queries) UpsertProductPartial(ctx context.Context, arg UpsertProductPartialParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductPartial, arg.Swidtag, arg.Scope, arg.CreatedBy)
	return err
}

const upsertRecievedLicenses = `-- name: UpsertRecievedLicenses :exec

INSERT INTO
    shared_licenses (
        sku,
        scope,
        sharing_scope,
        recieved_licences
    )
VALUES ($1, $2, $3, $4) ON CONFLICT (sku, scope, sharing_scope)
Do
Update
set recieved_licences = $4
`

type UpsertRecievedLicensesParams struct {
	Sku              string `json:"sku"`
	Scope            string `json:"scope"`
	SharingScope     string `json:"sharing_scope"`
	RecievedLicences int32  `json:"recieved_licences"`
}

func (q *Queries) UpsertRecievedLicenses(ctx context.Context, arg UpsertRecievedLicensesParams) error {
	_, err := q.db.ExecContext(ctx, upsertRecievedLicenses,
		arg.Sku,
		arg.Scope,
		arg.SharingScope,
		arg.RecievedLicences,
	)
	return err
}

const upsertSharedLicenses = `-- name: UpsertSharedLicenses :exec

INSERT INTO
    shared_licenses (
        sku,
        scope,
        sharing_scope,
        shared_licences
    )
VALUES ($1, $2, $3, $4) ON CONFLICT (sku, scope, sharing_scope)
Do
Update
set shared_licences = $4
`

type UpsertSharedLicensesParams struct {
	Sku            string `json:"sku"`
	Scope          string `json:"scope"`
	SharingScope   string `json:"sharing_scope"`
	SharedLicences int32  `json:"shared_licences"`
}

func (q *Queries) UpsertSharedLicenses(ctx context.Context, arg UpsertSharedLicensesParams) error {
	_, err := q.db.ExecContext(ctx, upsertSharedLicenses,
		arg.Sku,
		arg.Scope,
		arg.SharingScope,
		arg.SharedLicences,
	)
	return err
}

const wasteCost = `-- name: WasteCost :many
SELECT editor, product_names,aggregation_name, coalesce(sum(delta_cost), 0.0) :: FLOAT AS cost
FROM overall_computed_licences
WHERE delta_cost > 0 and scope = $1
GROUP BY editor, product_names,aggregation_name
`

type WasteCostRow struct {
	Editor          string  `json:"editor"`
	ProductNames    string  `json:"product_names"`
	AggregationName string  `json:"aggregation_name"`
	Cost            float64 `json:"cost"`
}

func (q *Queries) WasteCost(ctx context.Context, scope string) ([]WasteCostRow, error) {
	rows, err := q.db.QueryContext(ctx, wasteCost, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WasteCostRow
	for rows.Next() {
		var i WasteCostRow
		if err := rows.Scan(
			&i.Editor,
			&i.ProductNames,
			&i.AggregationName,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
