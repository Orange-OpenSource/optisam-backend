// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

const addComputedLicenses = `-- name: AddComputedLicenses :exec
UPDATE 
  acqrights
SET 
  num_licences_computed = $1,
  total_computed_cost = $2
WHERE sku = $3
AND scope = $4
`

type AddComputedLicensesParams struct {
	Computedlicenses int32           `json:"computedlicenses"`
	Computedcost     decimal.Decimal `json:"computedcost"`
	Sku              string          `json:"sku"`
	Scope            string          `json:"scope"`
}

func (q *Queries) AddComputedLicenses(ctx context.Context, arg AddComputedLicensesParams) error {
	_, err := q.db.ExecContext(ctx, addComputedLicenses,
		arg.Computedlicenses,
		arg.Computedcost,
		arg.Sku,
		arg.Scope,
	)
	return err
}

const counterFeitedProductsCosts = `-- name: CounterFeitedProductsCosts :many
SELECT swidtag as swid_tag, 
product_name as product_name, 
SUM(total_purchase_cost)::Numeric(15,2) as  total_purchase_cost,
total_computed_cost::Numeric(15,2) as total_computed_cost,
(SUM(total_purchase_cost)-total_computed_cost)::Numeric(15,2) as delta_cost
FROM acqrights 
WHERE
scope = $1
AND
product_editor = $2
GROUP BY swidtag, metric, product_name, total_computed_cost
HAVING (SUM(total_purchase_cost)-total_computed_cost) < 0
ORDER BY delta_cost ASC LIMIT 5
`

type CounterFeitedProductsCostsParams struct {
	Scope         string `json:"scope"`
	ProductEditor string `json:"product_editor"`
}

type CounterFeitedProductsCostsRow struct {
	SwidTag           string          `json:"swid_tag"`
	ProductName       string          `json:"product_name"`
	TotalPurchaseCost decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost decimal.Decimal `json:"total_computed_cost"`
	DeltaCost         decimal.Decimal `json:"delta_cost"`
}

func (q *Queries) CounterFeitedProductsCosts(ctx context.Context, arg CounterFeitedProductsCostsParams) ([]CounterFeitedProductsCostsRow, error) {
	rows, err := q.db.QueryContext(ctx, counterFeitedProductsCosts, arg.Scope, arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CounterFeitedProductsCostsRow
	for rows.Next() {
		var i CounterFeitedProductsCostsRow
		if err := rows.Scan(
			&i.SwidTag,
			&i.ProductName,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.DeltaCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const counterFeitedProductsLicences = `-- name: CounterFeitedProductsLicences :many
SELECT swidtag as swid_tag, 
product_name as product_name, 
SUM(num_licenses_acquired) as num_licenses_acquired,
num_licences_computed as num_licences_computed,
(SUM(num_licenses_acquired)-num_licences_computed) as delta
FROM acqrights 
WHERE
scope = $1
AND
product_editor = $2
GROUP BY swidtag, metric, product_name,num_licences_computed
HAVING (SUM(num_licenses_acquired)-num_licences_computed) < 0
ORDER BY delta ASC LIMIT 5
`

type CounterFeitedProductsLicencesParams struct {
	Scope         string `json:"scope"`
	ProductEditor string `json:"product_editor"`
}

type CounterFeitedProductsLicencesRow struct {
	SwidTag             string `json:"swid_tag"`
	ProductName         string `json:"product_name"`
	NumLicensesAcquired int64  `json:"num_licenses_acquired"`
	NumLicencesComputed int32  `json:"num_licences_computed"`
	Delta               int32  `json:"delta"`
}

func (q *Queries) CounterFeitedProductsLicences(ctx context.Context, arg CounterFeitedProductsLicencesParams) ([]CounterFeitedProductsLicencesRow, error) {
	rows, err := q.db.QueryContext(ctx, counterFeitedProductsLicences, arg.Scope, arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CounterFeitedProductsLicencesRow
	for rows.Next() {
		var i CounterFeitedProductsLicencesRow
		if err := rows.Scan(
			&i.SwidTag,
			&i.ProductName,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const counterfeitPercent = `-- name: CounterfeitPercent :one
SELECT acq, delta_rights from (
SELECT
    sum(num_licenses_acquired)::Numeric(15,2) as acq,
    abs(sum(case when num_licenses_acquired < total_computed_licenses then num_licenses_acquired - total_computed_licenses else 0 end))::Numeric(15,2) as delta_rights
    from (
        select sum(num_licenses_acquired) as num_licenses_acquired,
        num_licences_computed as total_computed_licenses
        from acqrights
        where scope= $1 AND metric = ANY($2::TEXT[])
        group by swidtag,metric, num_licences_computed
    ) y
)x WHERE acq IS NOT NULL
`

type CounterfeitPercentParams struct {
	Scope   string   `json:"scope"`
	Metrics []string `json:"metrics"`
}

type CounterfeitPercentRow struct {
	Acq         decimal.Decimal `json:"acq"`
	DeltaRights decimal.Decimal `json:"delta_rights"`
}

func (q *Queries) CounterfeitPercent(ctx context.Context, arg CounterfeitPercentParams) (CounterfeitPercentRow, error) {
	row := q.db.QueryRowContext(ctx, counterfeitPercent, arg.Scope, pq.Array(arg.Metrics))
	var i CounterfeitPercentRow
	err := row.Scan(&i.Acq, &i.DeltaRights)
	return i, err
}

const deleteAcqrightBySKU = `-- name: DeleteAcqrightBySKU :exec
DELETE FROM acqrights WHERE scope = $1 AND sku = $2
`

type DeleteAcqrightBySKUParams struct {
	Scope string `json:"scope"`
	Sku   string `json:"sku"`
}

func (q *Queries) DeleteAcqrightBySKU(ctx context.Context, arg DeleteAcqrightBySKUParams) error {
	_, err := q.db.ExecContext(ctx, deleteAcqrightBySKU, arg.Scope, arg.Sku)
	return err
}

const deleteAcqrightsByScope = `-- name: DeleteAcqrightsByScope :exec
DELETE FROM acqrights WHERE scope = $1
`

func (q *Queries) DeleteAcqrightsByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteAcqrightsByScope, scope)
	return err
}

const deleteAggregation = `-- name: DeleteAggregation :exec
DELETE FROM aggregated_rights 
WHERE id = $1
AND scope = $2
`

type DeleteAggregationParams struct {
	AggregationID int32  `json:"aggregation_id"`
	Scope         string `json:"scope"`
}

func (q *Queries) DeleteAggregation(ctx context.Context, arg DeleteAggregationParams) error {
	_, err := q.db.ExecContext(ctx, deleteAggregation, arg.AggregationID, arg.Scope)
	return err
}

const deleteProductAggregationByScope = `-- name: DeleteProductAggregationByScope :exec
DELETE FROM aggregated_rights WHERE scope = $1
`

func (q *Queries) DeleteProductAggregationByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteProductAggregationByScope, scope)
	return err
}

const deleteProductApplications = `-- name: DeleteProductApplications :exec
DELETE FROM products_applications
WHERE swidtag = $1 and application_id = ANY($2::TEXT[]) and scope = $3
`

type DeleteProductApplicationsParams struct {
	ProductID     string   `json:"product_id"`
	ApplicationID []string `json:"application_id"`
	Scope         string   `json:"scope"`
}

// SCOPE BASED CHANGE
func (q *Queries) DeleteProductApplications(ctx context.Context, arg DeleteProductApplicationsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductApplications, arg.ProductID, pq.Array(arg.ApplicationID), arg.Scope)
	return err
}

const deleteProductEquipments = `-- name: DeleteProductEquipments :exec
DELETE FROM products_equipments
WHERE swidtag = $1 and equipment_id = ANY($2::TEXT[]) and scope = $3
`

type DeleteProductEquipmentsParams struct {
	ProductID   string   `json:"product_id"`
	EquipmentID []string `json:"equipment_id"`
	Scope       string   `json:"scope"`
}

// SCOPE BASED CHANGE
func (q *Queries) DeleteProductEquipments(ctx context.Context, arg DeleteProductEquipmentsParams) error {
	_, err := q.db.ExecContext(ctx, deleteProductEquipments, arg.ProductID, pq.Array(arg.EquipmentID), arg.Scope)
	return err
}

const deleteProductsByScope = `-- name: DeleteProductsByScope :exec
DELETE FROM products WHERE scope = $1
`

func (q *Queries) DeleteProductsByScope(ctx context.Context, scope string) error {
	_, err := q.db.ExecContext(ctx, deleteProductsByScope, scope)
	return err
}

const equipmentProducts = `-- name: EquipmentProducts :many
SELECT swidtag, equipment_id, num_of_users, scope from products_equipments
WHERE
equipment_id = $1
`

func (q *Queries) EquipmentProducts(ctx context.Context, equipmentID string) ([]ProductsEquipment, error) {
	rows, err := q.db.QueryContext(ctx, equipmentProducts, equipmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsEquipment
	for rows.Next() {
		var i ProductsEquipment
		if err := rows.Scan(
			&i.Swidtag,
			&i.EquipmentID,
			&i.NumOfUsers,
			&i.Scope,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAcqBySwidtags = `-- name: GetAcqBySwidtags :many
Select sku, swidtag, product_name, product_editor, scope, metric, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, created_on, created_by, updated_on, updated_by, start_of_maintenance, end_of_maintenance, version, comment from acqrights where swidtag = ANY($1::TEXT[]) and scope = $2
`

type GetAcqBySwidtagsParams struct {
	Swidtag []string `json:"swidtag"`
	Scope   string   `json:"scope"`
}

func (q *Queries) GetAcqBySwidtags(ctx context.Context, arg GetAcqBySwidtagsParams) ([]Acqright, error) {
	rows, err := q.db.QueryContext(ctx, getAcqBySwidtags, pq.Array(arg.Swidtag), arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acqright
	for rows.Next() {
		var i Acqright
		if err := rows.Scan(
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Scope,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedOn,
			&i.UpdatedBy,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Version,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAcqRightBySKU = `-- name: GetAcqRightBySKU :one
SELECT sku, swidtag, product_name, product_editor, scope, metric, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, created_on, created_by, updated_on, updated_by, start_of_maintenance, end_of_maintenance, version, comment
FROM acqrights
WHERE sku = $1 and scope = $2
`

type GetAcqRightBySKUParams struct {
	AcqrightSku string `json:"acqright_sku"`
	Scope       string `json:"scope"`
}

func (q *Queries) GetAcqRightBySKU(ctx context.Context, arg GetAcqRightBySKUParams) (Acqright, error) {
	row := q.db.QueryRowContext(ctx, getAcqRightBySKU, arg.AcqrightSku, arg.Scope)
	var i Acqright
	err := row.Scan(
		&i.Sku,
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.Scope,
		&i.Metric,
		&i.NumLicensesAcquired,
		&i.NumLicencesComputed,
		&i.NumLicencesMaintainance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalComputedCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.Version,
		&i.Comment,
	)
	return i, err
}

const getAcqRightsCost = `-- name: GetAcqRightsCost :one
SELECT SUM(total_cost)::Numeric(15,2) as total_cost,SUM(total_maintenance_cost)::Numeric(15,2) as total_maintenance_cost 
from acqrights 
WHERE scope = ANY($1::TEXT[])
GROUP BY scope
`

type GetAcqRightsCostRow struct {
	TotalCost            decimal.Decimal `json:"total_cost"`
	TotalMaintenanceCost decimal.Decimal `json:"total_maintenance_cost"`
}

func (q *Queries) GetAcqRightsCost(ctx context.Context, scope []string) (GetAcqRightsCostRow, error) {
	row := q.db.QueryRowContext(ctx, getAcqRightsCost, pq.Array(scope))
	var i GetAcqRightsCostRow
	err := row.Scan(&i.TotalCost, &i.TotalMaintenanceCost)
	return i, err
}

const getAggregationByID = `-- name: GetAggregationByID :one
SELECT id, aggregation_name, sku, product_editor, metric, products, swidtags, scope, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, start_of_maintenance, end_of_maintenance, comment, created_on, created_by, updated_on, updated_by
FROM aggregated_rights
WHERE id = $1
    AND scope = $2
`

type GetAggregationByIDParams struct {
	ID    int32  `json:"id"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAggregationByID(ctx context.Context, arg GetAggregationByIDParams) (AggregatedRight, error) {
	row := q.db.QueryRowContext(ctx, getAggregationByID, arg.ID, arg.Scope)
	var i AggregatedRight
	err := row.Scan(
		&i.ID,
		&i.AggregationName,
		&i.Sku,
		&i.ProductEditor,
		&i.Metric,
		pq.Array(&i.Products),
		pq.Array(&i.Swidtags),
		&i.Scope,
		&i.NumLicensesAcquired,
		&i.NumLicencesComputed,
		&i.NumLicencesMaintainance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalComputedCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.Comment,
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const getAggregationByName = `-- name: GetAggregationByName :one
SELECT id, aggregation_name, sku, product_editor, metric, products, swidtags, scope, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, start_of_maintenance, end_of_maintenance, comment, created_on, created_by, updated_on, updated_by
FROM aggregated_rights
WHERE aggregation_name = $1
    AND scope = $2
`

type GetAggregationByNameParams struct {
	AggregationName string `json:"aggregation_name"`
	Scope           string `json:"scope"`
}

func (q *Queries) GetAggregationByName(ctx context.Context, arg GetAggregationByNameParams) (AggregatedRight, error) {
	row := q.db.QueryRowContext(ctx, getAggregationByName, arg.AggregationName, arg.Scope)
	var i AggregatedRight
	err := row.Scan(
		&i.ID,
		&i.AggregationName,
		&i.Sku,
		&i.ProductEditor,
		&i.Metric,
		pq.Array(&i.Products),
		pq.Array(&i.Swidtags),
		&i.Scope,
		&i.NumLicensesAcquired,
		&i.NumLicencesComputed,
		&i.NumLicencesMaintainance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalComputedCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.Comment,
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const getAggregationBySKU = `-- name: GetAggregationBySKU :one
SELECT id, aggregation_name, sku, product_editor, metric, products, swidtags, scope, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, start_of_maintenance, end_of_maintenance, comment, created_on, created_by, updated_on, updated_by
FROM aggregated_rights
WHERE sku = $1
    AND scope = $2
`

type GetAggregationBySKUParams struct {
	Sku   string `json:"sku"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAggregationBySKU(ctx context.Context, arg GetAggregationBySKUParams) (AggregatedRight, error) {
	row := q.db.QueryRowContext(ctx, getAggregationBySKU, arg.Sku, arg.Scope)
	var i AggregatedRight
	err := row.Scan(
		&i.ID,
		&i.AggregationName,
		&i.Sku,
		&i.ProductEditor,
		&i.Metric,
		pq.Array(&i.Products),
		pq.Array(&i.Swidtags),
		&i.Scope,
		&i.NumLicensesAcquired,
		&i.NumLicencesComputed,
		&i.NumLicencesMaintainance,
		&i.AvgUnitPrice,
		&i.AvgMaintenanceUnitPrice,
		&i.TotalPurchaseCost,
		&i.TotalComputedCost,
		&i.TotalMaintenanceCost,
		&i.TotalCost,
		&i.StartOfMaintenance,
		&i.EndOfMaintenance,
		&i.Comment,
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const getDashboardUpdates = `-- name: GetDashboardUpdates :one
select updated_at  at time zone $2::varchar as updated_at , next_update_at  at time zone $2::varchar as next_update_at from dashboard_audit where scope = $1
`

type GetDashboardUpdatesParams struct {
	Scope   string `json:"scope"`
	Column2 string `json:"column_2"`
}

type GetDashboardUpdatesRow struct {
	UpdatedAt    interface{} `json:"updated_at"`
	NextUpdateAt interface{} `json:"next_update_at"`
}

func (q *Queries) GetDashboardUpdates(ctx context.Context, arg GetDashboardUpdatesParams) (GetDashboardUpdatesRow, error) {
	row := q.db.QueryRowContext(ctx, getDashboardUpdates, arg.Scope, arg.Column2)
	var i GetDashboardUpdatesRow
	err := row.Scan(&i.UpdatedAt, &i.NextUpdateAt)
	return i, err
}

const getEquipmentsBySwidtag = `-- name: GetEquipmentsBySwidtag :one
SELECT 
    ARRAY_AGG(DISTINCT(equipment_id))::TEXT[] as equipments
from products_equipments
WHERE 
    scope = $1 and 
    swidtag = $2
`

type GetEquipmentsBySwidtagParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

func (q *Queries) GetEquipmentsBySwidtag(ctx context.Context, arg GetEquipmentsBySwidtagParams) ([]string, error) {
	row := q.db.QueryRowContext(ctx, getEquipmentsBySwidtag, arg.Scope, arg.Swidtag)
	var equipments []string
	err := row.Scan(pq.Array(&equipments))
	return equipments, err
}

const getIndividualProductDetailByAggregation = `-- name: GetIndividualProductDetailByAggregation :many
Select
	ar.aggregation_name,
    coalesce(num_of_applications,0) as num_of_applications,
    coalesce(num_of_equipments,0) as num_of_equipments,
    ar.product_editor,
    name,
    version,
    p_id,
    ar.total_cost
from
	aggregated_rights ar
	LEFT JOIN (
		select 
			p.product_name as name,
			p.product_version as version,
			p.swidtag  as p_id
			from products p 
		where 
			p.scope =  $1
	) p on p_id  = ANY(ar.swidtags::TEXT[])
    LEFT JOIN (
        SELECT
            pa.swidtag ,
            count(application_id) as num_of_applications
        FROM
            products_applications pa
        WHERE
            pa.scope = $1
        GROUP BY
            pa.swidtag
    ) pa ON p_id = pa.swidtag
    LEFT JOIN (
        SELECT
            pe.swidtag ,
            count(equipment_id) as num_of_equipments
        FROM
            products_equipments pe
        WHERE
            pe.scope = $1
        GROUP BY
            pe.swidtag
    ) pe ON p_id = pe.swidtag
WHERE
     ar.scope = $1 and ar.aggregation_name = $2
`

type GetIndividualProductDetailByAggregationParams struct {
	Scope           string `json:"scope"`
	AggregationName string `json:"aggregation_name"`
}

type GetIndividualProductDetailByAggregationRow struct {
	AggregationName   string          `json:"aggregation_name"`
	NumOfApplications int64           `json:"num_of_applications"`
	NumOfEquipments   int64           `json:"num_of_equipments"`
	ProductEditor     string          `json:"product_editor"`
	Name              string          `json:"name"`
	Version           string          `json:"version"`
	PID               string          `json:"p_id"`
	TotalCost         decimal.Decimal `json:"total_cost"`
}

func (q *Queries) GetIndividualProductDetailByAggregation(ctx context.Context, arg GetIndividualProductDetailByAggregationParams) ([]GetIndividualProductDetailByAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, getIndividualProductDetailByAggregation, arg.Scope, arg.AggregationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIndividualProductDetailByAggregationRow
	for rows.Next() {
		var i GetIndividualProductDetailByAggregationRow
		if err := rows.Scan(
			&i.AggregationName,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.ProductEditor,
			&i.Name,
			&i.Version,
			&i.PID,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductAggregation = `-- name: GetProductAggregation :many
SELECT swidtag
FROM products
WHERE aggregation_id = $1 AND aggregation_name = $2 AND scope = $3
`

type GetProductAggregationParams struct {
	AggregationID   int32  `json:"aggregation_id"`
	AggregationName string `json:"aggregation_name"`
	Scope           string `json:"scope"`
}

func (q *Queries) GetProductAggregation(ctx context.Context, arg GetProductAggregationParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getProductAggregation, arg.AggregationID, arg.AggregationName, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var swidtag string
		if err := rows.Scan(&swidtag); err != nil {
			return nil, err
		}
		items = append(items, swidtag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductInformation = `-- name: GetProductInformation :one
SELECT p.swidtag,p.product_name,p.product_editor,p.product_version, acq.metrics, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications,COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments
FROM products p 
LEFT JOIN 
(SELECT pa.swidtag, count(pa.application_id) as num_of_applications FROM products_applications pa WHERE pa.scope = $1 GROUP BY pa.swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT pe.swidtag, count(pe.equipment_id) as num_of_equipments FROM products_equipments pe WHERE pe.scope = $1 GROUP BY pe.swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN
(SELECT ac.swidtag,ARRAY_AGG(DISTINCT acmetrics)::TEXT[] as metrics FROM acqrights ac, unnest(string_to_array(ac.metric,',')) as acmetrics WHERE ac.scope = $1 GROUP BY ac.swidtag) acq
ON p.swidtag = acq.swidtag
WHERE p.swidtag = $2
AND p.scope = $1
GROUP BY p.swidtag, p.product_name, p.product_editor, p.product_version, acq.metrics, pa.num_of_applications, pe.num_of_equipments
`

type GetProductInformationParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

type GetProductInformationRow struct {
	Swidtag           string   `json:"swidtag"`
	ProductName       string   `json:"product_name"`
	ProductEditor     string   `json:"product_editor"`
	ProductVersion    string   `json:"product_version"`
	Metrics           []string `json:"metrics"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
}

func (q *Queries) GetProductInformation(ctx context.Context, arg GetProductInformationParams) (GetProductInformationRow, error) {
	row := q.db.QueryRowContext(ctx, getProductInformation, arg.Scope, arg.Swidtag)
	var i GetProductInformationRow
	err := row.Scan(
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.ProductVersion,
		pq.Array(&i.Metrics),
		&i.NumOfApplications,
		&i.NumOfEquipments,
	)
	return i, err
}

const getProductInformationFromAcqright = `-- name: GetProductInformationFromAcqright :one
SELECT ac.swidtag,
       ac.product_name,
       ac.product_editor,
       ac.version,
       ARRAY_AGG(DISTINCT acmetrics)::TEXT[] as metrics
FROM acqrights ac, unnest(string_to_array(ac.metric,',')) as acmetrics
WHERE ac.scope = $1
    AND ac.swidtag = $2
GROUP BY ac.swidtag,
         ac.product_name,
         ac.product_editor,
         ac.version
`

type GetProductInformationFromAcqrightParams struct {
	Scope   string `json:"scope"`
	Swidtag string `json:"swidtag"`
}

type GetProductInformationFromAcqrightRow struct {
	Swidtag       string   `json:"swidtag"`
	ProductName   string   `json:"product_name"`
	ProductEditor string   `json:"product_editor"`
	Version       string   `json:"version"`
	Metrics       []string `json:"metrics"`
}

func (q *Queries) GetProductInformationFromAcqright(ctx context.Context, arg GetProductInformationFromAcqrightParams) (GetProductInformationFromAcqrightRow, error) {
	row := q.db.QueryRowContext(ctx, getProductInformationFromAcqright, arg.Scope, arg.Swidtag)
	var i GetProductInformationFromAcqrightRow
	err := row.Scan(
		&i.Swidtag,
		&i.ProductName,
		&i.ProductEditor,
		&i.Version,
		pq.Array(&i.Metrics),
	)
	return i, err
}

const getProductOptions = `-- name: GetProductOptions :many
SELECT p.swidtag,p.product_name,p.product_edition,p.product_editor,p.product_version
FROM products p 
WHERE p.option_of = $1
AND p.scope = $2
`

type GetProductOptionsParams struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

type GetProductOptionsRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEdition string `json:"product_edition"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductOptions(ctx context.Context, arg GetProductOptionsParams) ([]GetProductOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductOptions, arg.Swidtag, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductOptionsRow
	for rows.Next() {
		var i GetProductOptionsRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEdition,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductQualityOverview = `-- name: GetProductQualityOverview :one

select total_records,
       count(swid1) as not_acquired,
       count(swid2) as not_deployed,
       (count(swid1) * 100.0/ total_records) :: NUMERIC(5,2) as not_deployed_percentage,
       (count(swid2) * 100.0/ total_records) :: NUMERIC(5,2) as not_acquired_percentage
from
    (select count(*) over() as total_records, pe.swidtag as swid1, acq.swidtag as swid2 from products_equipments pe
     full outer join acqrights acq on acq.swidtag = pe.swidtag and acq.scope = pe.scope
     where acq."scope" = $1  or pe.scope = $1
     group by (2,3)) p
where swid1 is NULL or swid2 is null
group by (1)
`

type GetProductQualityOverviewRow struct {
	TotalRecords          int64           `json:"total_records"`
	NotAcquired           int64           `json:"not_acquired"`
	NotDeployed           int64           `json:"not_deployed"`
	NotDeployedPercentage decimal.Decimal `json:"not_deployed_percentage"`
	NotAcquiredPercentage decimal.Decimal `json:"not_acquired_percentage"`
}

func (q *Queries) GetProductQualityOverview(ctx context.Context, scope string) (GetProductQualityOverviewRow, error) {
	row := q.db.QueryRowContext(ctx, getProductQualityOverview, scope)
	var i GetProductQualityOverviewRow
	err := row.Scan(
		&i.TotalRecords,
		&i.NotAcquired,
		&i.NotDeployed,
		&i.NotDeployedPercentage,
		&i.NotAcquiredPercentage,
	)
	return i, err
}

const getProductsByEditor = `-- name: GetProductsByEditor :many
SELECT p.swidtag, p.product_name, p.product_version
FROM products p
JOIN 
(SELECT swidtag FROM products_equipments WHERE scope = ANY($1::TEXT[]) GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
WHERE p.product_editor = $2 and p.scope = ANY($1::TEXT[])
`

type GetProductsByEditorParams struct {
	Scopes        []string `json:"scopes"`
	ProductEditor string   `json:"product_editor"`
}

type GetProductsByEditorRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) GetProductsByEditor(ctx context.Context, arg GetProductsByEditorParams) ([]GetProductsByEditorRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByEditor, pq.Array(arg.Scopes), arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByEditorRow
	for rows.Next() {
		var i GetProductsByEditorRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName, &i.ProductVersion); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAcqRight = `-- name: InsertAcqRight :exec
INSERT INTO acqrights (sku,swidtag,product_name,product_editor,scope,metric,num_licenses_acquired,avg_unit_price,avg_maintenance_unit_price,total_purchase_cost,total_maintenance_cost,total_cost,created_by,start_of_maintenance,end_of_maintenance,num_licences_maintainance,version,comment)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18)
`

type InsertAcqRightParams struct {
	Sku                     string          `json:"sku"`
	Swidtag                 string          `json:"swidtag"`
	ProductName             string          `json:"product_name"`
	ProductEditor           string          `json:"product_editor"`
	Scope                   string          `json:"scope"`
	Metric                  string          `json:"metric"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	CreatedBy               string          `json:"created_by"`
	StartOfMaintenance      sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance        sql.NullTime    `json:"end_of_maintenance"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	Version                 string          `json:"version"`
	Comment                 sql.NullString  `json:"comment"`
}

func (q *Queries) InsertAcqRight(ctx context.Context, arg InsertAcqRightParams) error {
	_, err := q.db.ExecContext(ctx, insertAcqRight,
		arg.Sku,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductEditor,
		arg.Scope,
		arg.Metric,
		arg.NumLicensesAcquired,
		arg.AvgUnitPrice,
		arg.AvgMaintenanceUnitPrice,
		arg.TotalPurchaseCost,
		arg.TotalMaintenanceCost,
		arg.TotalCost,
		arg.CreatedBy,
		arg.StartOfMaintenance,
		arg.EndOfMaintenance,
		arg.NumLicencesMaintainance,
		arg.Version,
		arg.Comment,
	)
	return err
}

const listAcqRightsAggregation = `-- name: ListAcqRightsAggregation :many
SELECT count(*) OVER() AS totalRecords,id, aggregation_name, sku, product_editor, metric, products, swidtags, scope, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, start_of_maintenance, end_of_maintenance, comment, created_on, created_by, updated_on, updated_by from aggregated_rights
WHERE scope = ANY($1::TEXT[]) LIMIT $3 OFFSET $2
`

type ListAcqRightsAggregationParams struct {
	Scope    []string `json:"scope"`
	PageNum  int32    `json:"page_num"`
	PageSize int32    `json:"page_size"`
}

type ListAcqRightsAggregationRow struct {
	Totalrecords            int64           `json:"totalrecords"`
	ID                      int32           `json:"id"`
	AggregationName         string          `json:"aggregation_name"`
	Sku                     string          `json:"sku"`
	ProductEditor           string          `json:"product_editor"`
	Metric                  string          `json:"metric"`
	Products                []string        `json:"products"`
	Swidtags                []string        `json:"swidtags"`
	Scope                   string          `json:"scope"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	NumLicencesComputed     int32           `json:"num_licences_computed"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost       decimal.Decimal `json:"total_computed_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	StartOfMaintenance      sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance        sql.NullTime    `json:"end_of_maintenance"`
	Comment                 sql.NullString  `json:"comment"`
	CreatedOn               time.Time       `json:"created_on"`
	CreatedBy               string          `json:"created_by"`
	UpdatedOn               time.Time       `json:"updated_on"`
	UpdatedBy               sql.NullString  `json:"updated_by"`
}

func (q *Queries) ListAcqRightsAggregation(ctx context.Context, arg ListAcqRightsAggregationParams) ([]ListAcqRightsAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsAggregation, pq.Array(arg.Scope), arg.PageNum, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsAggregationRow
	for rows.Next() {
		var i ListAcqRightsAggregationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.ID,
			&i.AggregationName,
			&i.Sku,
			&i.ProductEditor,
			&i.Metric,
			pq.Array(&i.Products),
			pq.Array(&i.Swidtags),
			&i.Scope,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Comment,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedOn,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsAggregationIndividual = `-- name: ListAcqRightsAggregationIndividual :many
SELECT a.sku,a.swidtag,a.product_name,a.product_editor,a.metric,a.num_licenses_acquired,a.num_licences_maintainance,a.avg_unit_price,a.avg_maintenance_unit_price,a.total_purchase_cost,a.total_maintenance_cost,a.total_cost, a.version FROM 
acqrights a
WHERE 
  a.swidtag IN (SELECT UNNEST(products) from aggregations where aggregation_id = $1  AND a.metric = aggregation_metric AND aggregation_scope = ANY($2::TEXT[]))
  AND a.scope = ANY($2::TEXT[])
`

type ListAcqRightsAggregationIndividualParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

type ListAcqRightsAggregationIndividualRow struct {
	Sku                     string          `json:"sku"`
	Swidtag                 string          `json:"swidtag"`
	ProductName             string          `json:"product_name"`
	ProductEditor           string          `json:"product_editor"`
	Metric                  string          `json:"metric"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	Version                 string          `json:"version"`
}

func (q *Queries) ListAcqRightsAggregationIndividual(ctx context.Context, arg ListAcqRightsAggregationIndividualParams) ([]ListAcqRightsAggregationIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsAggregationIndividual, arg.AggregationID, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsAggregationIndividualRow
	for rows.Next() {
		var i ListAcqRightsAggregationIndividualRow
		if err := rows.Scan(
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqRightsIndividual = `-- name: ListAcqRightsIndividual :many
SELECT count(*) OVER() AS totalRecords,a.sku,a.swidtag,a.product_name,a.product_editor,a.metric,a.num_licenses_acquired,a.num_licences_maintainance,a.avg_unit_price,a.avg_maintenance_unit_price,a.total_purchase_cost,a.total_maintenance_cost,a.total_cost ,start_of_maintenance, end_of_maintenance , version, comment FROM 
acqrights a
WHERE 
  a.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(a.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(a.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(a.product_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(a.product_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(a.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(a.product_editor) = lower($9) ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(a.sku) LIKE '%' || lower($12::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $13::bool THEN lower(a.sku) = lower($12) ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(a.metric) LIKE '%' || lower($15::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $16::bool THEN lower(a.metric) = lower($15) ELSE TRUE END)
  ORDER BY
  CASE WHEN $17::bool THEN a.swidtag END asc,
  CASE WHEN $18::bool THEN a.swidtag END desc,
  CASE WHEN $19::bool THEN a.product_name END asc,
  CASE WHEN $20::bool THEN a.product_name END desc,
  CASE WHEN $21::bool THEN a.product_editor END asc,
  CASE WHEN $22::bool THEN a.product_editor END desc,
  CASE WHEN $23::bool THEN a.sku END asc,
  CASE WHEN $24::bool THEN a.sku END desc,
  CASE WHEN $25::bool THEN a.metric END asc,
  CASE WHEN $26::bool THEN a.metric END desc,
  CASE WHEN $27::bool THEN a.num_licenses_acquired END asc,
  CASE WHEN $28::bool THEN a.num_licenses_acquired END desc,
  CASE WHEN $29::bool THEN a.num_licences_maintainance END asc,
  CASE WHEN $30::bool THEN a.num_licences_maintainance END desc,
  CASE WHEN $31::bool THEN a.avg_unit_price END asc,
  CASE WHEN $32::bool THEN a.avg_unit_price END desc,  
  CASE WHEN $33::bool THEN a.avg_maintenance_unit_price END asc,
  CASE WHEN $34::bool THEN a.avg_maintenance_unit_price END desc,
  CASE WHEN $35::bool THEN a.total_purchase_cost END asc,
  CASE WHEN $36::bool THEN a.total_purchase_cost END desc,
  CASE WHEN $37::bool THEN a.total_maintenance_cost END asc,
  CASE WHEN $38::bool THEN a.total_maintenance_cost END desc,
  CASE WHEN $39::bool THEN a.total_cost END asc,
  CASE WHEN $40::bool THEN a.total_cost END desc,
  CASE WHEN $41::bool THEN a.start_of_maintenance END asc,
  CASE WHEN $42::bool THEN a.start_of_maintenance END desc,
  CASE WHEN $43::bool THEN a.end_of_maintenance END asc,
  CASE WHEN $44::bool THEN a.end_of_maintenance END desc
  LIMIT $46 OFFSET $45
`

type ListAcqRightsIndividualParams struct {
	Scope                       []string `json:"scope"`
	LkSwidtag                   bool     `json:"lk_swidtag"`
	Swidtag                     string   `json:"swidtag"`
	IsSwidtag                   bool     `json:"is_swidtag"`
	LkProductName               bool     `json:"lk_product_name"`
	ProductName                 string   `json:"product_name"`
	IsProductName               bool     `json:"is_product_name"`
	LkProductEditor             bool     `json:"lk_product_editor"`
	ProductEditor               string   `json:"product_editor"`
	IsProductEditor             bool     `json:"is_product_editor"`
	LkSku                       bool     `json:"lk_sku"`
	Sku                         string   `json:"sku"`
	IsSku                       bool     `json:"is_sku"`
	LkMetric                    bool     `json:"lk_metric"`
	Metric                      string   `json:"metric"`
	IsMetric                    bool     `json:"is_metric"`
	SwidtagAsc                  bool     `json:"swidtag_asc"`
	SwidtagDesc                 bool     `json:"swidtag_desc"`
	ProductNameAsc              bool     `json:"product_name_asc"`
	ProductNameDesc             bool     `json:"product_name_desc"`
	ProductEditorAsc            bool     `json:"product_editor_asc"`
	ProductEditorDesc           bool     `json:"product_editor_desc"`
	SkuAsc                      bool     `json:"sku_asc"`
	SkuDesc                     bool     `json:"sku_desc"`
	MetricAsc                   bool     `json:"metric_asc"`
	MetricDesc                  bool     `json:"metric_desc"`
	NumLicensesAcquiredAsc      bool     `json:"num_licenses_acquired_asc"`
	NumLicensesAcquiredDesc     bool     `json:"num_licenses_acquired_desc"`
	NumLicencesMaintainanceAsc  bool     `json:"num_licences_maintainance_asc"`
	NumLicencesMaintainanceDesc bool     `json:"num_licences_maintainance_desc"`
	AvgUnitPriceAsc             bool     `json:"avg_unit_price_asc"`
	AvgUnitPriceDesc            bool     `json:"avg_unit_price_desc"`
	AvgMaintenanceUnitPriceAsc  bool     `json:"avg_maintenance_unit_price_asc"`
	AvgMaintenanceUnitPriceDesc bool     `json:"avg_maintenance_unit_price_desc"`
	TotalPurchaseCostAsc        bool     `json:"total_purchase_cost_asc"`
	TotalPurchaseCostDesc       bool     `json:"total_purchase_cost_desc"`
	TotalMaintenanceCostAsc     bool     `json:"total_maintenance_cost_asc"`
	TotalMaintenanceCostDesc    bool     `json:"total_maintenance_cost_desc"`
	TotalCostAsc                bool     `json:"total_cost_asc"`
	TotalCostDesc               bool     `json:"total_cost_desc"`
	StartOfMaintenanceAsc       bool     `json:"start_of_maintenance_asc"`
	StartOfMaintenanceDesc      bool     `json:"start_of_maintenance_desc"`
	EndOfMaintenanceAsc         bool     `json:"end_of_maintenance_asc"`
	EndOfMaintenanceDesc        bool     `json:"end_of_maintenance_desc"`
	PageNum                     int32    `json:"page_num"`
	PageSize                    int32    `json:"page_size"`
}

type ListAcqRightsIndividualRow struct {
	Totalrecords            int64           `json:"totalrecords"`
	Sku                     string          `json:"sku"`
	Swidtag                 string          `json:"swidtag"`
	ProductName             string          `json:"product_name"`
	ProductEditor           string          `json:"product_editor"`
	Metric                  string          `json:"metric"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	StartOfMaintenance      sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance        sql.NullTime    `json:"end_of_maintenance"`
	Version                 string          `json:"version"`
	Comment                 sql.NullString  `json:"comment"`
}

func (q *Queries) ListAcqRightsIndividual(ctx context.Context, arg ListAcqRightsIndividualParams) ([]ListAcqRightsIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqRightsIndividual,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.LkSku,
		arg.Sku,
		arg.IsSku,
		arg.LkMetric,
		arg.Metric,
		arg.IsMetric,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.SkuAsc,
		arg.SkuDesc,
		arg.MetricAsc,
		arg.MetricDesc,
		arg.NumLicensesAcquiredAsc,
		arg.NumLicensesAcquiredDesc,
		arg.NumLicencesMaintainanceAsc,
		arg.NumLicencesMaintainanceDesc,
		arg.AvgUnitPriceAsc,
		arg.AvgUnitPriceDesc,
		arg.AvgMaintenanceUnitPriceAsc,
		arg.AvgMaintenanceUnitPriceDesc,
		arg.TotalPurchaseCostAsc,
		arg.TotalPurchaseCostDesc,
		arg.TotalMaintenanceCostAsc,
		arg.TotalMaintenanceCostDesc,
		arg.TotalCostAsc,
		arg.TotalCostDesc,
		arg.StartOfMaintenanceAsc,
		arg.StartOfMaintenanceDesc,
		arg.EndOfMaintenanceAsc,
		arg.EndOfMaintenanceDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqRightsIndividualRow
	for rows.Next() {
		var i ListAcqRightsIndividualRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Sku,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Metric,
			&i.NumLicensesAcquired,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Version,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqrightsProducts = `-- name: ListAcqrightsProducts :many
SELECT DISTINCT swidtag,scope
FROM acqrights
`

type ListAcqrightsProductsRow struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

func (q *Queries) ListAcqrightsProducts(ctx context.Context) ([]ListAcqrightsProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqrightsProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqrightsProductsRow
	for rows.Next() {
		var i ListAcqrightsProductsRow
		if err := rows.Scan(&i.Swidtag, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAcqrightsProductsByScope = `-- name: ListAcqrightsProductsByScope :many
SELECT DISTINCT swidtag,scope
FROM acqrights where scope = $1
`

type ListAcqrightsProductsByScopeRow struct {
	Swidtag string `json:"swidtag"`
	Scope   string `json:"scope"`
}

func (q *Queries) ListAcqrightsProductsByScope(ctx context.Context, scope string) ([]ListAcqrightsProductsByScopeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcqrightsProductsByScope, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAcqrightsProductsByScopeRow
	for rows.Next() {
		var i ListAcqrightsProductsByScopeRow
		if err := rows.Scan(&i.Swidtag, &i.Scope); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregationProductsView = `-- name: ListAggregationProductsView :many
SELECT p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition ,COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications,COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments, COALESCE(acq.total_cost,0)::FLOAT as cost
FROM products p 
LEFT JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE scope = ANY($1::TEXT[])  GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE scope = ANY($1::TEXT[])  GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN
(SELECT swidtag, sum(total_cost) as total_cost FROM acqrights LEFT JOIN aggregations on acqrights.metric = aggregations.aggregation_metric WHERE aggregations.aggregation_id =  $2 AND acqrights.scope = ANY($1::TEXT[]) AND aggregations.aggregation_scope = ANY($1::TEXT[]) GROUP BY swidtag) acq
ON p.swidtag = acq.swidtag
WHERE
  p.aggregation_id = $2
  AND p.scope = ANY($1::TEXT[])
GROUP BY p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition,acq.total_cost,pa.num_of_applications, pe.num_of_equipments
`

type ListAggregationProductsViewParams struct {
	Scope         []string `json:"scope"`
	AggregationID int32    `json:"aggregation_id"`
}

type ListAggregationProductsViewRow struct {
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListAggregationProductsView(ctx context.Context, arg ListAggregationProductsViewParams) ([]ListAggregationProductsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregationProductsView, pq.Array(arg.Scope), arg.AggregationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationProductsViewRow
	for rows.Next() {
		var i ListAggregationProductsViewRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregations = `-- name: ListAggregations :many
SELECT id,aggregation_name,sku,product_editor,metric,products,swidtags,scope,num_licenses_acquired,
  num_licences_computed,num_licences_maintainance,avg_unit_price,avg_maintenance_unit_price,total_purchase_cost,
  total_computed_cost,total_maintenance_cost,total_cost,start_of_maintenance,end_of_maintenance,comment
FROM aggregated_rights
WHERE scope = $1
`

type ListAggregationsRow struct {
	ID                      int32           `json:"id"`
	AggregationName         string          `json:"aggregation_name"`
	Sku                     string          `json:"sku"`
	ProductEditor           string          `json:"product_editor"`
	Metric                  string          `json:"metric"`
	Products                []string        `json:"products"`
	Swidtags                []string        `json:"swidtags"`
	Scope                   string          `json:"scope"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	NumLicencesComputed     int32           `json:"num_licences_computed"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost       decimal.Decimal `json:"total_computed_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	StartOfMaintenance      sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance        sql.NullTime    `json:"end_of_maintenance"`
	Comment                 sql.NullString  `json:"comment"`
}

func (q *Queries) ListAggregations(ctx context.Context, scope string) ([]ListAggregationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregations, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationsRow
	for rows.Next() {
		var i ListAggregationsRow
		if err := rows.Scan(
			&i.ID,
			&i.AggregationName,
			&i.Sku,
			&i.ProductEditor,
			&i.Metric,
			pq.Array(&i.Products),
			pq.Array(&i.Swidtags),
			&i.Scope,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAggregationsView = `-- name: ListAggregationsView :many
SELECT count(*) OVER() AS totalRecords,p.aggregation_id,p.aggregation_name,p.product_editor,array_agg(distinct p.swidtag)::TEXT[] as swidtags, COALESCE(sum(pa.num_of_applications),0)::INTEGER as num_of_applications , COALESCE(sum(pe.num_of_equipments),0)::INTEGER as num_of_equipments , COALESCE(SUM(acq.total_cost),0)::FLOAT as total_cost
FROM products p 
LEFT JOIN
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE scope = ANY($1::TEXT[])  GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE scope = ANY($1::TEXT[])  GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN
(SELECT swidtag,total_cost FROM acqrights LEFT JOIN aggregations on acqrights.metric = aggregations.aggregation_metric WHERE acqrights.scope = ANY($1::TEXT[]) AND aggregations.aggregation_scope = ANY($1::TEXT[]) GROUP BY swidtag,total_cost) acq
ON p.swidtag = acq.swidtag
WHERE
  p.aggregation_id <> 0
  AND p.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(p.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(p.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(p.aggregation_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(p.aggregation_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(p.product_editor) = lower($9) ELSE TRUE END)
  GROUP BY p.aggregation_id, p.aggregation_name, p.product_editor
  ORDER BY
  CASE WHEN $11::bool THEN p.aggregation_name END asc,
  CASE WHEN $12::bool THEN p.aggregation_name END desc,
  CASE WHEN $13::bool THEN p.product_editor END asc,
  CASE WHEN $14::bool THEN p.product_editor END desc,
  CASE WHEN $15::bool THEN SUM(pa.num_of_applications) END asc,
  CASE WHEN $16::bool THEN SUM(pa.num_of_applications) END desc,
  CASE WHEN $17::bool THEN SUM(pe.num_of_equipments) END asc,
  CASE WHEN $18::bool THEN SUM(pe.num_of_equipments) END desc,
  CASE WHEN $19::bool THEN sum(acq.total_cost) END asc,
  CASE WHEN $20::bool THEN sum(acq.total_cost) END desc
  LIMIT $22 OFFSET $21
`

type ListAggregationsViewParams struct {
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkAggregationName     bool     `json:"lk_aggregation_name"`
	AggregationName       string   `json:"aggregation_name"`
	IsAggregationName     bool     `json:"is_aggregation_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	AggregationNameAsc    bool     `json:"aggregation_name_asc"`
	AggregationNameDesc   bool     `json:"aggregation_name_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListAggregationsViewRow struct {
	Totalrecords      int64    `json:"totalrecords"`
	AggregationID     int32    `json:"aggregation_id"`
	AggregationName   string   `json:"aggregation_name"`
	ProductEditor     string   `json:"product_editor"`
	Swidtags          []string `json:"swidtags"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	TotalCost         float64  `json:"total_cost"`
}

func (q *Queries) ListAggregationsView(ctx context.Context, arg ListAggregationsViewParams) ([]ListAggregationsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listAggregationsView,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkAggregationName,
		arg.AggregationName,
		arg.IsAggregationName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.AggregationNameAsc,
		arg.AggregationNameDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAggregationsViewRow
	for rows.Next() {
		var i ListAggregationsViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.AggregationID,
			&i.AggregationName,
			&i.ProductEditor,
			pq.Array(&i.Swidtags),
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditors = `-- name: ListEditors :many
SELECT DISTINCT ON (p.product_editor) p.product_editor 
FROM products p 
WHERE p.scope = ANY($1::TEXT[]) AND LENGTH(p.product_editor) > 0
`

func (q *Queries) ListEditors(ctx context.Context, scope []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEditors, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEditorsForAggregation = `-- name: ListEditorsForAggregation :many
SELECT DISTINCT acq.product_editor 
FROM acqrights acq 
WHERE acq.scope = $1 AND acq.product_editor <> ''
UNION
SELECT DISTINCT prd.product_editor 
FROM products prd 
WHERE prd.scope = $1 AND prd.product_editor <> ''
`

func (q *Queries) ListEditorsForAggregation(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listEditorsForAggregation, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var product_editor string
		if err := rows.Scan(&product_editor); err != nil {
			return nil, err
		}
		items = append(items, product_editor)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetricsForAggregation = `-- name: ListMetricsForAggregation :many
SELECT DISTINCT acq.metric
FROM acqrights acq
WHERE acq.scope = $1
`

func (q *Queries) ListMetricsForAggregation(ctx context.Context, scope string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listMetricsForAggregation, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var metric string
		if err := rows.Scan(&metric); err != nil {
			return nil, err
		}
		items = append(items, metric)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductAggregation = `-- name: ListProductAggregation :many
SELECT
    DISTINCT ag.aggregation_name as aggregation_name,
   	ag.product_editor,
   	swidtags,
   	coalesce(pe.num_of_equipments,0) as num_of_equipments,
   	coalesce(pa.num_of_applications,0) as num_of_applications,
   	ag.id,
   	ag.total_cost
FROM
    aggregated_rights ag
    INNER JOIN (
        SELECT
            pa.swidtag,
            count(pa.application_id) as num_of_applications
        FROM
            products_applications pa
        WHERE
            pa.scope = $1
        GROUP BY
            pa.swidtag
    ) pa ON pa.swidtag = ANY(ag.swidtags)
    INNER JOIN (
        SELECT
            pe.swidtag,
            count(pe.equipment_id) as num_of_equipments
        FROM
            products_equipments pe
        WHERE
            pe.scope = $1
        GROUP BY
            pe.swidtag
    ) pe ON pe.swidtag = ANY(ag.swidtags)
WHERE
    scope = $1
LIMIT
    $3 OFFSET $2
`

type ListProductAggregationParams struct {
	Scope    string `json:"scope"`
	PageNum  int32  `json:"page_num"`
	PageSize int32  `json:"page_size"`
}

type ListProductAggregationRow struct {
	AggregationName   string          `json:"aggregation_name"`
	ProductEditor     string          `json:"product_editor"`
	Swidtags          []string        `json:"swidtags"`
	NumOfEquipments   int64           `json:"num_of_equipments"`
	NumOfApplications int64           `json:"num_of_applications"`
	ID                int32           `json:"id"`
	TotalCost         decimal.Decimal `json:"total_cost"`
}

func (q *Queries) ListProductAggregation(ctx context.Context, arg ListProductAggregationParams) ([]ListProductAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductAggregation, arg.Scope, arg.PageNum, arg.PageSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductAggregationRow
	for rows.Next() {
		var i ListProductAggregationRow
		if err := rows.Scan(
			&i.AggregationName,
			&i.ProductEditor,
			pq.Array(&i.Swidtags),
			&i.NumOfEquipments,
			&i.NumOfApplications,
			&i.ID,
			&i.TotalCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsAggregationIndividual = `-- name: ListProductsAggregationIndividual :many
SELECT p.swidtag, product_name, product_version, product_edition, product_category, p.product_editor, p.scope, option_of, aggregation_id, p.aggregation_name, p.created_on, p.created_by, p.updated_on, p.updated_by, pa.swidtag, num_of_applications, products_applications.swidtag, application_id, products_applications.scope, pe.swidtag, num_of_equipments, products_equipments.swidtag, equipment_id, num_of_users, products_equipments.scope, ar.id, ar.aggregation_name, ar.sku, ar.product_editor, ar.metric, ar.products, ar.swidtags, ar.scope, ar.num_licenses_acquired, ar.num_licences_computed, ar.num_licences_maintainance, ar.avg_unit_price, ar.avg_maintenance_unit_price, ar.total_purchase_cost, ar.total_computed_cost, ar.total_maintenance_cost, ar.total_cost, ar.start_of_maintenance, ar.end_of_maintenance, ar.comment, ar.created_on, ar.created_by, ar.updated_on, ar.updated_by, aggregated_rights.id, aggregated_rights.aggregation_name, aggregated_rights.sku, aggregated_rights.product_editor, aggregated_rights.metric, aggregated_rights.products, aggregated_rights.swidtags, aggregated_rights.scope, aggregated_rights.num_licenses_acquired, aggregated_rights.num_licences_computed, aggregated_rights.num_licences_maintainance, aggregated_rights.avg_unit_price, aggregated_rights.avg_maintenance_unit_price, aggregated_rights.total_purchase_cost, aggregated_rights.total_computed_cost, aggregated_rights.total_maintenance_cost, aggregated_rights.total_cost, aggregated_rights.start_of_maintenance, aggregated_rights.end_of_maintenance, aggregated_rights.comment, aggregated_rights.created_on, aggregated_rights.created_by, aggregated_rights.updated_on, aggregated_rights.updated_by ,COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications,COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments
FROM products p 
LEFT JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE scope = p.scope  GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE scope = p.scope  GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN 
(SELECT id, aggregation_name, sku, product_editor, metric, products, swidtags, scope, num_licenses_acquired, num_licences_computed, num_licences_maintainance, avg_unit_price, avg_maintenance_unit_price, total_purchase_cost, total_computed_cost, total_maintenance_cost, total_cost, start_of_maintenance, end_of_maintenance, comment, created_on, created_by, updated_on, updated_by  FROM aggregated_rights WHERE scope = p.scope  GROUP BY swidtag) ar
ON p.swidtag = ar.swidtag
WHERE p.aggregation_name = $1 and p.scope = ANY($2::TEXT[])
`

type ListProductsAggregationIndividualParams struct {
	AggregationName string   `json:"aggregation_name"`
	Scope           []string `json:"scope"`
}

type ListProductsAggregationIndividualRow struct {
	Swidtag                   string          `json:"swidtag"`
	ProductName               string          `json:"product_name"`
	ProductVersion            string          `json:"product_version"`
	ProductEdition            string          `json:"product_edition"`
	ProductCategory           string          `json:"product_category"`
	ProductEditor             string          `json:"product_editor"`
	Scope                     string          `json:"scope"`
	OptionOf                  string          `json:"option_of"`
	AggregationID             int32           `json:"aggregation_id"`
	AggregationName           string          `json:"aggregation_name"`
	CreatedOn                 time.Time       `json:"created_on"`
	CreatedBy                 string          `json:"created_by"`
	UpdatedOn                 time.Time       `json:"updated_on"`
	UpdatedBy                 sql.NullString  `json:"updated_by"`
	Swidtag_2                 string          `json:"swidtag_2"`
	NumOfApplications         int64           `json:"num_of_applications"`
	Swidtag_3                 string          `json:"swidtag_3"`
	ApplicationID             string          `json:"application_id"`
	Scope_2                   string          `json:"scope_2"`
	Swidtag_4                 string          `json:"swidtag_4"`
	NumOfEquipments           int64           `json:"num_of_equipments"`
	Swidtag_5                 string          `json:"swidtag_5"`
	EquipmentID               string          `json:"equipment_id"`
	NumOfUsers                sql.NullInt32   `json:"num_of_users"`
	Scope_3                   string          `json:"scope_3"`
	ID                        int32           `json:"id"`
	AggregationName_2         string          `json:"aggregation_name_2"`
	Sku                       string          `json:"sku"`
	ProductEditor_2           string          `json:"product_editor_2"`
	Metric                    string          `json:"metric"`
	Products                  []string        `json:"products"`
	Swidtags                  []string        `json:"swidtags"`
	Scope_4                   string          `json:"scope_4"`
	NumLicensesAcquired       int32           `json:"num_licenses_acquired"`
	NumLicencesComputed       int32           `json:"num_licences_computed"`
	NumLicencesMaintainance   int32           `json:"num_licences_maintainance"`
	AvgUnitPrice              decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice   decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost         decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost         decimal.Decimal `json:"total_computed_cost"`
	TotalMaintenanceCost      decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost                 decimal.Decimal `json:"total_cost"`
	StartOfMaintenance        sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance          sql.NullTime    `json:"end_of_maintenance"`
	Comment                   sql.NullString  `json:"comment"`
	CreatedOn_2               time.Time       `json:"created_on_2"`
	CreatedBy_2               string          `json:"created_by_2"`
	UpdatedOn_2               time.Time       `json:"updated_on_2"`
	UpdatedBy_2               sql.NullString  `json:"updated_by_2"`
	ID_2                      int32           `json:"id_2"`
	AggregationName_3         string          `json:"aggregation_name_3"`
	Sku_2                     string          `json:"sku_2"`
	ProductEditor_3           string          `json:"product_editor_3"`
	Metric_2                  string          `json:"metric_2"`
	Products_2                []string        `json:"products_2"`
	Swidtags_2                []string        `json:"swidtags_2"`
	Scope_5                   string          `json:"scope_5"`
	NumLicensesAcquired_2     int32           `json:"num_licenses_acquired_2"`
	NumLicencesComputed_2     int32           `json:"num_licences_computed_2"`
	NumLicencesMaintainance_2 int32           `json:"num_licences_maintainance_2"`
	AvgUnitPrice_2            decimal.Decimal `json:"avg_unit_price_2"`
	AvgMaintenanceUnitPrice_2 decimal.Decimal `json:"avg_maintenance_unit_price_2"`
	TotalPurchaseCost_2       decimal.Decimal `json:"total_purchase_cost_2"`
	TotalComputedCost_2       decimal.Decimal `json:"total_computed_cost_2"`
	TotalMaintenanceCost_2    decimal.Decimal `json:"total_maintenance_cost_2"`
	TotalCost_2               decimal.Decimal `json:"total_cost_2"`
	StartOfMaintenance_2      sql.NullTime    `json:"start_of_maintenance_2"`
	EndOfMaintenance_2        sql.NullTime    `json:"end_of_maintenance_2"`
	Comment_2                 sql.NullString  `json:"comment_2"`
	CreatedOn_3               time.Time       `json:"created_on_3"`
	CreatedBy_3               string          `json:"created_by_3"`
	UpdatedOn_3               time.Time       `json:"updated_on_3"`
	UpdatedBy_3               sql.NullString  `json:"updated_by_3"`
	NumOfApplications_2       int32           `json:"num_of_applications_2"`
	NumOfEquipments_2         int32           `json:"num_of_equipments_2"`
}

func (q *Queries) ListProductsAggregationIndividual(ctx context.Context, arg ListProductsAggregationIndividualParams) ([]ListProductsAggregationIndividualRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsAggregationIndividual, arg.AggregationName, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsAggregationIndividualRow
	for rows.Next() {
		var i ListProductsAggregationIndividualRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductEdition,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.Scope,
			&i.OptionOf,
			&i.AggregationID,
			&i.AggregationName,
			&i.CreatedOn,
			&i.CreatedBy,
			&i.UpdatedOn,
			&i.UpdatedBy,
			&i.Swidtag_2,
			&i.NumOfApplications,
			&i.Swidtag_3,
			&i.ApplicationID,
			&i.Scope_2,
			&i.Swidtag_4,
			&i.NumOfEquipments,
			&i.Swidtag_5,
			&i.EquipmentID,
			&i.NumOfUsers,
			&i.Scope_3,
			&i.ID,
			&i.AggregationName_2,
			&i.Sku,
			&i.ProductEditor_2,
			&i.Metric,
			pq.Array(&i.Products),
			pq.Array(&i.Swidtags),
			&i.Scope_4,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.NumLicencesMaintainance,
			&i.AvgUnitPrice,
			&i.AvgMaintenanceUnitPrice,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.TotalMaintenanceCost,
			&i.TotalCost,
			&i.StartOfMaintenance,
			&i.EndOfMaintenance,
			&i.Comment,
			&i.CreatedOn_2,
			&i.CreatedBy_2,
			&i.UpdatedOn_2,
			&i.UpdatedBy_2,
			&i.ID_2,
			&i.AggregationName_3,
			&i.Sku_2,
			&i.ProductEditor_3,
			&i.Metric_2,
			pq.Array(&i.Products_2),
			pq.Array(&i.Swidtags_2),
			&i.Scope_5,
			&i.NumLicensesAcquired_2,
			&i.NumLicencesComputed_2,
			&i.NumLicencesMaintainance_2,
			&i.AvgUnitPrice_2,
			&i.AvgMaintenanceUnitPrice_2,
			&i.TotalPurchaseCost_2,
			&i.TotalComputedCost_2,
			&i.TotalMaintenanceCost_2,
			&i.TotalCost_2,
			&i.StartOfMaintenance_2,
			&i.EndOfMaintenance_2,
			&i.Comment_2,
			&i.CreatedOn_3,
			&i.CreatedBy_3,
			&i.UpdatedOn_3,
			&i.UpdatedBy_3,
			&i.NumOfApplications_2,
			&i.NumOfEquipments_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsForAggregation = `-- name: ListProductsForAggregation :many
SELECT acq.swidtag, acq.product_name, acq.product_editor 
FROM acqrights acq 
WHERE acq.scope = $1 
AND acq.swidtag NOT IN (SELECT UNNEST(agg.swidtags) from aggregated_rights agg where agg.scope = $1 and agg.metric = $2) 
AND acq.metric = $2
AND acq.product_editor = $3
UNION
SELECT prd.swidtag, prd.product_name, prd.product_editor 
FROM products prd 
JOIN 
(SELECT swidtag FROM products_equipments WHERE scope = $1 GROUP BY swidtag) pe
ON prd.swidtag = pe.swidtag
WHERE prd.scope = $1 
AND prd.swidtag NOT IN (SELECT UNNEST(agg.swidtags) from aggregated_rights agg where agg.scope = $1 and agg.metric = $2)
AND prd.product_editor = $3
`

type ListProductsForAggregationParams struct {
	Scope  string `json:"scope"`
	Metric string `json:"metric"`
	Editor string `json:"editor"`
}

type ListProductsForAggregationRow struct {
	Swidtag       string `json:"swidtag"`
	ProductName   string `json:"product_name"`
	ProductEditor string `json:"product_editor"`
}

func (q *Queries) ListProductsForAggregation(ctx context.Context, arg ListProductsForAggregationParams) ([]ListProductsForAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsForAggregation, arg.Scope, arg.Metric, arg.Editor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsForAggregationRow
	for rows.Next() {
		var i ListProductsForAggregationRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName, &i.ProductEditor); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsView = `-- name: ListProductsView :many
SELECT count(*) OVER() AS totalRecords,p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications , COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments ,COALESCE(acq.total_cost,0)::FLOAT as cost 
FROM products p 
LEFT JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE scope = ANY($1::TEXT[]) GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE scope = ANY($1::TEXT[]) GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN
(SELECT swidtag, sum(total_cost) as total_cost FROM acqrights WHERE scope = ANY($1::TEXT[]) GROUP BY swidtag) acq
ON p.swidtag = acq.swidtag
WHERE
  p.scope = ANY($1::TEXT[])
  AND (CASE WHEN $2::bool THEN lower(p.swidtag) LIKE '%' || lower($3::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $4::bool THEN lower(p.swidtag) = lower($3) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN lower(p.product_name) LIKE '%' || lower($6::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN lower(p.product_name) = lower($6) ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.product_editor) LIKE '%' || lower($9::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $10::bool THEN lower(p.product_editor) = lower($9) ELSE TRUE END)
  GROUP BY p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition,pa.num_of_applications, pe.num_of_equipments,acq.total_cost
  ORDER BY
  CASE WHEN $11::bool THEN p.swidtag END asc,
  CASE WHEN $12::bool THEN p.swidtag END desc,
  CASE WHEN $13::bool THEN p.product_name END asc,
  CASE WHEN $14::bool THEN p.product_name END desc,
  CASE WHEN $15::bool THEN p.product_edition END asc,
  CASE WHEN $16::bool THEN p.product_edition END desc,
  CASE WHEN $17::bool THEN p.product_category END asc,
  CASE WHEN $18::bool THEN p.product_category END desc,
  CASE WHEN $19::bool THEN p.product_version END asc,
  CASE WHEN $20::bool THEN p.product_version END desc,
  CASE WHEN $21::bool THEN p.product_editor END asc,
  CASE WHEN $22::bool THEN p.product_editor END desc,
  CASE WHEN $23::bool THEN num_of_applications END asc,
  CASE WHEN $24::bool THEN num_of_applications END desc,
  CASE WHEN $25::bool THEN num_of_equipments END asc,
  CASE WHEN $26::bool THEN num_of_equipments END desc,
  CASE WHEN $27::bool THEN acq.total_cost END asc,
  CASE WHEN $28::bool THEN acq.total_cost END desc
  LIMIT $30 OFFSET $29
`

type ListProductsViewParams struct {
	Scope                 []string `json:"scope"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductCategoryAsc    bool     `json:"product_category_asc"`
	ProductCategoryDesc   bool     `json:"product_category_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRow struct {
	Totalrecords      int64   `json:"totalrecords"`
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListProductsView(ctx context.Context, arg ListProductsViewParams) ([]ListProductsViewRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsView,
		pq.Array(arg.Scope),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRow
	for rows.Next() {
		var i ListProductsViewRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsViewRedirectedApplication = `-- name: ListProductsViewRedirectedApplication :many
SELECT count(*) OVER() AS totalRecords,p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications , COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments,pe.equipment_ids, COALESCE(acq.total_cost,0)::FLOAT as cost 
FROM products p 
INNER JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE scope = ANY($1::TEXT[]) AND  (CASE WHEN $2::bool THEN application_id = $3 ELSE TRUE END) GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
LEFT JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments,  ARRAY_AGG(equipment_id)::TEXT[] as equipment_ids FROM products_equipments WHERE scope = ANY($1::TEXT[]) AND (CASE WHEN $4::bool THEN equipment_id = ANY($5::TEXT[]) ELSE TRUE END) GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN
(SELECT swidtag, sum(total_cost) as total_cost FROM acqrights WHERE scope = ANY($1::TEXT[]) GROUP BY swidtag) acq
ON p.swidtag = acq.swidtag
WHERE
  p.scope = ANY($1::TEXT[])
  AND (CASE WHEN $6::bool THEN lower(p.swidtag) LIKE '%' || lower($7::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.swidtag) = lower($7) ELSE TRUE END)
  AND (CASE WHEN $9::bool THEN lower(p.product_name) LIKE '%' || lower($10::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(p.product_name) = lower($10) ELSE TRUE END)
  AND (CASE WHEN $12::bool THEN lower(p.product_editor) LIKE '%' || lower($13::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(p.product_editor) = lower($13) ELSE TRUE END)
  GROUP BY p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition,pa.num_of_applications, pe.num_of_equipments, pe.equipment_ids, acq.total_cost
  ORDER BY
  CASE WHEN $15::bool THEN p.swidtag END asc,
  CASE WHEN $16::bool THEN p.swidtag END desc,
  CASE WHEN $17::bool THEN p.product_name END asc,
  CASE WHEN $18::bool THEN p.product_name END desc,
  CASE WHEN $19::bool THEN p.product_edition END asc,
  CASE WHEN $20::bool THEN p.product_edition END desc,
  CASE WHEN $21::bool THEN p.product_category END asc,
  CASE WHEN $22::bool THEN p.product_category END desc,
  CASE WHEN $23::bool THEN p.product_version END asc,
  CASE WHEN $24::bool THEN p.product_version END desc,
  CASE WHEN $25::bool THEN p.product_editor END asc,
  CASE WHEN $26::bool THEN p.product_editor END desc,
  CASE WHEN $27::bool THEN num_of_applications END asc,
  CASE WHEN $28::bool THEN num_of_applications END desc,
  CASE WHEN $29::bool THEN num_of_equipments END asc,
  CASE WHEN $30::bool THEN num_of_equipments END desc,
  CASE WHEN $31::bool THEN acq.total_cost END asc,
  CASE WHEN $32::bool THEN acq.total_cost END desc
  LIMIT $34 OFFSET $33
`

type ListProductsViewRedirectedApplicationParams struct {
	Scope                 []string `json:"scope"`
	IsApplicationID       bool     `json:"is_application_id"`
	ApplicationID         string   `json:"application_id"`
	IsEquipmentID         bool     `json:"is_equipment_id"`
	EquipmentIds          []string `json:"equipment_ids"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductCategoryAsc    bool     `json:"product_category_asc"`
	ProductCategoryDesc   bool     `json:"product_category_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRedirectedApplicationRow struct {
	Totalrecords      int64    `json:"totalrecords"`
	Swidtag           string   `json:"swidtag"`
	ProductName       string   `json:"product_name"`
	ProductVersion    string   `json:"product_version"`
	ProductCategory   string   `json:"product_category"`
	ProductEditor     string   `json:"product_editor"`
	ProductEdition    string   `json:"product_edition"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	EquipmentIds      []string `json:"equipment_ids"`
	Cost              float64  `json:"cost"`
}

func (q *Queries) ListProductsViewRedirectedApplication(ctx context.Context, arg ListProductsViewRedirectedApplicationParams) ([]ListProductsViewRedirectedApplicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsViewRedirectedApplication,
		pq.Array(arg.Scope),
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.IsEquipmentID,
		pq.Array(arg.EquipmentIds),
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRedirectedApplicationRow
	for rows.Next() {
		var i ListProductsViewRedirectedApplicationRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			pq.Array(&i.EquipmentIds),
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsViewRedirectedEquipment = `-- name: ListProductsViewRedirectedEquipment :many
SELECT count(*) OVER() AS totalRecords,p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition, COALESCE(pa.num_of_applications,0)::INTEGER as num_of_applications , COALESCE(pe.num_of_equipments,0)::INTEGER as num_of_equipments ,COALESCE(acq.total_cost,0)::FLOAT as cost 
FROM products p 
LEFT JOIN 
(SELECT swidtag, count(application_id) as num_of_applications FROM products_applications WHERE scope = ANY($1::TEXT[]) AND (CASE WHEN $2::bool THEN application_id = $3 ELSE TRUE END)  GROUP BY swidtag) pa
ON p.swidtag = pa.swidtag
INNER JOIN 
(SELECT swidtag, count(equipment_id) as num_of_equipments FROM products_equipments WHERE  scope = ANY($1::TEXT[]) AND (CASE WHEN $4::bool THEN equipment_id = $5 ELSE TRUE END)  GROUP BY swidtag) pe
ON p.swidtag = pe.swidtag
LEFT JOIN
(SELECT swidtag, sum(total_cost) as total_cost FROM acqrights WHERE scope = ANY($1::TEXT[]) GROUP BY swidtag) acq
ON p.swidtag = acq.swidtag
WHERE
  p.scope = ANY($1::TEXT[])
  AND (CASE WHEN $6::bool THEN lower(p.swidtag) LIKE '%' || lower($7::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $8::bool THEN lower(p.swidtag) = lower($7) ELSE TRUE END)
  AND (CASE WHEN $9::bool THEN lower(p.product_name) LIKE '%' || lower($10::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $11::bool THEN lower(p.product_name) = lower($10) ELSE TRUE END)
  AND (CASE WHEN $12::bool THEN lower(p.product_editor) LIKE '%' || lower($13::TEXT) || '%' ELSE TRUE END)
  AND (CASE WHEN $14::bool THEN lower(p.product_editor) = lower($13) ELSE TRUE END)
  GROUP BY p.swidtag,p.product_name,p.product_version,p.product_category,p.product_editor,p.product_edition,pa.num_of_applications, pe.num_of_equipments, acq.total_cost
  ORDER BY
  CASE WHEN $15::bool THEN p.swidtag END asc,
  CASE WHEN $16::bool THEN p.swidtag END desc,
  CASE WHEN $17::bool THEN p.product_name END asc,
  CASE WHEN $18::bool THEN p.product_name END desc,
  CASE WHEN $19::bool THEN p.product_edition END asc,
  CASE WHEN $20::bool THEN p.product_edition END desc,
  CASE WHEN $21::bool THEN p.product_category END asc,
  CASE WHEN $22::bool THEN p.product_category END desc,
  CASE WHEN $23::bool THEN p.product_version END asc,
  CASE WHEN $24::bool THEN p.product_version END desc,
  CASE WHEN $25::bool THEN p.product_editor END asc,
  CASE WHEN $26::bool THEN p.product_editor END desc,
  CASE WHEN $27::bool THEN num_of_applications END asc,
  CASE WHEN $28::bool THEN num_of_applications END desc,
  CASE WHEN $29::bool THEN num_of_equipments END asc,
  CASE WHEN $30::bool THEN num_of_equipments END desc,
  CASE WHEN $31::bool THEN acq.total_cost END asc,
  CASE WHEN $32::bool THEN acq.total_cost END desc
  LIMIT $34 OFFSET $33
`

type ListProductsViewRedirectedEquipmentParams struct {
	Scope                 []string `json:"scope"`
	IsApplicationID       bool     `json:"is_application_id"`
	ApplicationID         string   `json:"application_id"`
	IsEquipmentID         bool     `json:"is_equipment_id"`
	EquipmentID           string   `json:"equipment_id"`
	LkSwidtag             bool     `json:"lk_swidtag"`
	Swidtag               string   `json:"swidtag"`
	IsSwidtag             bool     `json:"is_swidtag"`
	LkProductName         bool     `json:"lk_product_name"`
	ProductName           string   `json:"product_name"`
	IsProductName         bool     `json:"is_product_name"`
	LkProductEditor       bool     `json:"lk_product_editor"`
	ProductEditor         string   `json:"product_editor"`
	IsProductEditor       bool     `json:"is_product_editor"`
	SwidtagAsc            bool     `json:"swidtag_asc"`
	SwidtagDesc           bool     `json:"swidtag_desc"`
	ProductNameAsc        bool     `json:"product_name_asc"`
	ProductNameDesc       bool     `json:"product_name_desc"`
	ProductEditionAsc     bool     `json:"product_edition_asc"`
	ProductEditionDesc    bool     `json:"product_edition_desc"`
	ProductCategoryAsc    bool     `json:"product_category_asc"`
	ProductCategoryDesc   bool     `json:"product_category_desc"`
	ProductVersionAsc     bool     `json:"product_version_asc"`
	ProductVersionDesc    bool     `json:"product_version_desc"`
	ProductEditorAsc      bool     `json:"product_editor_asc"`
	ProductEditorDesc     bool     `json:"product_editor_desc"`
	NumOfApplicationsAsc  bool     `json:"num_of_applications_asc"`
	NumOfApplicationsDesc bool     `json:"num_of_applications_desc"`
	NumOfEquipmentsAsc    bool     `json:"num_of_equipments_asc"`
	NumOfEquipmentsDesc   bool     `json:"num_of_equipments_desc"`
	CostAsc               bool     `json:"cost_asc"`
	CostDesc              bool     `json:"cost_desc"`
	PageNum               int32    `json:"page_num"`
	PageSize              int32    `json:"page_size"`
}

type ListProductsViewRedirectedEquipmentRow struct {
	Totalrecords      int64   `json:"totalrecords"`
	Swidtag           string  `json:"swidtag"`
	ProductName       string  `json:"product_name"`
	ProductVersion    string  `json:"product_version"`
	ProductCategory   string  `json:"product_category"`
	ProductEditor     string  `json:"product_editor"`
	ProductEdition    string  `json:"product_edition"`
	NumOfApplications int32   `json:"num_of_applications"`
	NumOfEquipments   int32   `json:"num_of_equipments"`
	Cost              float64 `json:"cost"`
}

func (q *Queries) ListProductsViewRedirectedEquipment(ctx context.Context, arg ListProductsViewRedirectedEquipmentParams) ([]ListProductsViewRedirectedEquipmentRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsViewRedirectedEquipment,
		pq.Array(arg.Scope),
		arg.IsApplicationID,
		arg.ApplicationID,
		arg.IsEquipmentID,
		arg.EquipmentID,
		arg.LkSwidtag,
		arg.Swidtag,
		arg.IsSwidtag,
		arg.LkProductName,
		arg.ProductName,
		arg.IsProductName,
		arg.LkProductEditor,
		arg.ProductEditor,
		arg.IsProductEditor,
		arg.SwidtagAsc,
		arg.SwidtagDesc,
		arg.ProductNameAsc,
		arg.ProductNameDesc,
		arg.ProductEditionAsc,
		arg.ProductEditionDesc,
		arg.ProductCategoryAsc,
		arg.ProductCategoryDesc,
		arg.ProductVersionAsc,
		arg.ProductVersionDesc,
		arg.ProductEditorAsc,
		arg.ProductEditorDesc,
		arg.NumOfApplicationsAsc,
		arg.NumOfApplicationsDesc,
		arg.NumOfEquipmentsAsc,
		arg.NumOfEquipmentsDesc,
		arg.CostAsc,
		arg.CostDesc,
		arg.PageNum,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsViewRedirectedEquipmentRow
	for rows.Next() {
		var i ListProductsViewRedirectedEquipmentRow
		if err := rows.Scan(
			&i.Totalrecords,
			&i.Swidtag,
			&i.ProductName,
			&i.ProductVersion,
			&i.ProductCategory,
			&i.ProductEditor,
			&i.ProductEdition,
			&i.NumOfApplications,
			&i.NumOfEquipments,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSelectedProductsForAggregration = `-- name: ListSelectedProductsForAggregration :many
SELECT acq.swidtag, acq.product_name, acq.product_editor
FROM acqrights acq 
WHERE acq.scope = $1 
AND acq.swidtag IN (SELECT UNNEST(agg.swidtags) from aggregated_rights agg where agg.scope = $1 and agg.id = $2) 
UNION
SELECT prd.swidtag, prd.product_name, prd.product_editor
FROM products prd 
WHERE prd.scope = $1 
AND prd.swidtag IN (SELECT UNNEST(agg.swidtags) from aggregated_rights agg where agg.scope = $1 and agg.id = $2)
`

type ListSelectedProductsForAggregrationParams struct {
	Scope string `json:"scope"`
	ID    int32  `json:"id"`
}

type ListSelectedProductsForAggregrationRow struct {
	Swidtag       string `json:"swidtag"`
	ProductName   string `json:"product_name"`
	ProductEditor string `json:"product_editor"`
}

func (q *Queries) ListSelectedProductsForAggregration(ctx context.Context, arg ListSelectedProductsForAggregrationParams) ([]ListSelectedProductsForAggregrationRow, error) {
	rows, err := q.db.QueryContext(ctx, listSelectedProductsForAggregration, arg.Scope, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSelectedProductsForAggregrationRow
	for rows.Next() {
		var i ListSelectedProductsForAggregrationRow
		if err := rows.Scan(&i.Swidtag, &i.ProductName, &i.ProductEditor); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overDeployedProductsCosts = `-- name: OverDeployedProductsCosts :many
SELECT swidtag as swid_tag, 
product_name as product_name, 
SUM(total_purchase_cost)::Numeric(15,2) as  total_purchase_cost,
total_computed_cost::Numeric(15,2) as total_computed_cost,
(SUM(total_purchase_cost)-total_computed_cost)::Numeric(15,2) as delta_cost
FROM acqrights 
WHERE
scope = $1
AND
product_editor = $2
GROUP BY swidtag, metric, product_name, total_computed_cost
HAVING (SUM(total_purchase_cost)-total_computed_cost) > 0
ORDER BY delta_cost DESC LIMIT 5
`

type OverDeployedProductsCostsParams struct {
	Scope         string `json:"scope"`
	ProductEditor string `json:"product_editor"`
}

type OverDeployedProductsCostsRow struct {
	SwidTag           string          `json:"swid_tag"`
	ProductName       string          `json:"product_name"`
	TotalPurchaseCost decimal.Decimal `json:"total_purchase_cost"`
	TotalComputedCost decimal.Decimal `json:"total_computed_cost"`
	DeltaCost         decimal.Decimal `json:"delta_cost"`
}

func (q *Queries) OverDeployedProductsCosts(ctx context.Context, arg OverDeployedProductsCostsParams) ([]OverDeployedProductsCostsRow, error) {
	rows, err := q.db.QueryContext(ctx, overDeployedProductsCosts, arg.Scope, arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverDeployedProductsCostsRow
	for rows.Next() {
		var i OverDeployedProductsCostsRow
		if err := rows.Scan(
			&i.SwidTag,
			&i.ProductName,
			&i.TotalPurchaseCost,
			&i.TotalComputedCost,
			&i.DeltaCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overDeployedProductsLicences = `-- name: OverDeployedProductsLicences :many
SELECT swidtag as swid_tag, 
product_name as product_name, 
SUM(num_licenses_acquired) as num_licenses_acquired,
num_licences_computed as num_licences_computed,
(SUM(num_licenses_acquired)-num_licences_computed) as delta
FROM acqrights 
WHERE
scope = $1
AND
product_editor = $2
GROUP BY swidtag, metric, product_name,num_licences_computed
HAVING (SUM(num_licenses_acquired)-num_licences_computed) > 0
ORDER BY delta ASC LIMIT 5
`

type OverDeployedProductsLicencesParams struct {
	Scope         string `json:"scope"`
	ProductEditor string `json:"product_editor"`
}

type OverDeployedProductsLicencesRow struct {
	SwidTag             string `json:"swid_tag"`
	ProductName         string `json:"product_name"`
	NumLicensesAcquired int64  `json:"num_licenses_acquired"`
	NumLicencesComputed int32  `json:"num_licences_computed"`
	Delta               int32  `json:"delta"`
}

func (q *Queries) OverDeployedProductsLicences(ctx context.Context, arg OverDeployedProductsLicencesParams) ([]OverDeployedProductsLicencesRow, error) {
	rows, err := q.db.QueryContext(ctx, overDeployedProductsLicences, arg.Scope, arg.ProductEditor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OverDeployedProductsLicencesRow
	for rows.Next() {
		var i OverDeployedProductsLicencesRow
		if err := rows.Scan(
			&i.SwidTag,
			&i.ProductName,
			&i.NumLicensesAcquired,
			&i.NumLicencesComputed,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const overdeployPercent = `-- name: OverdeployPercent :one
SELECT acq, delta_rights from (
SELECT
    sum(num_licenses_acquired)::Numeric(15,2) as acq,
    abs(sum(case when num_licenses_acquired > total_computed_licenses then num_licenses_acquired - total_computed_licenses else 0 end))::Numeric(15,2) as delta_rights
    from (
        select sum(num_licenses_acquired) as num_licenses_acquired,
        num_licences_computed as total_computed_licenses
        from acqrights
        where scope= $1 AND metric = ANY($2::TEXT[])
        group by swidtag,metric, num_licences_computed
    ) y
)x WHERE acq IS NOT NULL
`

type OverdeployPercentParams struct {
	Scope   string   `json:"scope"`
	Metrics []string `json:"metrics"`
}

type OverdeployPercentRow struct {
	Acq         decimal.Decimal `json:"acq"`
	DeltaRights decimal.Decimal `json:"delta_rights"`
}

func (q *Queries) OverdeployPercent(ctx context.Context, arg OverdeployPercentParams) (OverdeployPercentRow, error) {
	row := q.db.QueryRowContext(ctx, overdeployPercent, arg.Scope, pq.Array(arg.Metrics))
	var i OverdeployPercentRow
	err := row.Scan(&i.Acq, &i.DeltaRights)
	return i, err
}

const productAggregationChildOptions = `-- name: ProductAggregationChildOptions :many
SELECT p.swidtag,p.product_name,p.product_edition,p.product_editor,p.product_version
FROM products p 
WHERE p.option_of in (
SELECT p.swidtag
FROM products p
WHERE 
  p.aggregation_id = $1
  AND p.scope = ANY($2::TEXT[]))
AND p.scope = ANY($2::TEXT[])
`

type ProductAggregationChildOptionsParams struct {
	AggregationID int32    `json:"aggregation_id"`
	Scope         []string `json:"scope"`
}

type ProductAggregationChildOptionsRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEdition string `json:"product_edition"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) ProductAggregationChildOptions(ctx context.Context, arg ProductAggregationChildOptionsParams) ([]ProductAggregationChildOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, productAggregationChildOptions, arg.AggregationID, pq.Array(arg.Scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductAggregationChildOptionsRow
	for rows.Next() {
		var i ProductAggregationChildOptionsRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEdition,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productAggregationDetails = `-- name: ProductAggregationDetails :one
SELECT x.product_editor as editor,
    ARRAY_AGG(DISTINCT x.product_name)::TEXT [] as product_names,
    ARRAY_AGG(DISTINCT x.swidtag)::TEXT [] as product_swidtags,
    ARRAY_AGG(DISTINCT x.version)::TEXT[] as product_versions,
    COALESCE(SUM(pa.num_of_applications),0)::INTEGER as num_of_applications,
    COALESCE(SUM(pe.num_of_equipments),0)::INTEGER as num_of_equipments,
    x.aggregation_name as aggregation_name,
    x.aggregation_id as aggregation_id,
    x.aggregation_metric as metric
FROM(
        SELECT  acq.swidtag,
             acq.product_name,
            acq.product_editor,
            acq.version,
            agg.aggregation_id,
            agg.aggregation_name,
            agg.aggregation_metric
        FROM aggregations agg
            JOIN acqrights acq ON acq.swidtag = ANY(agg.products)
        WHERE acq.scope = $1
            AND agg.aggregation_scope = $1
            AND agg.aggregation_id = $2
            AND acq.metric = agg.aggregation_metric
        UNION
        SELECT prd.swidtag,
            prd.product_name,
            prd.product_editor,
            prd.product_version as version,
            agg.aggregation_id,
            agg.aggregation_name,
            agg.aggregation_metric
        FROM aggregations agg
            JOIN products prd ON prd.swidtag = ANY(agg.products)
        WHERE prd.scope = $1
            AND agg.aggregation_scope = $1
            AND agg.aggregation_id = $2
            AND prd.aggregation_id = agg.aggregation_id
    ) x
LEFT JOIN
(SELECT pa.swidtag, count(pa.application_id) as num_of_applications FROM products_applications pa WHERE pa.scope = $1 GROUP BY pa.swidtag) pa
ON pa.swidtag = x.swidtag
LEFT JOIN 
(SELECT pe.swidtag, count(pe.equipment_id) as num_of_equipments FROM products_equipments pe WHERE pe.scope = $1 GROUP BY pe.swidtag) pe
ON pe.swidtag = x.swidtag
GROUP BY x.product_editor,
    x.aggregation_id,
    x.aggregation_name,
    x.aggregation_metric
`

type ProductAggregationDetailsParams struct {
	Scope         string `json:"scope"`
	AggregationID int32  `json:"aggregation_id"`
}

type ProductAggregationDetailsRow struct {
	Editor            string   `json:"editor"`
	ProductNames      []string `json:"product_names"`
	ProductSwidtags   []string `json:"product_swidtags"`
	ProductVersions   []string `json:"product_versions"`
	NumOfApplications int32    `json:"num_of_applications"`
	NumOfEquipments   int32    `json:"num_of_equipments"`
	AggregationName   string   `json:"aggregation_name"`
	AggregationID     int32    `json:"aggregation_id"`
	Metric            string   `json:"metric"`
}

func (q *Queries) ProductAggregationDetails(ctx context.Context, arg ProductAggregationDetailsParams) (ProductAggregationDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, productAggregationDetails, arg.Scope, arg.AggregationID)
	var i ProductAggregationDetailsRow
	err := row.Scan(
		&i.Editor,
		pq.Array(&i.ProductNames),
		pq.Array(&i.ProductSwidtags),
		pq.Array(&i.ProductVersions),
		&i.NumOfApplications,
		&i.NumOfEquipments,
		&i.AggregationName,
		&i.AggregationID,
		&i.Metric,
	)
	return i, err
}

const productsNotAcquired = `-- name: ProductsNotAcquired :many
SELECT swidtag, product_name, product_editor, product_version  FROM products
WHERE products.swidtag NOT IN (SELECT swidtag FROM acqrights WHERE acqrights.scope = $1)
AND products.swidtag IN (SELECT swidtag FROM products_equipments WHERE products_equipments.scope = $1)
AND products.scope = $1
`

type ProductsNotAcquiredRow struct {
	Swidtag        string `json:"swidtag"`
	ProductName    string `json:"product_name"`
	ProductEditor  string `json:"product_editor"`
	ProductVersion string `json:"product_version"`
}

func (q *Queries) ProductsNotAcquired(ctx context.Context, scope string) ([]ProductsNotAcquiredRow, error) {
	rows, err := q.db.QueryContext(ctx, productsNotAcquired, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsNotAcquiredRow
	for rows.Next() {
		var i ProductsNotAcquiredRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.ProductVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productsNotDeployed = `-- name: ProductsNotDeployed :many
SELECT DISTINCT(swidtag), product_name, product_editor, version FROM acqrights
WHERE acqrights.swidtag NOT IN (SELECT swidtag FROM products_equipments WHERE products_equipments.scope = $1)
AND acqrights.scope = $1
`

type ProductsNotDeployedRow struct {
	Swidtag       string `json:"swidtag"`
	ProductName   string `json:"product_name"`
	ProductEditor string `json:"product_editor"`
	Version       string `json:"version"`
}

func (q *Queries) ProductsNotDeployed(ctx context.Context, scope string) ([]ProductsNotDeployedRow, error) {
	rows, err := q.db.QueryContext(ctx, productsNotDeployed, scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsNotDeployedRow
	for rows.Next() {
		var i ProductsNotDeployedRow
		if err := rows.Scan(
			&i.Swidtag,
			&i.ProductName,
			&i.ProductEditor,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const productsPerMetric = `-- name: ProductsPerMetric :many
SELECT metric, COUNT(swidtag) as num_products
from acqrights
WHERE scope = ANY($1::TEXT[])
GROUP BY metric
`

type ProductsPerMetricRow struct {
	Metric      string `json:"metric"`
	NumProducts int64  `json:"num_products"`
}

func (q *Queries) ProductsPerMetric(ctx context.Context, scope []string) ([]ProductsPerMetricRow, error) {
	rows, err := q.db.QueryContext(ctx, productsPerMetric, pq.Array(scope))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductsPerMetricRow
	for rows.Next() {
		var i ProductsPerMetricRow
		if err := rows.Scan(&i.Metric, &i.NumProducts); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAggregation = `-- name: UpdateAggregation :one
UPDATE aggregations
SET aggregation_name = $1,products = $2
WHERE aggregation_id = $3
AND aggregation_scope = $4
RETURNING aggregation_id, aggregation_name, aggregation_metric, aggregation_scope, products, created_on, created_by, updated_on, updated_by
`

type UpdateAggregationParams struct {
	AggregationName string   `json:"aggregation_name"`
	Products        []string `json:"products"`
	AggregationID   int32    `json:"aggregation_id"`
	Scope           string   `json:"scope"`
}

func (q *Queries) UpdateAggregation(ctx context.Context, arg UpdateAggregationParams) (Aggregation, error) {
	row := q.db.QueryRowContext(ctx, updateAggregation,
		arg.AggregationName,
		pq.Array(arg.Products),
		arg.AggregationID,
		arg.Scope,
	)
	var i Aggregation
	err := row.Scan(
		&i.AggregationID,
		&i.AggregationName,
		&i.AggregationMetric,
		&i.AggregationScope,
		pq.Array(&i.Products),
		&i.CreatedOn,
		&i.CreatedBy,
		&i.UpdatedOn,
		&i.UpdatedBy,
	)
	return i, err
}

const updateAggregationForProduct = `-- name: UpdateAggregationForProduct :exec
Update products set aggregation_id = $1, aggregation_name = $2 WHERE
aggregation_id = $3 AND scope = $4
`

type UpdateAggregationForProductParams struct {
	AggregationID    int32  `json:"aggregation_id"`
	AggregationName  string `json:"aggregation_name"`
	OldAggregationID int32  `json:"old_aggregation_id"`
	Scope            string `json:"scope"`
}

func (q *Queries) UpdateAggregationForProduct(ctx context.Context, arg UpdateAggregationForProductParams) error {
	_, err := q.db.ExecContext(ctx, updateAggregationForProduct,
		arg.AggregationID,
		arg.AggregationName,
		arg.OldAggregationID,
		arg.Scope,
	)
	return err
}

const upsertAcqRights = `-- name: UpsertAcqRights :exec
INSERT INTO acqrights (sku,swidtag,product_name,product_editor,scope,metric,num_licenses_acquired,avg_unit_price,avg_maintenance_unit_price,total_purchase_cost,total_maintenance_cost,total_cost,created_by,start_of_maintenance,end_of_maintenance,num_licences_maintainance,version,comment)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18)
ON CONFLICT (sku,scope)
DO
UPDATE SET swidtag = $2,product_name = $3,product_editor = $4,scope = $5,metric = $6,num_licenses_acquired = $7,
            avg_unit_price = $8,avg_maintenance_unit_price = $9,total_purchase_cost = $10,
            total_maintenance_cost = $11,total_cost = $12,updated_by = $13,start_of_maintenance = $14,end_of_maintenance = $15, num_licences_maintainance = $16, version = $17, comment = $18
`

type UpsertAcqRightsParams struct {
	Sku                     string          `json:"sku"`
	Swidtag                 string          `json:"swidtag"`
	ProductName             string          `json:"product_name"`
	ProductEditor           string          `json:"product_editor"`
	Scope                   string          `json:"scope"`
	Metric                  string          `json:"metric"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	CreatedBy               string          `json:"created_by"`
	StartOfMaintenance      sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance        sql.NullTime    `json:"end_of_maintenance"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	Version                 string          `json:"version"`
	Comment                 sql.NullString  `json:"comment"`
}

func (q *Queries) UpsertAcqRights(ctx context.Context, arg UpsertAcqRightsParams) error {
	_, err := q.db.ExecContext(ctx, upsertAcqRights,
		arg.Sku,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductEditor,
		arg.Scope,
		arg.Metric,
		arg.NumLicensesAcquired,
		arg.AvgUnitPrice,
		arg.AvgMaintenanceUnitPrice,
		arg.TotalPurchaseCost,
		arg.TotalMaintenanceCost,
		arg.TotalCost,
		arg.CreatedBy,
		arg.StartOfMaintenance,
		arg.EndOfMaintenance,
		arg.NumLicencesMaintainance,
		arg.Version,
		arg.Comment,
	)
	return err
}

const upsertAggregation = `-- name: UpsertAggregation :one
INSERT INTO aggregated_rights (
  aggregation_name,
  sku,
  scope,
  product_editor,
  metric,
  products,
  swidtags,
  num_licenses_acquired,
  avg_unit_price,
  avg_maintenance_unit_price,
  total_purchase_cost,
  total_maintenance_cost,
  total_cost,
  created_by,
  start_of_maintenance,
  end_of_maintenance,
  num_licences_maintainance,
  comment)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) ON CONFLICT (aggregation_name,sku,scope) DO
UPDATE
SET product_editor = $4,
    metric = $5,
    products = $6,
    swidtags = $7,
    num_licenses_acquired = $8,
    avg_unit_price = $9,
    avg_maintenance_unit_price = $10,
    total_purchase_cost = $11,
    total_maintenance_cost = $12,
    total_cost = $13,
    updated_by = $14,
    start_of_maintenance = $15,
    end_of_maintenance = $16,
    num_licences_maintainance = $17,
    comment = $18
RETURNING id
`

type UpsertAggregationParams struct {
	AggregationName         string          `json:"aggregation_name"`
	Sku                     string          `json:"sku"`
	Scope                   string          `json:"scope"`
	ProductEditor           string          `json:"product_editor"`
	Metric                  string          `json:"metric"`
	Products                []string        `json:"products"`
	Swidtags                []string        `json:"swidtags"`
	NumLicensesAcquired     int32           `json:"num_licenses_acquired"`
	AvgUnitPrice            decimal.Decimal `json:"avg_unit_price"`
	AvgMaintenanceUnitPrice decimal.Decimal `json:"avg_maintenance_unit_price"`
	TotalPurchaseCost       decimal.Decimal `json:"total_purchase_cost"`
	TotalMaintenanceCost    decimal.Decimal `json:"total_maintenance_cost"`
	TotalCost               decimal.Decimal `json:"total_cost"`
	CreatedBy               string          `json:"created_by"`
	StartOfMaintenance      sql.NullTime    `json:"start_of_maintenance"`
	EndOfMaintenance        sql.NullTime    `json:"end_of_maintenance"`
	NumLicencesMaintainance int32           `json:"num_licences_maintainance"`
	Comment                 sql.NullString  `json:"comment"`
}

func (q *Queries) UpsertAggregation(ctx context.Context, arg UpsertAggregationParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertAggregation,
		arg.AggregationName,
		arg.Sku,
		arg.Scope,
		arg.ProductEditor,
		arg.Metric,
		pq.Array(arg.Products),
		pq.Array(arg.Swidtags),
		arg.NumLicensesAcquired,
		arg.AvgUnitPrice,
		arg.AvgMaintenanceUnitPrice,
		arg.TotalPurchaseCost,
		arg.TotalMaintenanceCost,
		arg.TotalCost,
		arg.CreatedBy,
		arg.StartOfMaintenance,
		arg.EndOfMaintenance,
		arg.NumLicencesMaintainance,
		arg.Comment,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const upsertDashboardUpdates = `-- name: UpsertDashboardUpdates :exec
Insert into dashboard_audit (updated_at, next_update_at ,updated_by ,scope) values($1,$2,$3,$4)
on CONFLICT (scope) 
Do update set updated_at = $1, next_update_at = $2, updated_by = $3
`

type UpsertDashboardUpdatesParams struct {
	UpdatedAt    time.Time    `json:"updated_at"`
	NextUpdateAt sql.NullTime `json:"next_update_at"`
	UpdatedBy    string       `json:"updated_by"`
	Scope        string       `json:"scope"`
}

func (q *Queries) UpsertDashboardUpdates(ctx context.Context, arg UpsertDashboardUpdatesParams) error {
	_, err := q.db.ExecContext(ctx, upsertDashboardUpdates,
		arg.UpdatedAt,
		arg.NextUpdateAt,
		arg.UpdatedBy,
		arg.Scope,
	)
	return err
}

const upsertProduct = `-- name: UpsertProduct :exec
INSERT INTO products (swidtag, product_name, product_version, product_edition, product_category, product_editor,scope,option_of,created_on,created_by)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)
ON CONFLICT (swidtag,scope)
DO
 UPDATE SET product_name = $2, product_version = $3, product_edition = $4,product_category = $5,product_editor= $6,option_of=$8,updated_on=$11,updated_by=$12
`

type UpsertProductParams struct {
	Swidtag         string         `json:"swidtag"`
	ProductName     string         `json:"product_name"`
	ProductVersion  string         `json:"product_version"`
	ProductEdition  string         `json:"product_edition"`
	ProductCategory string         `json:"product_category"`
	ProductEditor   string         `json:"product_editor"`
	Scope           string         `json:"scope"`
	OptionOf        string         `json:"option_of"`
	CreatedOn       time.Time      `json:"created_on"`
	CreatedBy       string         `json:"created_by"`
	UpdatedOn       time.Time      `json:"updated_on"`
	UpdatedBy       sql.NullString `json:"updated_by"`
}

// SCOPE BASED CHANGE
func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) error {
	_, err := q.db.ExecContext(ctx, upsertProduct,
		arg.Swidtag,
		arg.ProductName,
		arg.ProductVersion,
		arg.ProductEdition,
		arg.ProductCategory,
		arg.ProductEditor,
		arg.Scope,
		arg.OptionOf,
		arg.CreatedOn,
		arg.CreatedBy,
		arg.UpdatedOn,
		arg.UpdatedBy,
	)
	return err
}

const upsertProductAggregation = `-- name: UpsertProductAggregation :exec
Update products set aggregation_id = $1, aggregation_name = $2 WHERE
swidtag = ANY($3::TEXT[]) AND scope = $4
`

type UpsertProductAggregationParams struct {
	AggregationID   int32    `json:"aggregation_id"`
	AggregationName string   `json:"aggregation_name"`
	Swidtags        []string `json:"swidtags"`
	Scope           string   `json:"scope"`
}

// SCOPE BASED CHANGE
func (q *Queries) UpsertProductAggregation(ctx context.Context, arg UpsertProductAggregationParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductAggregation,
		arg.AggregationID,
		arg.AggregationName,
		pq.Array(arg.Swidtags),
		arg.Scope,
	)
	return err
}

const upsertProductApplications = `-- name: UpsertProductApplications :exec

Insert into products_applications (swidtag, application_id,scope ) Values ($1,$2,$3) ON CONFLICT  (swidtag, application_id,scope)
Do NOTHING
`

type UpsertProductApplicationsParams struct {
	Swidtag       string `json:"swidtag"`
	ApplicationID string `json:"application_id"`
	Scope         string `json:"scope"`
}

func (q *Queries) UpsertProductApplications(ctx context.Context, arg UpsertProductApplicationsParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductApplications, arg.Swidtag, arg.ApplicationID, arg.Scope)
	return err
}

const upsertProductEquipments = `-- name: UpsertProductEquipments :exec

Insert into products_equipments (swidtag, equipment_id, num_of_users,scope ) Values ($1,$2,$3,$4 ) ON CONFLICT  (swidtag, equipment_id, scope)
Do Update set num_of_users = $3
`

type UpsertProductEquipmentsParams struct {
	Swidtag     string        `json:"swidtag"`
	EquipmentID string        `json:"equipment_id"`
	NumOfUsers  sql.NullInt32 `json:"num_of_users"`
	Scope       string        `json:"scope"`
}

func (q *Queries) UpsertProductEquipments(ctx context.Context, arg UpsertProductEquipmentsParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductEquipments,
		arg.Swidtag,
		arg.EquipmentID,
		arg.NumOfUsers,
		arg.Scope,
	)
	return err
}

const upsertProductPartial = `-- name: UpsertProductPartial :exec
INSERT INTO products (swidtag,scope,created_by)
VALUES ($1,$2,$3)
ON CONFLICT (swidtag,scope)
DO NOTHING
`

type UpsertProductPartialParams struct {
	Swidtag   string `json:"swidtag"`
	Scope     string `json:"scope"`
	CreatedBy string `json:"created_by"`
}

// SCOPE BASED CHANGE
func (q *Queries) UpsertProductPartial(ctx context.Context, arg UpsertProductPartialParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductPartial, arg.Swidtag, arg.Scope, arg.CreatedBy)
	return err
}
